(function() {
  define(['underscore', 'raven', 'backbone', 'app/models'], function(_, Raven, Backbone, models) {
    var BASE_URL, LANGUAGES, TIMEOUT, currentId, fetchAccessibilitySentences, ids, _buildTranslatedObject, _generateId, _parse;
    BASE_URL = 'http://www.hel.fi/palvelukarttaws/rest/v3/unit/';
    LANGUAGES = ['fi', 'sv', 'en'];
    TIMEOUT = 10000;
    _buildTranslatedObject = function(data, base) {
      return _.object(_.map(LANGUAGES, function(lang) {
        return [lang, data["" + base + "_" + lang]];
      }));
    };
    currentId = 0;
    ids = {};
    _generateId = function(content) {
      if (!(content in ids)) {
        ids[content] = currentId;
        currentId += 1;
      }
      return ids[content];
    };
    _parse = function(data) {
      var groups, sentences;
      sentences = {};
      groups = {};
      _.each(data.accessibility_sentences, function(sentence) {
        var group, key;
        group = _buildTranslatedObject(sentence, 'sentence_group');
        key = _generateId(group.fi);
        groups[key] = group;
        if (!(key in sentences)) {
          sentences[key] = [];
        }
        return sentences[key].push(_buildTranslatedObject(sentence, 'sentence'));
      });
      return {
        groups: groups,
        sentences: sentences
      };
    };
    fetchAccessibilitySentences = function(unit, callback) {
      var args;
      args = {
        dataType: 'jsonp',
        url: BASE_URL + unit.id,
        jsonpCallback: 'jcbAsc',
        cache: true,
        success: function(data) {
          return callback(_parse(data));
        },
        timeout: TIMEOUT,
        error: function(jqXHR, errorType, exception) {
          var context;
          context = {
            tags: {
              type: 'helfi_rest_api'
            },
            extra: {
              error_type: errorType,
              jqXHR: jqXHR
            }
          };
          if (errorType === 'timeout') {
            Raven.captureException(new Error("Timeout of " + TIMEOUT + "ms reached for " + (BASE_URL + unit.id)), context);
          } else {
            Raven.captureException(exception, context);
          }
          return callback({
            error: true
          });
        }
      };
      return this.xhr = $.ajax(args);
    };
    return {
      fetch: fetchAccessibilitySentences
    };
  });

}).call(this);

//

(function() {
  "use strict";
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['underscore', 'backbone'], function(_, Backbone) {
    var Accessibility;
    Accessibility = (function() {
      function Accessibility() {
        this._requestData = __bind(this._requestData, this);
        _.extend(this, Backbone.Events);
        this._requestData();
      }

      Accessibility.prototype._requestData = function() {
        var settings;
        settings = {
          url: "" + appSettings.service_map_backend + "/accessibility_rule/",
          success: (function(_this) {
            return function(data) {
              _this.rules = data.rules;
              _this.messages = data.messages;
              return _this.trigger('change');
            };
          })(this),
          error: (function(_this) {
            return function(data) {
              throw new Error("Unable to retrieve accessibility data");
            };
          })(this)
        };
        return Backbone.ajax(settings);
      };

      Accessibility.prototype._emitShortcoming = function(rule, messages) {
        var currentMessages, msg, requirementId, segment, segmentMessages;
        if (rule.msg === null || !(rule.msg in this.messages)) {
          return;
        }
        msg = this.messages[rule.msg];
        if (msg != null) {
          segment = rule.path[0];
          if (!(segment in messages)) {
            messages[segment] = [];
          }
          segmentMessages = messages[segment];
          requirementId = rule.requirement_id;
          if (!(requirementId in segmentMessages)) {
            segmentMessages[requirementId] = [];
          }
          currentMessages = segmentMessages[requirementId];
          if (rule.id === requirementId) {
            if (!currentMessages.length) {
              currentMessages.push(msg);
            }
          } else {
            currentMessages.push(msg);
          }
        }
      };

      Accessibility.prototype._calculateShortcomings = function(rule, properties, messages, level) {
        var isOkay, op, prop, retValues, val, _i, _len, _ref, _ref1;
        if (level == null) {
          level = None;
        }
        if (!(rule.operands[0] instanceof Object)) {
          op = rule.operands;
          prop = properties[op[0]];
          if (!prop) {
            return true;
          }
          val = op[1];
          if (rule.operator === 'NEQ') {
            isOkay = prop !== val;
          } else if (rule.operator === 'EQ') {
            isOkay = prop === val;
          } else {
            throw new Error("invalid operator " + rule.operator);
          }
          if (!isOkay) {
            this._emitShortcoming(rule, messages);
          }
          return isOkay;
        }
        retValues = [];
        _ref = rule.operands;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          op = _ref[_i];
          isOkay = this._calculateShortcomings(op, properties, messages, level = level + 1);
          retValues.push(isOkay);
        }
        if ((_ref1 = rule.operator) !== 'AND' && _ref1 !== 'OR') {
          throw new Error("invalid operator " + rule.operator);
        }
        if (rule.operator === 'AND' && __indexOf.call(retValues, false) < 0) {
          return true;
        }
        if (rule.operator === 'OR' && __indexOf.call(retValues, true) >= 0) {
          return true;
        }
        this._emitShortcoming(rule, messages);
        return false;
      };

      Accessibility.prototype.getShortcomings = function(properties, profile) {
        var level, messages, p, propById, rule, _i, _len;
        if (this.rules == null) {
          return {
            status: 'pending'
          };
        }
        propById = {};
        for (_i = 0, _len = properties.length; _i < _len; _i++) {
          p = properties[_i];
          propById[p.variable] = p.value;
        }
        messages = {};
        rule = this.rules[profile];
        level = 0;
        this._calculateShortcomings(rule, propById, messages, level = level);
        return {
          status: 'complete',
          messages: messages
        };
      };

      Accessibility.prototype.getTranslatedShortcomings = function(profiles, model) {
        var gatheredMessages, messages, msg, pid, requirementId, seen, segmentId, segmentMessages, shortcoming, shortcomings, translated, _i, _j, _len, _len1, _ref, _ref1;
        shortcomings = {};
        seen = {};
        _ref = _.keys(profiles);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pid = _ref[_i];
          shortcoming = this.getShortcomings(model.get('accessibility_properties'), pid);
          if (shortcoming.status !== 'complete') {
            return {
              status: 'pending',
              results: {}
            };
          }
          if (_.keys(shortcoming.messages).length) {
            _ref1 = shortcoming.messages;
            for (segmentId in _ref1) {
              segmentMessages = _ref1[segmentId];
              shortcomings[segmentId] = shortcomings[segmentId] || {};
              for (requirementId in segmentMessages) {
                messages = segmentMessages[requirementId];
                gatheredMessages = [];
                for (_j = 0, _len1 = messages.length; _j < _len1; _j++) {
                  msg = messages[_j];
                  translated = p13n.getTranslatedAttr(msg);
                  if (!(translated in seen)) {
                    seen[translated] = true;
                    gatheredMessages.push(msg);
                  }
                }
                if (gatheredMessages.length) {
                  shortcomings[segmentId][requirementId] = gatheredMessages;
                }
              }
            }
          }
        }
        return {
          status: 'success',
          results: shortcomings
        };
      };

      return Accessibility;

    })();
    return new Accessibility;
  });

}).call(this);

//

(function() {
  define(function() {
    var FINNISH_ALPHABET, alpha;
    FINNISH_ALPHABET = 'abcdefghijklmnopqrstuvwxyzåäö';
    alpha = function(direction, caseSensitive, alphabetOrder) {
      var compareLetters;
      if (alphabetOrder == null) {
        alphabetOrder = FINNISH_ALPHABET;
      }
      compareLetters = function(a, b) {
        var ia, ib, _ref;
        _ref = [alphabetOrder.indexOf(a), alphabetOrder.indexOf(b)], ia = _ref[0], ib = _ref[1];
        if (ia === -1 || ib === -1) {
          if (ib !== -1) {
            return a > 'a';
          }
          if (ia !== -1) {
            return 'a' > b;
          }
          return a > b;
        }
        return ia > ib;
      };
      direction = direction || 1;
      return function(a, b) {
        var length, pos;
        length = Math.min(a.length, b.length);
        caseSensitive = caseSensitive || false;
        if (!caseSensitive) {
          a = a.toLowerCase();
          b = b.toLowerCase();
        }
        pos = 0;
        while (a.charAt(pos) === b.charAt(pos) && pos < length) {
          pos++;
        }
        if (compareLetters(a.charAt(pos), b.charAt(pos))) {
          return direction;
        } else {
          return -direction;
        }
      };
    };
    return {
      makeComparator: alpha
    };
  });

}).call(this);

//

(function() {
  define(['TweenLite'], function(TweenLite) {
    var DURATION_IN_SECONDS, HORIZONTAL_MARGIN, getMoveDistanceInPx, getStartingLeft, getStartingTop, render;
    HORIZONTAL_MARGIN = 4;
    DURATION_IN_SECONDS = 0.3;
    getStartingLeft = function(contentWidth, animation) {
      switch (animation) {
        case 'left':
          return contentWidth + HORIZONTAL_MARGIN;
        case 'right':
          return -contentWidth - HORIZONTAL_MARGIN;
        default:
          return 0;
      }
    };
    getStartingTop = function(contentHeight, animation) {
      switch (animation) {
        case 'left':
          return -contentHeight;
        case 'right':
          return -contentHeight;
        default:
          return 0;
      }
    };
    getMoveDistanceInPx = function(distance, animation) {
      switch (animation) {
        case 'left':
          return "-=" + distance + "px";
        case 'right':
          return "+=" + distance + "px";
        default:
          return 0;
      }
    };
    render = function($container, $oldContent, $newContent, animation, callback) {
      var contentHeight, contentWidth, moveDistance;
      $container.append($newContent);
      contentHeight = $oldContent.height();
      contentWidth = $oldContent.width();
      moveDistance = getMoveDistanceInPx(contentWidth + HORIZONTAL_MARGIN, animation);
      $newContent.css({
        'position': 'relative',
        'left': getStartingLeft(contentWidth, animation),
        'top': getStartingTop(contentHeight, animation)
      });
      $oldContent.css({
        'position': 'relative'
      });
      return TweenLite.to([$oldContent, $newContent], DURATION_IN_SECONDS, {
        left: moveDistance,
        ease: Power2.easeOut,
        onComplete: function() {
          $oldContent.remove();
          $newContent.css({
            'left': 0,
            'top': 0
          });
          return typeof callback === "function" ? callback() : void 0;
        }
      });
    };
    return {
      render: render
    };
  });

}).call(this);

//

define [
    'underscore',
    'raven',
    'backbone',
    'app/models'
], (
    _,
    Raven,
    Backbone,
    models
) ->

    # This module is a temporary solution to fetch pre-generated
    # accessibility sentences before we can access all the data allowing
    # them to be generated on demand.

    BASE_URL = 'http://www.hel.fi/palvelukarttaws/rest/v3/unit/'
    LANGUAGES = ['fi', 'sv', 'en']
    TIMEOUT = 10000

    _buildTranslatedObject = (data, base) ->
        _.object _.map(LANGUAGES, (lang) ->
            [lang, data["#{base}_#{lang}"]])

    currentId = 0
    ids = {}
    _generateId = (content) ->
        unless content of ids
            ids[content] = currentId
            currentId += 1
        ids[content]

    _parse = (data) ->
        sentences = { }
        groups = { }
        _.each data.accessibility_sentences, (sentence) ->
            group = _buildTranslatedObject sentence, 'sentence_group'
            key = _generateId group.fi
            groups[key] = group
            unless key of sentences
                sentences[key] = []
            sentences[key].push _buildTranslatedObject(sentence, 'sentence')
        groups:
            groups
        sentences:
            sentences

    fetchAccessibilitySentences = (unit, callback) ->
        args =
            dataType: 'jsonp'
            url: BASE_URL + unit.id
            jsonpCallback: 'jcbAsc'
            cache: true
            success: (data) ->
                callback _parse(data)
            timeout: TIMEOUT
            error: (jqXHR, errorType, exception) ->
                context = {
                    tags:
                        type: 'helfi_rest_api'
                    extra:
                        error_type: errorType
                        jqXHR: jqXHR
                }

                if errorType == 'timeout'
                    Raven.captureException(
                        new Error("Timeout of #{TIMEOUT}ms reached for #{BASE_URL+unit.id}"),
                        context)
                else
                    Raven.captureException exception, context
                callback error: true
        @xhr = $.ajax args

    fetch:
        fetchAccessibilitySentences

"use strict"

define [
    'underscore',
    'backbone'
], (
    _,
    Backbone
) ->

    class Accessibility
        constructor: ->
            _.extend @, Backbone.Events
            #setTimeout @_requestData, 3000
            @_requestData()

        _requestData: =>
            settings =
                url: "#{appSettings.service_map_backend}/accessibility_rule/"
                success: (data) =>
                    @rules = data.rules
                    @messages = data.messages
                    @trigger 'change'
                error: (data) =>
                    throw new Error "Unable to retrieve accessibility data"
            Backbone.ajax settings
        _emitShortcoming: (rule, messages) ->
            if rule.msg == null or rule.msg not of @messages
                return
            msg = @messages[rule.msg]
            if msg?
                segment = rule.path[0]
                unless segment of messages
                    messages[segment] = []
                segmentMessages = messages[segment]
                requirementId = rule.requirement_id
                unless requirementId of segmentMessages
                    segmentMessages[requirementId] = []
                currentMessages = segmentMessages[requirementId]
                if rule.id == requirementId
                    # This is a top level requirement -
                    # only add top level message
                    # if there are no specific messages.
                    unless currentMessages.length
                        currentMessages.push msg
                else
                    currentMessages.push msg
            return

        _calculateShortcomings: (rule, properties, messages, level=None) ->
            if rule.operands[0] not instanceof Object
                op = rule.operands
                prop = properties[op[0]]
                # If the information is not supplied, pretend that everything
                # is fine.
                if not prop
                    return true
                val = op[1]
                if rule.operator == 'NEQ'
                    isOkay = prop != val
                else if rule.operator == 'EQ'
                    isOkay = prop == val
                else
                    throw new Error "invalid operator #{rule.operator}"
                if not isOkay
                    @_emitShortcoming rule, messages
                return isOkay

            retValues = []
            for op in rule.operands
                isOkay = @_calculateShortcomings op, properties, messages, level=level+1
                retValues.push isOkay

            if rule.operator not in ['AND', 'OR']
                throw new Error "invalid operator #{rule.operator}"
            if rule.operator == 'AND' and false not in retValues
                return true
            if rule.operator == 'OR' and true in retValues
                return true

            @_emitShortcoming rule, messages
            return false

        getShortcomings: (properties, profile) ->
            if not @rules?
                return status: 'pending'
            propById = {}
            for p in properties
                propById[p.variable] = p.value
            messages = {}
            rule = @rules[profile]
            level = 0
            @_calculateShortcomings rule, propById, messages, level=level
            status: 'complete'
            messages: messages

        getTranslatedShortcomings: (profiles, model) ->
            shortcomings = {}
            seen = {}
            for pid in _.keys profiles
                shortcoming = @getShortcomings model.get('accessibility_properties'), pid
                if shortcoming.status != 'complete'
                    return status: 'pending', results: {}
                if _.keys(shortcoming.messages).length
                    for segmentId, segmentMessages of shortcoming.messages
                        shortcomings[segmentId] = shortcomings[segmentId] or {}
                        for requirementId, messages of segmentMessages
                            gatheredMessages = []
                            for msg in messages
                                translated = p13n.getTranslatedAttr msg
                                if translated not of seen
                                    seen[translated] = true
                                    gatheredMessages.push msg
                            if gatheredMessages.length
                                shortcomings[segmentId][requirementId] = gatheredMessages
            status: 'success'
            results: shortcomings

    return new Accessibility

define ->

    FINNISH_ALPHABET = 'abcdefghijklmnopqrstuvwxyzåäö'

    # Thank you
    # http://stackoverflow.com/questions/3630645/how-to-compare-utf-8-strings-in-javascript/3633725#3633725
    alpha = (direction, caseSensitive, alphabetOrder = FINNISH_ALPHABET) ->
        compareLetters = (a, b) ->
            [ia, ib] = [alphabetOrder.indexOf(a), alphabetOrder.indexOf(b)]
            if ia == -1 or ib == -1
                if ib != -1
                    return a > 'a'
                if ia != -1
                    return 'a' > b
                return a > b
            ia > ib
        direction = direction or 1
        (a, b) ->
            length = Math.min a.length, b.length
            caseSensitive = caseSensitive or false
            if !caseSensitive
                a = a.toLowerCase()
                b = b.toLowerCase()
            pos = 0
            while a.charAt(pos) == b.charAt(pos) and pos < length
                pos++

            if compareLetters a.charAt(pos), b.charAt(pos)
                direction
            else
                -direction

    #a.sort alpha('ABCDEFGHIJKLMNOPQRSTUVWXYZaàâäbcçdeéèêëfghiïîjklmnñoôöpqrstuûüvwxyÿz')
    makeComparator: alpha

define [
    'TweenLite'
], (
    TweenLite
) ->

    HORIZONTAL_MARGIN = 4
    DURATION_IN_SECONDS = 0.3

    getStartingLeft = (contentWidth, animation) ->
        switch animation
            when 'left' then contentWidth + HORIZONTAL_MARGIN
            when 'right' then -contentWidth - HORIZONTAL_MARGIN
            else 0

    getStartingTop = (contentHeight, animation) ->
        switch animation
            when 'left' then -contentHeight
            when 'right' then -contentHeight
            else 0

    getMoveDistanceInPx = (distance, animation) ->
        switch animation
            when 'left' then "-=#{distance}px"
            when 'right' then "+=#{distance}px"
            else 0

    render = ($container, $oldContent, $newContent, animation, callback) ->
        # Add new content to DOM after the old content.
        $container.append $newContent

        # Measurements - calculate how much the new content needs to be moved.
        contentHeight = $oldContent.height()
        contentWidth = $oldContent.width()
        moveDistance = getMoveDistanceInPx contentWidth + HORIZONTAL_MARGIN, animation

        # Move the new content to correct starting position.
        $newContent.css(
            'position': 'relative'
            'left': getStartingLeft(contentWidth, animation)
            'top': getStartingTop(contentHeight, animation)
        )

        # Make sure the old old content is has position: relative for animations.
        $oldContent.css('position': 'relative')

        # Animate old content and new content.
        TweenLite.to([$oldContent, $newContent], DURATION_IN_SECONDS, {
            left: moveDistance,
            ease: Power2.easeOut,
            onComplete: () ->
                $oldContent.remove()
                $newContent.css 'left': 0, 'top': 0
                callback?()
        })

    return {
        render: render
    }

config =
    baseUrl: appSettings.static_path + 'vendor'
    paths:
        app: '../js'
    shim:
        bootstrap:
            deps: ['jquery']
        backbone:
            deps: ['underscore', 'jquery']
            exports: 'Backbone'
        'typeahead.bundle':
            deps: ['jquery']
        TweenLite:
            deps: ['CSSPlugin', 'EasePack']
        'leaflet.markercluster':
            deps: ['leaflet']
        'leaflet.activearea':
            deps: ['leaflet']
        'bootstrap-datetimepicker':
            deps: ['bootstrap']
        'bootstrap-tour':
            deps: ['bootstrap']
        'iexhr':
            deps: ['jquery']
        'leaflet.snogylop':
            deps: ['leaflet']
    config:
        'app/p13n': localStorageEnabled: true

requirejs.config config

requirejs ['leaflet'], (L) ->
    # Allow calling original getBounds when needed.
    # (leaflet.activearea overrides getBounds)
    L.Map.prototype._originalGetBounds = L.Map.prototype.getBounds

DEBUG_STATE = appSettings.debug_state
VERIFY_INVARIANTS = appSettings.verify_invariants

window.getIeVersion = ->
    isInternetExplorer = ->
        window.navigator.appName is "Microsoft Internet Explorer"

    if not isInternetExplorer()
        return false

    matches = new RegExp(" MSIE ([0-9]+)\\.([0-9])").exec window.navigator.userAgent
    return parseInt matches[1]

if appSettings.sentry_url
    config = {}
    if appSettings.sentry_disable
        config.shouldSendCallback = -> false
    requirejs ['raven'], (Raven) ->
        Raven.config(appSettings.sentry_url, config).install()
        Raven.setExtraContext gitCommit: appSettings.git_commit_id

# Disable Raven thrown errors on local
else
    requirejs ['raven'], (Raven) ->
        Raven.debug = false;

requirejs [
    'app/models',
    'app/p13n',
    'app/map-view',
    'app/landing',
    'app/color',
    'app/tour',
    'backbone',
    'backbone.marionette',
    'jquery',
    'i18next',
    'app/uservoice',
    'app/transit',
    'app/debug',
    'iexhr',
    'app/views/service-cart',
    'app/views/navigation',
    'app/views/personalisation',
    'app/views/language-selector',
    'app/views/title',
    'app/views/feedback-form',
    'app/views/feedback-confirmation',
    'app/views/feature-tour-start',
    'app/views/service-map-disclaimers',
    'app/views/exporting',
    'app/base',
    'app/widgets',
    'app/control',
    'app/router'
],
(
    Models,
    p13n,
    MapView,
    landingPage,
    ColorMatcher,
    tour,
    Backbone,
    Marionette,
    $,
    i18n,
    uservoice,
    transit,
    debug,
    iexhr,
    ServiceCartView,
    NavigationLayout,
    PersonalisationView,
    LanguageSelectorView,
    titleViews,
    FeedbackFormView,
    FeedbackConfirmationView,
    TourStartButton,
    disclaimers,
    ExportingView,
    sm,
    widgets,
    BaseControl,
    BaseRouter
) ->

    LOG = debug.log

    isFrontPage = =>
        Backbone.history.fragment == ''

    class AppControl extends BaseControl
        initialize: (appModels) ->
            super appModels
            #_.extend @, Backbone.Events

            @route = appModels.route
            # Selected events (always of length one)
            @selectedEvents = appModels.selectedEvents

            @_resetPendingFeedback appModels.pendingFeedback

            @listenTo p13n, 'change', (path, val) ->
                if path[path.length - 1] == 'city'
                    @_reFetchAllServiceUnits()

            if DEBUG_STATE
                @eventDebugger = new debug.EventDebugger appModels

        _resetPendingFeedback: (o) ->
            if o?
                @pendingFeedback = o
            else
                @pendingFeedback = new Models.FeedbackMessage()
            appModels.pendingFeedback = @pendingFeedback
            @listenTo appModels.pendingFeedback, 'sent', =>
                app.getRegion('feedbackFormContainer').show new FeedbackConfirmationView(appModels.pendingFeedback.get('unit'))

        atMostOneIsSet: (list) ->
            _.filter(list, (o) -> o.isSet()).length <= 1

        _verifyInvariants: ->
            unless @atMostOneIsSet [@services, @searchResults]
                return new Error "Active services and search results are mutually exclusive."
            unless @atMostOneIsSet [@selectedPosition, @selectedUnits]
                return new Error "Selected positions/units/events are mutually exclusive."
            unless @atMostOneIsSet [@searchResults, @selectedPosition]
                return new Error "Search results & selected position are mutually exclusive."
            return null

        reset: () ->
            @_setSelectedUnits()
            @_clearRadius()
            @selectedPosition.clear()
            @selectedDivision.clear()
            @route.clear()
            @units.reset []
            @services.reset [], silent: true
            @selectedEvents.reset []
            @_resetSearchResults()

        isStateEmpty: () ->
            @selectedPosition.isEmpty() and
            @services.isEmpty() and
            @selectedEvents.isEmpty()

        _resetSearchResults: ->
            @searchResults.query = null
            @searchResults.reset []
            if @selectedUnits.isSet()
                @units.reset [@selectedUnits.first()]
            else if not @units.isEmpty()
                @units.reset()

        clearUnits: (opts) ->
            # Only clears selected units, and bbox units,
            # not removed service units nor search results.
            @route.clear()
            if @searchResults.isSet()
                return
            if opts?.all
                @units.clearFilters()
                @units.reset [], bbox: true
                return
            if @services.isSet()
                return
            if @selectedPosition.isSet() and 'distance' of @units.filters
                return
            if opts?.bbox == false and 'bbox' of @units.filters
                return
            else if opts?.bbox and 'bbox' not of @units.filters
                return
            @units.clearFilters()
            resetOpts = bbox: opts?.bbox
            if opts.silent
                resetOpts.silent = true
            if opts?.bbox
                resetOpts.noRefit = true
            if @selectedUnits.isSet()
                @units.reset [@selectedUnits.first()], resetOpts
            else
                @units.reset [], resetOpts

        highlightUnit: (unit) ->
            @units.trigger 'unit:highlight', unit

        clearFilters: ->
            @units.clearFilters()

        clearSelectedUnit: ->
            @route.clear()
            @selectedUnits.each (u) -> u.set 'selected', false
            @_setSelectedUnits()
            @clearUnits all: false, bbox: false
            sm.resolveImmediately()

        selectEvent: (event) ->
            @_clearRadius()
            unit = event.getUnit()
            select = =>
                event.set 'unit', unit
                if unit?
                    @setUnit unit
                @selectedEvents.reset [event]
            if unit?
                unit.fetch
                    success: select
            else
                select()

        clearSelectedPosition: ->
            @selectedDivision.clear()
            @selectedPosition.clear()
            sm.resolveImmediately()

        resetPosition: (position) ->
            unless position?
                position = @selectedPosition.value()
                unless position?
                    position = new models.CoordinatePosition
                        isDetected: true
            position.clear()
            @listenToOnce p13n, 'position', (position) =>
                @selectPosition position
            p13n.requestLocation position

        clearSelectedEvent: ->
            @_clearRadius()
            @selectedEvents.set []
        removeUnit: (unit) ->
            @units.remove unit
            if unit == @selectedUnits.first()
                @clearSelectedUnit()
        removeUnits: (units) ->
            @units.remove units,
                silent: true
            @units.trigger 'batch-remove',
                removed: units

        _clearRadius: ->
            pos = @selectedPosition.value()
            if pos?
                hasFilter = pos.get 'radiusFilter'
                if hasFilter?
                    pos.set 'radiusFilter', null
                    @units.reset []

        _reFetchAllServiceUnits: ->
            if @services.length > 0
                @units.reset []
                @services.each (s) => @_fetchServiceUnits(s)


        removeService: (serviceId) ->
            service = @services.get serviceId
            @services.remove service
            unless service.get('units')?
                return
            otherServices = @services.filter (s) => s != service
            unitsToRemove = service.get('units').reject (unit) =>
                @selectedUnits.get(unit)? or
                _(otherServices).find (s) => s.get('units').get(unit)?
            @removeUnits unitsToRemove
            if @services.size() == 0
                if @selectedPosition.isSet()
                    @selectPosition @selectedPosition.value()
                    @selectedPosition.trigger 'change:value', @selectedPosition, @selectedPosition.value()
            sm.resolveImmediately()


        clearSearchResults: () ->
            @searchResults.query = null
            if not @searchResults.isEmpty()
                @_resetSearchResults()
            sm.resolveImmediately()

        closeSearch: ->
            if @isStateEmpty() then @home()
            sm.resolveImmediately()

        composeFeedback: (unit) ->
            app.getRegion('feedbackFormContainer').show new FeedbackFormView model: @pendingFeedback, unit: unit
            $('#feedback-form-container').on 'shown.bs.modal', ->
                $(@).children().attr('tabindex', -1).focus()
            $('#feedback-form-container').modal('show')

        closeFeedback: ->
            @_resetPendingFeedback()
            _.defer => app.getRegion('feedbackFormContainer').reset()

        showServiceMapDescription: ->
            app.getRegion('feedbackFormContainer').show new disclaimers.ServiceMapDisclaimersView()
            $('#feedback-form-container').modal('show')

        home: ->
            @reset()

    app = new Marionette.Application()

    appModels =
        services: new Models.ServiceList()
        selectedServices: new Models.ServiceList()
        units: new Models.UnitList null, setComparator: true
        selectedUnits: new Models.UnitList()
        selectedEvents: new Models.EventList()
        searchResults: new Models.SearchList [], pageSize: appSettings.page_size
        searchState: new Models.WrappedModel()
        route: new transit.Route()
        routingParameters: new Models.RoutingParameters()
        selectedPosition: new Models.WrappedModel()
        selectedDivision: new Models.WrappedModel()
        divisions: new models.AdministrativeDivisionList
        pendingFeedback: new Models.FeedbackMessage()

    cachedMapView = null
    makeMapView = (mapOpts) ->
        unless cachedMapView
            opts =
                units: appModels.units
                services: appModels.selectedServices
                selectedUnits: appModels.selectedUnits
                searchResults: appModels.searchResults
                selectedPosition: appModels.selectedPosition
                selectedDivision: appModels.selectedDivision
                route: appModels.route
                divisions: appModels.divisions
            cachedMapView = new MapView opts, mapOpts
            window.mapView = cachedMapView
            map = cachedMapView.map
            pos = appModels.routingParameters.pendingPosition
            pos.on 'request', (ev) => cachedMapView.requestLocation pos
            app.getRegion('map').show cachedMapView
            f = -> landingPage.clear()
            cachedMapView.map.addOneTimeEventListener
                'zoomstart': f
                'mousedown': f
            app.commands.execute 'setMapProxy', cachedMapView.getProxy()
        cachedMapView

    setSiteTitle = (routeTitle) ->
        # Sets the page title. Should be called when the view that is
        # considered the main view changes.
        title = "#{i18n.t('general.site_title')}"
        if routeTitle
            title = "#{p13n.getTranslatedAttr(routeTitle)} | " + title
        $('head title').text title

    class AppRouter extends BaseRouter
        initialize: (options) ->
            super options

            @appModels = options.models
            refreshServices = =>
                ids = @appModels.selectedServices.pluck('id').join ','
                if ids.length
                    "unit?service=#{ids}"
                else
                    if @appModels.selectedPosition.isSet()
                        @fragmentFunctions.selectPosition()
                    else
                        ""
            blank = => ""

            @fragmentFunctions =
                selectUnit: =>
                    id = @appModels.selectedUnits.first().id
                    "unit/#{id}"
                search: (params) =>
                    query = params[0]
                    "search?q=#{query}"
                selectPosition: =>
                    slug = @appModels.selectedPosition.value().slugifyAddress()
                    "address/#{slug}"
                addService: refreshServices
                removeService: refreshServices
                clearSelectedPosition: blank
                clearSelectedUnit: blank
                clearSearchResults: blank
                closeSearch: blank
                home: blank

        _getFragment: (commandString, parameters) ->
            @fragmentFunctions[commandString]?(parameters)

        navigateByCommand: (commandString, parameters) ->
            fragment = @_getFragment commandString, parameters
            if fragment?
                @navigate fragment
                p13n.trigger 'url'

        onPostRouteExecute: ->
            if isFrontPage() and not p13n.get('skip_tour') and not p13n.get('hide_tour')
                tour.startTour()

    app.addRegions
        navigation: '#navigation-region'
        personalisation: '#personalisation'
        exporting: '#exporting'
        languageSelector: '#language-selector'
        serviceCart: '#service-cart'
        landingLogo: '#landing-logo'
        logo: '#persistent-logo'
        map: '#app-container'
        tourStart: '#feature-tour-start'
        feedbackFormContainer: '#feedback-form-container'
        disclaimerContainer: '#disclaimers'

    app.addInitializer (opts) ->

        window.debugAppModels = appModels
        appModels.services.fetch
            data:
                level: 0

        appControl = new AppControl appModels
        router = new AppRouter models: appModels, controller: appControl, makeMapView: makeMapView
        appControl.router = router

        COMMANDS = [
            "addService",
            "removeService",

            "selectUnit",
            "highlightUnit",
            "clearSelectedUnit",

            "selectPosition",
            "clearSelectedPosition",
            "resetPosition"

            "selectEvent",
            "clearSelectedEvent",

            "toggleDivision",

            "clearFilters",

            "setUnits",
            "setUnit",
            "addUnitsWithinBoundingBoxes"

            "search",
            "clearSearchResults",
            "closeSearch",

            "setRadiusFilter"
            "home"

            "composeFeedback",
            "closeFeedback",

            "hideTour",
            "showServiceMapDescription",

            "setMapProxy"
        ]
        reportError = (position, command) ->
            e = appControl._verifyInvariants()
            if e
                message = "Invariant failed #{position} command #{command}: #{e.message}"
                LOG appModels
                e.message = message
                throw e

        commandInterceptor = (comm, parameters) ->
            appControl[comm].apply(appControl, parameters)?.done? =>
                unless parameters[0]?.navigate == false
                    router.navigateByCommand comm, parameters

        makeInterceptor = (comm) ->
            if DEBUG_STATE
                ->
                    LOG "COMMAND #{comm} CALLED"
                    commandInterceptor comm, arguments
                    LOG appModels
            else if VERIFY_INVARIANTS
                ->
                    LOG "COMMAND #{comm} CALLED"
                    reportError "before", comm
                    commandInterceptor comm, arguments
                    reportError "after", comm
            else
                ->
                    commandInterceptor comm, arguments

        for comm in COMMANDS
            @commands.setHandler comm, makeInterceptor(comm)

        navigation = new NavigationLayout
            serviceTreeCollection: appModels.services
            selectedServices: appModels.selectedServices
            searchResults: appModels.searchResults
            selectedUnits: appModels.selectedUnits
            selectedEvents: appModels.selectedEvents
            searchState: appModels.searchState
            route: appModels.route
            units: appModels.units
            routingParameters: appModels.routingParameters
            selectedPosition: appModels.selectedPosition

        @getRegion('navigation').show navigation
        @getRegion('landingLogo').show new titleViews.LandingTitleView
        @getRegion('logo').show new titleViews.TitleView

        personalisation = new PersonalisationView
        @getRegion('personalisation').show personalisation

        exportingView = new ExportingView()
        @getRegion('exporting').show exportingView

        languageSelector = new LanguageSelectorView
            p13n: p13n
        @getRegion('languageSelector').show languageSelector

        serviceCart = new ServiceCartView
            collection: appModels.selectedServices
        @getRegion('serviceCart').show serviceCart

        # The colors are dependent on the currently selected services.
        @colorMatcher = new ColorMatcher appModels.selectedServices

        f = -> landingPage.clear()
        $('body').one "keydown", f
        $('body').one "click", f

        Backbone.history.start
            pushState: true
            root: appSettings.url_prefix

        # Prevent empty anchors from appending a '#' to the URL bar but
        # still allow external links to work.
        $('body').on 'click', 'a', (ev) ->
            target = $(ev.currentTarget)
            if not target.hasClass('external-link') and not target.hasClass('force')
                ev.preventDefault()

        @listenTo app.vent, 'site-title:change', setSiteTitle

        showButton = =>
            tourButtonView = new TourStartButton()
            app.getRegion('tourStart').show tourButtonView
            @listenToOnce tourButtonView, 'close', => app.getRegion('tourStart').reset()
        if p13n.get('skip_tour')
            showButton()
        @listenTo p13n, 'tour-skipped', =>
            showButton()

        app.getRegion('disclaimerContainer').show new disclaimers.ServiceMapDisclaimersOverlayView

    app.addInitializer widgets.initializer

    window.app = app

    # We wait for p13n/i18next to finish loading before firing up the UI
    $.when(p13n.deferred).done ->
        $('html').attr 'lang', p13n.getLanguage()
        app.start()
        if isFrontPage()
            if p13n.get('first_visit')
                $('body').addClass 'landing'
        $('#app-container').attr 'class', p13n.get('map_background_layer')
        p13n.setVisited()
        uservoice.init(p13n.getLanguage())

define ->
    mixOf: (base, mixins...) ->
        class Mixed extends base
            for mixin in mixins by -1 # earlier mixins override later ones
                for name, method of mixin::
                    Mixed::[name] = method
            Mixed

    resolveImmediately: ->
        $.Deferred().resolve().promise()

    withDeferred: (callback) ->
        deferred = $.Deferred()
        callback deferred
        deferred.promise()

    pad: (number) ->
        str = "" + number
        pad = "00000"
        pad.substring(0, pad.length - str.length) + str


define ->

    class ColorMatcher
        @serviceColors:
            # Housing and environment
            50000: [77,139,0]

            # Administration and economy
            50001: [192,79,220]

            # Culture and leisure
            50002: [252,173,0]

            # Maps, information services and communication
            50003: [154,0,0]

            # Teaching and education
            26412: [0,81,142]

            # Family and social services
            27918: [67,48,64]

            # Child daycare and pre-school education
            27718: [60,210,0]

            # Health care
            25000: [142,139,255]

            # Public safety
            26190: [240,66,0]

            # The following are not root services
            # in the simplified service tree
            # Legal protection and democracy
            #26244: [192,79,220]
            # Planning, real estate and construction
            #25142: [40,40,40]
            # Tourism and events
            #25954: [252,172,0]
            # Entrepreneurship, work and taxation
            #26098: [192,79,220]
            # Sports and physical exercise
            #28128: [252,173,0]

        constructor: (@selectedServices) ->
        @rgb: (r, g, b) ->
            return "rgb(#{r}, #{g}, #{b})"
        @rgba: (r, g, b, a) ->
            return "rgba(#{r}, #{g}, #{b}, #{a})"
        serviceColor: (service) ->
            @serviceRootIdColor service.get('root')
        serviceRootIdColor: (id) ->
            [r, g, b] = @constructor.serviceColors[id]
            @constructor.rgb(r, g, b)
        unitColor: (unit) ->
            roots = unit.get('root_services')
            if @selectedServices?
                rootService = _.find roots, (rid) =>
                    @selectedServices.find (s) ->
                        s.get('root') == rid
            unless rootService?
                rootService = roots[0]
            [r, g, b] = @constructor.serviceColors[rootService]
            @constructor.rgb(r, g, b)

    return ColorMatcher

define [
    'jquery',
    'backbone.marionette',
    'app/base',
    'app/models'
],
(
    $,
    Marionette,
    sm,
    Models
) ->

    PAGE_SIZE = appSettings.page_size

    class BaseControl extends Marionette.Controller
        initialize: (appModels) ->
            # Units currently on the map
            @units = appModels.units
            # Services in the cart
            @services = appModels.selectedServices
            # Selected units (always of length one)
            @selectedUnits = appModels.selectedUnits
            @selectedPosition = appModels.selectedPosition
            @searchResults = appModels.searchResults
            @divisions = appModels.divisions
            @selectedDivision = appModels.selectedDivision

        setMapProxy: (@mapProxy) ->

        setUnits: (units, filter) ->
            @services.set []
            @_setSelectedUnits()
            @units.reset units.toArray()
            if filter?
                @units.setFilter filter, true
            else
                @units.clearFilters()
            # Current cluster based map logic
            # requires batch reset signal.

        setUnit: (unit) ->
            @services.set []
            @units.reset [unit]

        getUnit: (id) ->
            return @units.get id

        _setSelectedUnits: (units, options) ->
            @selectedUnits.each (u) -> u.set 'selected', false
            if units?
                _(units).each (u) -> u.set 'selected', true
                @selectedUnits.reset units, options
            else
                if @selectedUnits.length
                    @selectedUnits.reset [], options

        selectUnit: (unit, opts) ->
            @selectedDivision.clear()
            @_setSelectedUnits? [unit], silent: true
            if opts?.replace
                @units.reset [unit]
                @units.clearFilters()
            else if not @units.contains unit
                @units.add unit
                @units.trigger 'reset', @units
            hasObject = (unit, key) ->
                o = unit.get(key)
                o? and typeof o == 'object'
            requiredObjects = ['department', 'municipality', 'services']
            unless _(requiredObjects).find((x)->!hasObject(unit, x))
                @selectedUnits.trigger 'reset', @selectedUnits
                sm.resolveImmediately()
            else
                unit.fetch
                    data: include: 'department,municipality,services'
                    success: => @selectedUnits.trigger 'reset', @selectedUnits

        addUnitsWithinBoundingBoxes: (bboxStrings, level) ->
            if level == 'none'
                return
            unless level?
                level = 'customer_service'
            bboxCount = bboxStrings.length
            if bboxCount > 4
                null
                # TODO: handle case.
            if @selectedPosition.value()?.get('radiusFilter')?
                return
            @units.clearFilters()
            getBbox = (bboxStrings) =>
                # Fetch bboxes sequentially
                if bboxStrings.length == 0
                    @units.setFilter 'bbox', true
                    @units.trigger 'finished',
                        keepViewport: true
                    return
                bboxString = _.first bboxStrings
                unitList = new models.UnitList null, forcedPriority: false
                opts = success: (coll, resp, options) =>
                    if unitList.length
                        @units.add unitList.toArray()
                    unless unitList.fetchNext(opts)
                        unitList.trigger 'finished',
                            keepViewport: true
                unitList.pageSize = PAGE_SIZE
                unitList.setFilter 'bbox', bboxString
                layer = p13n.get 'map_background_layer'
                unitList.setFilter 'bbox_srid', if layer in ['servicemap', 'accessible_map'] then 3067 else 3879
                unitList.setFilter 'only', 'name,location,root_services'
                if level?
                    unitList.setFilter 'level', level

                @listenTo unitList, 'finished', =>
                    getBbox _.rest(bboxStrings)
                unitList.fetch(opts)
            getBbox(bboxStrings)

        _clearRadius: ->
        clearSearchResults: ->
        clearUnits: ->
        reset: ->

        toggleDivision: (division) =>
            @_clearRadius()
            old = @selectedDivision.value()
            if old? then old.set 'selected', false
            if division == old
                @selectedDivision.clear()
            else
                @selectedDivision.wrap division
                division.set 'selected', true

        renderUnitById: (id) ->
            deferred = $.Deferred()
            unit = new Models.Unit id: id
            unit.fetch
                data:
                    include: 'department,municipality,services'
                success: =>
                    @setUnit unit
                    @selectUnit unit
                    deferred.resolve unit
            deferred.promise()

        selectPosition: (position) ->
            @clearSearchResults?()
            @_setSelectedUnits?()
            previous = @selectedPosition.value()
            if previous?.get('radiusFilter')?
                @units.reset []
                @units.clearFilters()
            if position == previous
                @selectedPosition.trigger 'change:value', @selectedPosition
            else
                @selectedPosition.wrap position
            sm.resolveImmediately()

        setRadiusFilter: (radius) ->
            @services.reset [], skip_navigate: true
            @units.reset []
            @units.clearFilters()
            @units.overrideComparatorKeys = [
                'distance_precalculated',
                'alphabetic',
                'alphabetic_reverse']
            @units.setComparator 'distance_precalculated'
            if @selectedPosition.isEmpty()
                return
            pos = @selectedPosition.value()
            pos.set 'radiusFilter', radius

            unitList = new models.UnitList [], pageSize: PAGE_SIZE
                .setFilter 'only', 'name,location,root_services'
                .setFilter 'include', 'services,accessibility_properties'
                .setFilter 'lat', pos.get('location').coordinates[1]
                .setFilter 'lon', pos.get('location').coordinates[0]
                .setFilter 'distance', radius
            opts =
                success: =>
                    @units.add unitList.toArray(), merge: true
                    @units.setFilter 'distance', radius
                    unless unitList.fetchNext opts
                        @units.trigger 'finished', refit: true
            unitList.fetch opts

        _addService: (service) ->
            @_clearRadius()
            @_setSelectedUnits()
            @services.add service
            if @services.length == 1
                # Remove possible units
                # that had been added through
                # other means than service
                # selection.
                @units.reset []
                @units.clearFilters()
                @units.setDefaultComparator()
                @clearSearchResults()

            if service.has 'ancestors'
                ancestor = @services.find (s) ->
                    s.id in service.get 'ancestors'
                if ancestor?
                    @removeService ancestor
            @_fetchServiceUnits service

        _fetchServiceUnits: (service) ->
            unitList = new models.UnitList [], pageSize: PAGE_SIZE, setComparator: true
                .setFilter('service', service.id)
                .setFilter('only', 'name,location,root_services')
                .setFilter('include', 'services,accessibility_properties')

            municipality = p13n.get 'city'
            if municipality
                unitList.setFilter 'municipality', municipality

            opts =
                # todo: re-enable
                #spinnerTarget: spinnerTarget
                success: =>
                    @units.add unitList.toArray(), merge: true
                    service.get('units').add unitList.toArray()
                    unless unitList.fetchNext opts
                        @units.overrideComparatorKeys = ['alphabetic', 'alphabetic_reverse', 'distance']
                        @units.setDefaultComparator()
                        @units.trigger 'finished', refit: true
                        service.get('units').trigger 'finished'

            unitList.fetch opts

        addService: (service) ->
            if service.has('ancestors')
                @_addService service
            else
                sm.withDeferred (deferred) =>
                    service.fetch
                        data: include: 'ancestors'
                        success: =>
                            @_addService(service).done =>
                                deferred.resolve()
        _search: (query) ->
            @_clearRadius()
            @selectedPosition.clear()
            @clearUnits all: true

            sm.withDeferred (deferred) =>
                if @searchResults.query == query
                    @searchResults.trigger 'ready'
                    deferred.resolve()
                    return

                if 'search' in _(@units.filters).keys()
                    @units.reset []

                unless @searchResults.isEmpty()
                    @searchResults.reset []
                opts =
                    success: =>
                        if _paq?
                            _paq.push ['trackSiteSearch', query, false, @searchResults.models.length]
                        @units.add @searchResults.filter (r) ->
                            r.get('object_type') == 'unit'
                        @units.setFilter 'search', true
                        unless @searchResults.fetchNext opts
                            @searchResults.trigger 'ready'
                            @units.trigger 'finished'
                            @services.set []
                            deferred.resolve()
                opts = @searchResults.search query, opts

        search: (query) ->
            unless query?
                query = @searchResults.query
            if query? and query.length > 0
                @_search query
            else
                sm.resolveImmediately()

        renderUnitsByServices: (serviceIdString) ->
            serviceIds = serviceIdString.split ','
            deferreds = _.map serviceIds, (id) =>
                @addService new models.Service id: id
            return $.when deferreds...

        _fetchDivisions: (divisionIds, callback) ->
            @divisions
                .setFilter 'ocd_id', divisionIds.join(',')
                .setFilter 'geometry', true
                .fetch success: callback

        _getLevel: (context, defaultLevel='none') ->
            context?.query?.level or defaultLevel

        _renderDivisions: (ocdIds, context) ->
            level = @_getLevel context, defaultLevel='none'
            sm.withDeferred (deferred) =>
                @_fetchDivisions ocdIds, =>
                    if level == 'none'
                        deferred.resolve()
                        return
                    if level != 'all'
                        @units.setFilter 'level', context.query.level
                    @units
                        .setFilter 'division', ocdIds.join(',')
                        .setFilter 'only', ['root_services', 'location', 'name'].join(',')
                    opts = success: =>
                        unless @units.fetchNext opts
                            @units.trigger 'finished'
                            deferred.resolve()
                    @units.fetch opts
                    @units

        renderDivision: (municipality, divisionId, context) ->
            @_renderDivisions ["#{municipality}/#{divisionId}"], context
        renderMultipleDivisions: (_path, context) ->
            if context.query.ocdId.length > 0
                @_renderDivisions context.query.ocdId, context

        renderAddress: (municipality, street, numberPart, context) ->
            level = @_getLevel context, defaultLevel='none'
            sm.withDeferred (deferred) =>
                SEPARATOR = /-/g
                slug = "#{municipality}/#{street}/#{numberPart}"
                positionList = models.PositionList.fromSlug municipality, street, numberPart
                @listenTo positionList, 'sync', (p) =>
                    try
                        if p.length == 0
                            throw new Error 'Address slug not found', slug
                        else if p.length == 1
                            position = p.pop()
                        else if p.length > 1
                            exactMatch = p.filter (pos) ->
                                numberParts = numberPart.split SEPARATOR
                                letter = pos.get 'letter'
                                number_end = pos.get 'number_end'
                                if numberParts.length == 1
                                    return letter == null and number_end == null
                                letterMatch = -> letter and letter.toLowerCase() == numberParts[1].toLowerCase()
                                numberEndMatch = -> number_end and number_end == numberParts[1]
                                return letterMatch() or numberEndMatch()
                            if exactMatch.length != 1
                                throw new Error 'Too many address matches'
                        @selectPosition position

                    catch err

                        addressInfo =
                            address: slug

                        Raven.captureException err, {extra: addressInfo}

                    deferred.resolve
                        afterMapInit: =>
                            if level != 'none'
                                @_showAllUnits level

        _showAllUnits: (level) ->
            transformedBounds = @mapProxy.getTransformedBounds()
            bboxes = []
            for bbox in transformedBounds
                bboxes.push "#{bbox[0][0]},#{bbox[0][1]},#{bbox[1][0]},#{bbox[1][1]}"
            @addUnitsWithinBoundingBoxes bboxes, level

        renderHome: (path, context) ->
            unless (not path? or
                path == '' or
                (path instanceof Array and path.length = 0))
                    context = path
            level = @_getLevel context, defaultLevel='none'
            @reset()
            sm.withDeferred (d) =>
                d.resolve afterMapInit: =>
                    if level != 'none'
                        @_showAllUnits level

        renderSearch: (path, opts) ->
            unless opts.query?.q?
                return
            @search opts.query.q

        _matchResourceUrl: (path) ->
            match = path.match /^([0-9]+)/
            if match?
                match[0]

        renderUnit: (path, opts) ->
            id = @_matchResourceUrl path
            if id?
                def = $.Deferred()
                @renderUnitById(id).done (unit) =>
                    def.resolve
                        afterMapInit: =>
                            @selectUnit unit
                return def.promise()
            query = opts.query
            if query?.service
                @renderUnitsByServices opts.query.service

define [
    'moment'
], (
    moment
) ->

    isMultiDayEvent = ([start, end]) ->
        end? and not start.isSame end, 'day'
    isMultiYearEvent = ([start, end]) ->
        end? and not start.isSame end, 'year'
    isMultiMonthEvent = ([start, end]) ->
        end? and not start.isSame end, 'month'

    getLanguage = ->
        moment.locale()

    # TODO move to locale
    clockWord =
        'fi': 'klo',
        'sv': 'kl.',
        'en-gb': 'at'

    dateFormat = (specs, includeMonth=true, includeYear=false) ->
        format = []
        add = (x) -> format.push x
        if specs.includeWeekday
            add specs.format.weekday
        if true
            add specs.format.dayOfMonth
        if includeMonth
            add specs.format.month
        if includeYear
            add specs.format.year
        format

    humanize = (m) ->
        day = m.calendar()
        # todo: Swedish?
        day = day.replace /( (klo|at))* \d{1,2}[:.]\d{1,2}$/, ''
        day

    formatEventDatetime = (start, end, specs) ->
        results = {}
        format = dateFormat specs,
            includeMonth = specs.includeStartTime or specs.includeFirstMonth,
            includeYear = specs.includeFirstYear

        if specs.humanize
            startDate = humanize start
        else
            startDate = start.format format.join(' ')

        startTime = start.format specs.format.time
        if isMultiDayEvent [start, end]
            format = dateFormat(specs, includeMonth=true, includeYear=specs.includeLastYear)
            if not specs.includeLastYear and specs.includeStartTime
                startDate += ' ' + startTime
            endDate = end.format format.join(' ')
            if not specs.includeLastYear and specs.includeEndTime
                endDate += ' ' + end.format specs.format.time
        else
            if specs.includeStartTime
                results.startTime = startTime
            if specs.includeEndTime
                results.endTime = end.format specs.format.time
        sod = moment().startOf 'day'
        diff = start.diff sod, 'days', true
        if specs.humanizeNotice and (diff < 2) and (diff > -1)
            # Add an extra notice for "yesterday" and "tomorrow"
            # in addition to the explicit datetime
            results.notice = humanize start
        if results.startTime
            results.time = "#{clockWord[getLanguage()]} #{results.startTime}"
            delete results.startTime
        if results.endTime
            results.time += "&nbsp;#{results.endTime}"
            delete results.endTime
        results.date = [startDate, endDate]
        results

    formatSpecs = (language, space) ->
        weekday =
            if space == 'large'
                'dddd'
            else
                if getLanguage() == 'en-gb' then 'ddd'
                else 'dd'
        month =
            if space == 'large'
                if getLanguage() == 'fi' then 'MMMM[ta]'
                else 'MMMM'
            else
                if getLanguage() == 'fi' then 'Mo'
                else if getLanguage() == 'sv' then 'M[.]'
                else if getLanguage() == 'en-gb' then 'MMM'
                else 'M'
        dayOfMonth =
            if getLanguage() == 'sv' then 'D[.]'
            else if  getLanguage() == 'en-gb' then 'D'
            else 'Do'

        time: 'LT'
        year: 'YYYY'
        weekday: weekday
        month: month
        dayOfMonth: dayOfMonth

    humanizeSingleDatetime = (datetime) ->
        humanizeEventDatetime(datetime, null, 'small')

    humanizeEventDatetime = (start, end, space) ->
        # space is 'large' or 'small'
        hasStartTime = start.length > 11
        hasEndTime = hasStartTime and (end?.length > 11)

        start = moment start
        if end?
            end = moment end
        now = moment()

        ev = [start, end]
        if isMultiDayEvent ev and not hasStartTime
            hasEndTime = false

        specs = {}
        specs.includeFirstYear =
            isMultiYearEvent ev
        specs.includeLastYear =
            (not now.isSame(end, 'year')) or isMultiYearEvent ev
        specs.includeFirstMonth =
            isMultiMonthEvent ev
        if space == 'large' and isMultiDayEvent ev
            specs.includeWeekday = true
        specs.includeStartTime =
            hasStartTime and ((space == 'large' and hasEndTime) or not isMultiDayEvent ev)
        specs.includeEndTime =
            hasEndTime and space == 'large'

        unless isMultiDayEvent ev
            specs.includeFirstMonth = true
            sod = now.startOf 'day'
            diff = start.diff sod, 'days', true
            _humanize = diff > -7 and diff <= 7
            if space == 'large'
                specs.humanizeNotice = _humanize
            else
                specs.humanize = _humanize
            unless specs.humanize
                specs.includeWeekday = true

        specs.format = formatSpecs getLanguage(), space
        result = formatEventDatetime start, end, specs
        result

    humanizeEventDatetime: humanizeEventDatetime,
    humanizeSingleDatetime: humanizeSingleDatetime

    # Test moments
    # a = moment('2014-07-15T12:00:00')
    # b = moment('2014-07-15T14:00:00')
    # c = moment('2014-07-16T10:00:00')
    # d = moment('2014-07-15T23:59:59')
    # e = moment('2014-07-16T00:00:00')
    # f = moment('2015-07-16T00:00:00')
    # g = moment('2014-08-15T00:00:00')
    # h = moment()
    # i = moment().add 2, 'hours'
    # j = moment().add 2, 'days'
    # k = moment().add 1, 'year'

define [
    'backbone'
], (
    Backbone
) ->

    debugVariables = [
        'units',
        'services',
        'selectedUnits',
        'selectedEvents',
        'searchResults',
        'searchState'
    ]
    debugEvents = [
        'all'
    ]
    log = (x) -> console.log x

    # Class whose name stands out in console output.
    class STATEFUL_EVENT

    class EventDebugger
        constructor: (@appControl) ->
            _.extend @, Backbone.Events
            @addListeners()

        addListeners: ->
            interceptor = (variableName) ->
                (eventName, target, rest...) ->
                    data = new STATEFUL_EVENT
                    data.variable = variableName
                    data.event = eventName
                    data.target = target?.toJSON?() or target
                    for param, i in rest
                        data["param_#{i+1}"] = param
                    log data
            for variableName in debugVariables
                for eventSpec in debugEvents
                    @listenTo @appControl[variableName], eventSpec,
                        interceptor(variableName)

    exports =
        EventDebugger: EventDebugger
        log: log

define ->

    class CanvasDrawer
        referenceLength: 4500
        strokePath: (c, callback) ->
            c.beginPath()
            callback(c)
            c.stroke()
            c.closePath()
        dim: (part) ->
            @ratio * @defaults[part]

    class Stem extends CanvasDrawer
        constructor: (@size, @rotation) ->
            @ratio = @size / @referenceLength
        defaults:
            width: 250
            base: 370
            top: 2670
            control: 1030
        startingPoint: ->
            [@size/2, @size]
        berryCenter: (rotation) ->
            rotation = Math.PI * rotation / 180
            x = 0.8 * Math.cos(rotation) * @dim('top') + (@size / 2)
            y = - Math.sin(rotation) * @dim('top') + @size - @dim('base')
            [x, y]
        setup: (c) ->
            c.lineJoin = 'round'
            c.strokeStyle = '#333'
            c.lineCap = 'round'
            c.lineWidth = @dim('width')
        draw: (c) ->
            @setup(c)
            c.fillStyle = '#000'
            point = @startingPoint()
            @strokePath c, (c) =>
                c.moveTo(point...)
                point[1] -= @dim('base')
                c.lineTo(point...)
                controlPoint = point
                controlPoint[1] -= @dim('control')
                point = @berryCenter(@rotation)
                c.quadraticCurveTo controlPoint..., point...
            point

    class Berry extends CanvasDrawer
        constructor: (@size, @point, @color) ->
            @ratio = @size / @referenceLength
        draw: (c) ->
            c.beginPath()
            c.fillStyle = @color
            c.arc @point..., @defaults.radius * @ratio, 0, 2 * Math.PI
            c.fill()
            unless getIeVersion() and getIeVersion() < 9
                c.strokeStyle = 'rgba(0,0,0,1.0)'
                oldComposite = c.globalCompositeOperation
                c.globalCompositeOperation = "destination-out"
                c.lineWidth = 1.5
                c.stroke()
                c.globalCompositeOperation = oldComposite
            c.closePath()
            c.beginPath()
            c.arc @point..., @defaults.radius * @ratio - 1, 0, 2 * Math.PI
            c.strokeStyle = '#fcf7f5'
            c.lineWidth = 1
            c.stroke()
            c.closePath()
        defaults:
            radius: 1000
            stroke: 125

    class Plant extends CanvasDrawer
        constructor: (@size, @color, id,
                      @rotation = 70 + (id % 40),
                      @translation = [0, -3]) ->
            @stem = new Stem(@size, @rotation)
        draw: (@context) ->
            @context.save()
            @context.translate(@translation...)
            berryPoint = @stem.draw(@context)
            @berry = new Berry(@size, berryPoint, @color)
            @berry.draw(@context)
            @context.restore()

    drawSimpleBerry = (c, x, y, radius, color) ->
        c.fillStyle = color
        c.beginPath()
        c.arc x, y, radius, 0, 2 * Math.PI
        c.fill()

    class PointCluster extends CanvasDrawer
        constructor: (@size, @colors, @positions, @radius) ->
        draw: (c) =>
            _.each @positions, (pos) =>
                drawSimpleBerry c, pos..., @radius, "#000"

    class PointPlant extends CanvasDrawer
        constructor: (@size, @color, @radius) ->
            true
        draw: (c) =>
            drawSimpleBerry c, 10, 10, @radius, "#f00"

    exports =
        Plant: Plant
        PointCluster: PointCluster
        PointPlant: PointPlant
    return exports

config =
    baseUrl: appSettings.static_path + 'vendor'
    paths:
        app: '../js'
    shim:
        bootstrap:
            deps: ['jquery']
        backbone:
            deps: ['underscore', 'jquery']
            exports: 'Backbone'
        'leaflet.markercluster':
            deps: ['leaflet']
        'iexhr':
            deps: ['jquery']
    config:
        'app/p13n': localStorageEnabled: false

requirejs.config config

PAGE_SIZE = 1000

# TODO: move to common file??
window.getIeVersion = ->
    isInternetExplorer = ->
        window.navigator.appName is "Microsoft Internet Explorer"

    if not isInternetExplorer()
        return false

    matches = new RegExp(" MSIE ([0-9]+)\\.([0-9])").exec window.navigator.userAgent
    return parseInt matches[1]

requirejs [
    'app/models',
    'app/p13n',
    'app/color',
    'app/map-base-view'
    'app/map',
    'app/views/embedded-title',
    'backbone',
    'backbone.marionette',
    'jquery',
    'iexhr',
    'i18next',
    'URI',
    'bootstrap',
    'app/router',
    'app/control',
    'app/embedded-views',
    'app/widgets'
],
(
    models,
    p13n,
    ColorMatcher,
    BaseMapView,
    map,
    TitleView,
    Backbone,
    Marionette,
    $,
    iexhr,
    i18n,
    URI,
    Bootstrap,
    Router,
    BaseControl,
    TitleBarView,
    widgets
) ->

    app = new Backbone.Marionette.Application()
    window.app = app

    fullUrl = ->
        currentUri = URI window.location.href
        currentUri.segment(0, "").toString()

    class EmbeddedMapView extends BaseMapView
        mapOptions:
            dragging: true
            touchZoom: true
            scrollWheelZoom: false
            doubleClickZoom: true
            boxZoom: false
        postInitialize: ->
            super()
            zoom = L.control.zoom
                position: 'bottomright'
                zoomInText: "<span class=\"icon-icon-zoom-in\"></span>"
                zoomOutText: "<span class=\"icon-icon-zoom-out\"></span>"
            logo = new widgets.ControlWrapper(new TitleView(href: fullUrl()), position: 'bottomleft', autoZIndex: false)
            zoom.addTo @map
            logo.addTo @map
            @allMarkers.on 'click', (l) =>
                root = URI(window.location.href).host()
                if l.layer?.unit?
                    window.open "http://#{root}/unit/" + l.layer.unit.get('id')
                else
                    window.open fullUrl()
            @allMarkers.on 'clusterclick', =>
                window.open fullUrl()

        clusterPopup: (event) ->
            cluster = event.layer
            childCount = cluster.getChildCount()
            popup = @createPopup()
            html = """
                <div class='servicemap-prompt'>
                    #{i18n.t 'embed.click_prompt_move'}
                </div>
            """
            popup.setContent html
            popup.setLatLng cluster.getBounds().getCenter()
            popup
        createPopup: (unit) ->
            popup = L.popup offset: L.point(0, 30), closeButton: false
            if unit?
                htmlContent = """
                    <div class='unit-name'>#{unit.getText 'name'}</div>
                    <div class='servicemap-prompt'>#{i18n.t 'embed.click_prompt'}</div>
                """
                popup.setContent htmlContent
            popup
        getFeatureGroup: ->
            L.markerClusterGroup
                showCoverageOnHover: false
                maxClusterRadius: (zoom) =>
                    return if (zoom >= map.MapUtils.getZoomlevelToShowAllMarkers()) then 4 else 30
                iconCreateFunction: (cluster) =>
                    @createClusterIcon cluster
                zoomToBoundsOnClick: false
        handlePosition: (positionObject) ->
            accuracy = location.accuracy
            latLng = map.MapUtils.latLngFromGeojson positionObject
            marker = map.MapUtils.createPositionMarker latLng, accuracy, positionObject.origin(), clickable: true
            marker.position = positionObject
            popup = L.popup offset: L.point(0, 40), closeButton: false
            name = positionObject.humanAddress()
            popup.setContent "<div class='unit-name'>#{name}</div>"
            marker.bindPopup popup
            marker.addTo @map
            @map.adapt()
            marker.openPopup()
            marker.on 'click', => window.open fullUrl()

    appState =
        # TODO handle pagination
        divisions: new models.AdministrativeDivisionList
        units: new models.UnitList null, pageSize: 500
        selectedUnits: new models.UnitList()
        selectedPosition: new models.WrappedModel()
        selectedDivision: new models.WrappedModel()
        selectedServices: new models.ServiceList()
        searchResults: new models.SearchList [], pageSize: appSettings.page_size

    appState.services = appState.selectedServices
    window.appState = appState

    app.addInitializer (opts) ->
        # The colors are dependent on the currently selected services.
        @colorMatcher = new ColorMatcher
        control = new BaseControl appState
        router = new Router
            controller: control
            makeMapView: (mapOptions) =>
                mapView = new EmbeddedMapView appState, mapOptions, true
                app.getRegion('map').show mapView
                control.setMapProxy mapView.getProxy()

        baseRoot = "#{appSettings.url_prefix}embed"
        root = baseRoot + '/'
        if !(window.history and history.pushState)
          rootRegexp = new RegExp baseRoot + '\/?'
          url = window.location.href
          url = url.replace rootRegexp, '/'
          currentUri = URI url
          currentUri
          router.routeEmbedded currentUri
        else
            Backbone.history.start
                pushState: true, root: root

        @commands.setHandler 'addUnitsWithinBoundingBoxes', (bboxes) =>
            control.addUnitsWithinBoundingBoxes(bboxes)

    app.addRegions
        navigation: '#navigation-region'
        map: '#app-container'

    # We wait for p13n/i18next to finish loading before firing up the UI
    $.when(p13n.deferred).done ->
        app.start()
        $appContainer = $('#app-container')
        $appContainer.attr 'class', p13n.get('map_background_layer')
        $appContainer.addClass 'embed'


define [
    'app/models',
    'app/spinner',
    'app/embedded-views',
    'backbone.marionette',
    'jquery'
], (
    models,
    Spinner,
    TitleBarView
    Marionette,
    $
) ->

    PAGE_SIZE = 1000
    delayTime = 1000
    spinner = new Spinner
        container: document.body
    #TODO enable title bar and loading spinner
    class Router extends Marionette.AppRouter
        execute: (callback, args) ->
            _.delay @indicateLoading, delayTime
            model = callback.apply(@, args)
            @listenTo model, 'sync', @removeLoadingIndicator
            @listenTo model, 'finished', @removeLoadingIndicator

        _parseParameters: (params) ->
            parsedParams = {}
            _(params.split '&').each (query) =>
                [k, v] = query.split('=', 2)
                if v.match /,/
                    v = v.split(',')
                else
                    v = [v]
                parsedParams[k] = v
            parsedParams

        # renderUnitsWithFilter: (params) ->
        #     @listenToOnce @appState.units, 'finished', =>
        #         @drawUnits @appState.units
        #     units =  @appState.units
        #     params = @_parseParameters params
        #     key = 'division'
        #     divIds = params.divisions
            if _(params).has 'titlebar' # TODO enable
                app.getRegion('navigation').show new TitleBarView @appState.divisions
            # @_fetchDivisions divIds
            # units

        indicateLoading: ->
            spinner.start()

        removeLoadingIndicator: ->
            spinner?.stop()

    Router

define [
    'app/views/base',
    'backbone'
], (
    baseviews,
    Backbone
) ->

    class EmbeddedMap extends Backbone.View
        # Todo: re-enable functionality
        initialize: (options)->
            @mapView = options.mapView
            @listenTo app.vent, 'unit:render-one', @renderUnit
            @listenTo app.vent, 'units:render-with-filter', @renderUnitsWithFilter
            @listenTo app.vent, 'units:render-category', @renderUnitsByCategory

        renderUnitsByCategory: (isSelected) ->
            publicCategories = [100, 101, 102, 103, 104]
            privateCategories = [105]

            onlyCategories = (categoriesArray) ->
                (model) -> _.contains categoriesArray, model.get('provider_type')

            publicUnits = @unitList.filter onlyCategories publicCategories
            privateUnits = @unitList.filter onlyCategories privateCategories
            unitsInCategory = []

            _.extend unitsInCategory, publicUnits if not isSelected.public
            _.extend unitsInCategory, privateUnits if not isSelected.private

            @mapView.drawUnits(new models.UnitList unitsInCategory)

        fetchAdministrativeDivisions: (params, callback)->
            divisions = new models.AdministrativeDivisionList()
            divisions.fetch
                data: ocd_id: params
                success: callback

        findUniqueAdministrativeDivisions: (collection) ->
            byName = (divisionModel) -> divisionModel.toJSON().name
            divisionNames = collection.chain().map(byName).compact().unique().value()
            divisionNamesPartials = {}
            if divisionNames.length > 1
                divisionNamesPartials.start = _.initial(divisionNames).join(', ')
                divisionNamesPartials.end = _.last divisionNames
            else divisionNamesPartials.start = divisionNames[0]

            app.vent.trigger('administration-divisions-fetched', divisionNamesPartials)

    class TitleBarView extends baseviews.SMItemView
        template: 'embedded-title-bar'
        className: 'panel panel-default'
        events:
            'click a': 'preventDefault'
            'click .show-button': 'toggleShow'
            'click .panel-heading': 'collapseCategoryMenu'

        initialize: (@model) ->
            @listenTo @model, 'sync', @render

        divisionNames: (divisions) =>
            divisions.pluck 'name'

        serializeData: ->
            divisions: @divisionNames @model
        show: ->
            @delegateEvents
            @$el.removeClass 'hide'

        hide: ->
            @undelegateEvents()
            @$el.addClass 'hide'

        preventDefault: (ev) ->
            ev.preventDefault()

        toggleShow: (ev)->
            publicToggle = @$ '.public'
            privateToggle = @$ '.private'

            target = $(ev.target)
            target.toggleClass 'selected'

            isSelected =
                public: publicToggle.hasClass 'selected'
                private: privateToggle.hasClass 'selected'

            app.vent.trigger 'units:render-category', isSelected

        collapseCategoryMenu: ->
            $('.panel-heading').toggleClass 'open'
            #$('.collapse').collapse 'toggle'

    return TitleBarView

define [
    'app/base',
    'app/p13n',
    'app/settings',
    'app/jade',
    'app/models',
    'typeahead.bundle',
    'backbone'
],
(
    sm,
    p13n,
    settings,
    jade,
    models,
    _typeahead,
    Backbone
) ->

    monkeyPatchTypeahead = ($element) =>
        typeahead = $element.data 'ttTypeahead'
        proto = Object.getPrototypeOf typeahead
        originalSelect = proto._select
        proto._select = (datum) ->
            @input.setQuery datum.value
            @input.setInputValue datum.value, true
            @_setLanguageDirection()
            @eventBus.trigger 'selected', datum.raw, datum.datasetName
            # REMOVED CODE WHICH CLOSES THE DROPDOWN
        proto.closeCompletely = ->
            @close()
            _.defer _.bind(@dropdown.empty, @dropdown)

    GeocoderSourceBackend: class GeocoderSourceBackend
        constructor: (@options) ->
            _.extend @, Backbone.Events
            @street = undefined
            geocoderStreetEngine = @_createGeocoderStreetEngine p13n.getLanguage()
            @geocoderStreetSource = geocoderStreetEngine.ttAdapter()
        setOptions: (@options) ->
            @options.$inputEl.on 'typeahead:selected', _.bind(@typeaheadSelected, @)
            @options.$inputEl.on 'typeahead:autocompleted', _.bind(@typeaheadSelected, @)
            monkeyPatchTypeahead @options.$inputEl

        _createGeocoderStreetEngine: (lang) ->
            e = new Bloodhound
                name: 'street_suggestions'
                remote:
                    url: appSettings.service_map_backend + "/street/?page_size=4"
                    replace: (url, query) =>
                        url += "&input=#{query}"
                        url += "&language=#{if lang != 'sv' then 'fi' else lang}"
                        url
                    ajax: settings.applyAjaxDefaults {}
                    filter: (parsedResponse) =>
                        results = new models.StreetList parsedResponse.results
                        if results.length == 1
                            @setStreet results.first()
                        results.toArray()
                    rateLimitWait: 50
                datumTokenizer: (datum) ->
                    Bloodhound.tokenizers.whitespace datum.name[lang]
                queryTokenizer: (s) =>
                    res = [s]
            e.initialize()
            return e

        typeaheadSelected: (ev, data) ->
            objectType = data.object_type
            if objectType == 'address'
                if data instanceof models.Position
                    @options.$inputEl.typeahead 'close'
                    @options.selectionCallback ev, data
                else
                    @setStreet(data).done =>
                        @options.$inputEl.val (@options.$inputEl.val() + ' ')
                        @options.$inputEl.trigger 'input'
            else
                @setStreet null

        streetSelected: ->
            unless @street?
                return
            _.defer =>
                streetName = p13n.getTranslatedAttr @street.name
                @options.$inputEl.typeahead('val', '')
                @options.$inputEl.typeahead('val', streetName + ' ')
                @options.$inputEl.trigger 'input'

        setStreet: (street) =>
            sm.withDeferred (deferred) =>
                unless street?
                    @street = undefined
                    deferred.resolve()
                    return
                if street.get('id') == @street?.get('id')
                    deferred.resolve()
                    return
                @street = street
                @street.translatedName = (
                    @street.get('name')[p13n.getLanguage()] or @street.get('name').fi
                ).toLowerCase()
                @street.addresses = new models.AddressList [], pageSize: 200
                @street.addresses.comparator = (x) =>
                    parseInt x.get('number')
                @street.addressesFetched = false
                @street.addresses.fetch
                    data:
                        street: @street.get('id')
                    success: =>
                        @street?.addressesFetched = true
                        deferred.resolve()

        addressSource: (query, callback) =>
            re = new RegExp "^\\s*#{@street.translatedName}(\\s+\\d.*)?", 'i'
            matches = query.match re
            if matches?
                [q, numberPart] = matches
                # TODO: automatically make this search on focus
                unless numberPart?
                    numberPart = ''
                numberPart = numberPart.replace(/\s+/g, '').replace /[^0-9]+/g, ''
                done = =>
                    unless @street?
                        callback []
                        return
                    if @street.addresses.length == 1
                        callback @street.addresses.toArray()
                        return
                    filtered = @street.addresses
                        .filter (a) =>
                            a.humanNumber().indexOf(numberPart) == 0
                    results = filtered.slice(0, 2)
                    last = _(filtered).last()
                    unless last in results
                        if last?
                            results.push last
                    callback results
                if @street.addressesFetched
                    done()
                else
                    @listenToOnce @street.addresses, 'sync', =>
                        done()

        getSource: =>
            (query, cb) =>
                if @street? and @street.translatedName.length <= query.length
                    @addressSource query, cb
                else
                    @geocoderStreetSource query, cb

        getDatasetOptions: =>
            name: 'address'
            displayKey: (c) ->
                c.humanAddress()
            source: @getSource()
            templates:
                suggestion: (c) =>
                    if c instanceof models.Position
                        c.set 'street', @street
                    c.address = c.humanAddress()
                    c.object_type = 'address'
                    jade.template 'typeahead-suggestion', c


define [
    'underscore',
    'jquery',
    'i18next',
    'app/p13n',
    'app/dateformat'
], (
    _,
    $,
    i18n,
    p13n,
    dateformat
) ->

    # Make sure jade runtime is loaded
    if typeof jade != 'object'
        throw new Error "Jade not loaded before app"

    setHelper = (data, name, helper) ->
        if name of data
            return
        data[name] = helper

    class Jade
        getTemplate: (name) ->
            key = "views/templates/#{name}"
            if key not of JST
                throw new Error "template '#{name}' not loaded"
            templateFunc = JST[key]
            return templateFunc

        tAttr: (attr) ->
            return p13n.getTranslatedAttr attr
        tAttrHasLang: (attr) ->
            if not attr
                return false
            return p13n.getLanguage() of attr
        phoneI18n: (num) ->
            if num.indexOf '0' == 0
                # FIXME: make configurable
                num = '+358' + num.substring 1
            num = num.replace /\s/g, ''
            num = num.replace /-/g, ''
            return num
        staticPath: (path) ->
            # Strip leading slash
            if path.indexOf('/') == 0
                path = path.substring 1
            return appSettings.static_path + path
        humanDateRange: (startTime, endTime) ->
            formatted = dateformat.humanizeEventDatetime(
                startTime, endTime, 'small', hasEndTime=false
            )
            return formatted.date
        humanDistance: (meters) ->
            return if meters == Number.MAX_VALUE
                "?"
            else if meters < 1000
                "#{Math.ceil meters }m"
            else
                val = Math.ceil(meters/100).toString()
                [a, b] = [val.slice(0, -1), val.slice(-1)]
                if b != "0"
                    "#{a}.#{b}km"
                else
                    "#{a}km"
        humanShortcomings: (count) ->
            return if count == Number.MAX_VALUE
                i18n.t 'accessibility.no_data'
            else if count == 0
                i18n.t 'accessibility.no_shortcomings'
            else
                i18n.t 'accessibility.shortcoming_count', count: count
        humanDate: (datetime) ->
            res = dateformat.humanizeSingleDatetime datetime
        uppercaseFirst: (val) ->
            val.charAt(0).toUpperCase() + val.slice 1

        mixinHelpers: (data) ->
            setHelper data, 't', i18n.t
            setHelper data, 'tAttr', @tAttr
            setHelper data, 'tAttrHasLang', @tAttrHasLang
            setHelper data, 'phoneI18n', @phoneI18n
            setHelper data, 'staticPath', @staticPath
            setHelper data, 'humanDateRange', @humanDateRange
            setHelper data, 'humanDate', @humanDate
            setHelper data, 'humanDistance', @humanDistance
            setHelper data, 'uppercaseFirst', @uppercaseFirst
            setHelper data, 'humanShortcomings', @humanShortcomings
            setHelper data, 'pad', (s) => " #{s} "
            data

        template: (name, locals) ->
            if locals?
                if typeof locals != 'object'
                    throw new Error "template must get an object argument"
            else
                locals = {}
            func = @getTemplate name
            data = _.clone locals
            @mixinHelpers data
            templateStr = func data
            return $.trim templateStr

    return new Jade

define ->

    clearLandingPage = ->
        # The transitions triggered by removing the class landing from body are defined
        # in the file landing-page.less.
        # When key animations have ended a 'landing-page-cleared' event is triggered.
        if $('body').hasClass('landing')
            $('body').removeClass('landing')
            $('#navigation-region').one('transitionend webkitTransitionEnd otransitionend oTransitionEnd MSTransitionEnd', (event) ->
                app.vent.trigger('landing-page-cleared')
                $(@).off('transitionend webkitTransitionEnd oTransitionEnd MSTransitnd')
                )
    return {
        clear: clearLandingPage
    }

define [
    'backbone',
    'backbone.marionette',
    'i18next',
    'leaflet',
    'leaflet.markercluster',
    'leaflet.snogylop',
    'app/map',
    'app/widgets',
    'app/jade',
    'app/map-state-model'
], (
    Backbone,
    Marionette,
    i18n,
    leaflet,
    markercluster,
    leaflet_snogylop,
    map,
    widgets,
    jade,
    MapStateModel,
) ->

    # TODO: remove duplicates
    MARKER_POINT_VARIANT = false
    DEFAULT_CENTER =
        helsinki: [60.171944, 24.941389]
        espoo: [60.19792, 24.708885]
        vantaa: [60.309045, 25.004675]
        kauniainen: [60.21174, 24.729595]
    ICON_SIZE = 40
    if getIeVersion() and getIeVersion() < 9
        ICON_SIZE *= .8

    class MapBaseView extends Backbone.Marionette.View
        initialize: (@opts, @mapOpts, @embedded) ->
            @markers = {}
            @units = @opts.units
            @selectedUnits = @opts.selectedUnits
            @selectedPosition = @opts.selectedPosition
            @divisions = @opts.divisions
            @listenTo @units, 'reset', @drawUnits
            @listenTo @units, 'finished', (options) =>
                # Triggered when all of the
                # pages of units have been fetched.
                @drawUnits @units, options
                if @selectedUnits.isSet()
                    @highlightSelectedUnit @selectedUnits.first()

        getProxy: ->
            fn = => map.MapUtils.overlappingBoundingBoxes @map
            getTransformedBounds: fn

        mapOptions: {}

        render: ->
            @$el.attr 'id', 'map'

        getMapStateModel: ->
            new MapStateModel @opts, @embedded

        onShow: ->
            # The map is created only after the element is added
            # to the DOM to work around Leaflet init issues.
            mapStyle = p13n.get 'map_background_layer'
            options =
                style: mapStyle
                language: p13n.getLanguage()
            @map = map.MapMaker.createMap @$el.get(0), options, @mapOptions, @getMapStateModel()
            @map.on 'click', _.bind(@onMapClicked, @)
            @allMarkers = @getFeatureGroup()
            @allMarkers.addTo @map
            @divisionLayer = L.featureGroup()
            @divisionLayer.addTo @map
            @postInitialize()

        onMapClicked: (ev) -> # override

        calculateInitialOptions: ->
            if @selectedPosition.isSet()
                zoom: map.MapUtils.getZoomlevelToShowAllMarkers()
                center: map.MapUtils.latLngFromGeojson @selectedPosition.value()
            else if @selectedUnits.isSet()
                zoom: @getMaxAutoZoom()
                center: map.MapUtils.latLngFromGeojson @selectedUnits.first()
            else if @divisions.isSet()
                boundaries = @divisions.map (d) =>
                    new L.GeoJSON d.get('boundary')
                iteratee = (memo, value) => memo.extend value.getBounds()
                bounds = _.reduce boundaries, iteratee, L.latLngBounds([])
                bounds: bounds
            else
                city = p13n.get 'city'
                unless city?
                    city = 'helsinki'
                center = DEFAULT_CENTER[city]
                # Default state without selections
                zoom: if (p13n.get('map_background_layer') == 'servicemap') then 10 else 5
                center: center

        postInitialize: ->
            @_addMouseoverListeners @allMarkers
            @popups = L.layerGroup()
            @popups.addTo @map
            @setInitialView()
            @drawInitialState()

        fitBbox: (bbox) =>
            sw = L.latLng(bbox.slice(0,2))
            ne = L.latLng(bbox.slice(2,4))
            bounds = L.latLngBounds(sw, ne)
            @map.fitBounds bounds

        getMaxAutoZoom: ->
            layer = p13n.get('map_background_layer')
            if layer == 'guidemap'
                7
            else if layer == 'ortographic'
                9
            else
                12


        setInitialView: ->
            if @mapOpts?.bbox?
                @fitBbox @mapOpts.bbox
            else
                opts = @calculateInitialOptions()
                if opts.bounds?
                    @map.fitBounds opts.bounds
                else
                    @map.setView opts.center, opts.zoom

        drawInitialState: =>
            if @selectedPosition.isSet()
                @handlePosition @selectedPosition.value(),
                    center: false,
                    skipRefit: true,
                    initial: true
            else if @selectedUnits.isSet()
                @drawUnits @units, noRefit: true
            else
                if @units.isSet()
                    @drawUnits @units
                if @divisions.isSet()
                    @divisionLayer.clearLayers()
                    @drawDivisions @divisions

        drawUnits: (units, options) ->
            @allMarkers.clearLayers()
            if units.filters?.bbox?
                if @_skipBboxDrawing
                    return
            unitsWithLocation = units.filter (unit) => unit.get('location')?
            markers = unitsWithLocation.map (unit) => @createMarker(unit, options?.marker)
            latLngs = _(markers).map (m) => m.getLatLng()
            unless options?.keepViewport
                @preAdapt?()
                @map.adaptToLatLngs latLngs
            @allMarkers.addLayers markers

        _combineMultiPolygons: (multiPolygons) ->
            multiPolygons.map (mp) => mp.coordinates[0]

        drawDivisionGeometry: (geojson) ->
            mp = L.GeoJSON.geometryToLayer geojson,
                null, null,
                invert: true
                color: '#ff8400'
                weight: 3
                strokeOpacity: 1
                fillColor: '#000'
                fillOpacity: 0.2
            @map.adapt()
            mp.addTo @divisionLayer

        drawDivisions: (divisions) ->
            geojson =
                coordinates: @_combineMultiPolygons divisions.pluck('boundary')
                type: 'MultiPolygon'
            @drawDivisionGeometry geojson

        drawDivision: (division) ->
            unless division?
                return
            @drawDivisionGeometry division.get('boundary')

        highlightUnselectedUnit: (unit) ->
            # Transiently highlight the unit which is being moused
            # over in search results or otherwise temporarily in focus.
            marker = unit.marker
            popup = marker?.popup
            if popup?.selected
                return
            @_clearOtherPopups popup, clearSelected: true
            if popup?
                $(marker.popup._wrapper).removeClass 'selected'
                popup.setLatLng marker?.getLatLng()
                @popups.addLayer popup

        clusterPopup: (event) ->
            cluster = event.layer
            # Maximum number of displayed names per cluster.
            COUNT_LIMIT = 3
            childCount = cluster.getChildCount()
            names = _.map cluster.getAllChildMarkers(), (marker) ->
                    p13n.getTranslatedAttr marker.unit.get('name')
                .sort()
            data = {}
            overflowCount = childCount - COUNT_LIMIT
            if overflowCount > 1
                names = names[0...COUNT_LIMIT]
                data.overflow_message = i18n.t 'general.more_units',
                    count: overflowCount
            data.names = names
            popuphtml = jade.getTemplate('popup_cluster') data
            popup = @createPopup()
            popup.setLatLng cluster.getBounds().getCenter()
            popup.setContent popuphtml
            cluster.popup = popup
            @map.on 'zoomstart', =>
                @popups.removeLayer popup
            popup

        _addMouseoverListeners: (markerClusterGroup)->
            @bindDelayedPopup markerClusterGroup, null,
                showEvent: 'clustermouseover'
                hideEvent: 'clustermouseout'
                popupCreateFunction: _.bind @clusterPopup, @
            markerClusterGroup.on 'spiderfied', (e) =>
                icon = $(e.target._spiderfied?._icon)
                icon?.fadeTo('fast', 0)

            @_lastOpenedClusterIcon = null
            markerClusterGroup.on 'spiderfied', (e) =>
                # Work around css hover forced opacity showing the
                # clicked cluster which should be hidden.
                if @_lastOpenedClusterIcon
                    L.DomUtil.removeClass @_lastOpenedClusterIcon, 'hidden'
                icon = e.target._spiderfied._icon
                L.DomUtil.addClass icon, 'hidden'
                @_lastOpenedClusterIcon = icon

        getZoomlevelToShowAllMarkers: ->
            layer = p13n.get('map_background_layer')
            if layer == 'guidemap'
                return 8
            else if layer == 'ortographic'
                return 8
            else
                return 14

        getServices: ->
            null

        createClusterIcon: (cluster) ->
            count = cluster.getChildCount()
            serviceIds = {}
            serviceId = null
            markers = cluster.getAllChildMarkers()
            services = @getServices()
            _.each markers, (marker) =>
                unless marker.unit?
                    return
                if marker.popup?
                    cluster.on 'remove', (event) =>
                        @popups.removeLayer marker.popup
                if not services or services.isEmpty()
                    root = marker.unit.get('root_services')[0]
                else
                    service = services.find (s) =>
                        s.get('root') in marker.unit.get('root_services')
                    root = service?.get('root') or 50000
                serviceIds[root] = true
            cluster.on 'remove', (event) =>
                if cluster.popup?
                    @popups.removeLayer cluster.popup
            colors = _(serviceIds).map (val, id) =>
                app.colorMatcher.serviceRootIdColor id

            if MARKER_POINT_VARIANT
                ctor = widgets.PointCanvasClusterIcon
            else
                ctor = widgets.CanvasClusterIcon
            iconOpts = {}
            if _(markers).find((m) => m?.unit?.collection?.hasReducedPriority())?
                iconOpts.reducedProminence = true
            new ctor count, ICON_SIZE, colors, null,
                iconOpts

        getFeatureGroup: ->
            L.markerClusterGroup
                showCoverageOnHover: false
                maxClusterRadius: (zoom) =>
                    return if (zoom >= map.MapUtils.getZoomlevelToShowAllMarkers()) then 4 else 30
                iconCreateFunction: (cluster) =>
                    @createClusterIcon cluster
                zoomToBoundsOnClick: true

        createMarker: (unit, markerOptions) ->
            id = unit.get 'id'
            if id of @markers
                marker = @markers[id]
                marker.unit = unit
                unit.marker = marker
                return marker

            icon = @createIcon unit, @selectedServices
            marker = widgets.createMarker map.MapUtils.latLngFromGeojson(unit),
                reducedProminence: unit.collection?.hasReducedPriority()
                icon: icon
                zIndexOffset: 100
            marker.unit = unit
            unit.marker = marker
            if @selectMarker?
                @listenTo marker, 'click', @selectMarker

            marker.on 'remove', (event) =>
                marker = event.target
                if marker.popup?
                    @popups.removeLayer marker.popup

            popup = @createPopup unit
            popup.setLatLng marker.getLatLng()
            @bindDelayedPopup marker, popup

            @markers[id] = marker

        _clearOtherPopups: (popup, opts) ->
            @popups.eachLayer (layer) =>
                if layer == popup
                    return
                if opts?.clearSelected or not layer.selected
                    @popups.removeLayer layer

        bindDelayedPopup: (marker, popup, opts) ->
            showEvent = opts?.showEvent or 'mouseover'
            hideEvent = opts?.hideEvent or 'mouseout'
            delay = opts?.delay or 600
            if marker and popup
                marker.popup = popup
                popup.marker = marker

            prevent = false
            createdPopup = null

            popupOn = (event) =>
                unless prevent
                    if opts?.popupCreateFunction?
                        _popup = opts.popupCreateFunction(event)
                        createdPopup = _popup
                    else
                        _popup = popup
                    @_clearOtherPopups _popup, clearSelected: false
                    @popups.addLayer _popup
                prevent = false

            popupOff = (event) =>
                if opts?.popupCreateFunction
                    _popup = createdPopup
                else
                    _popup = popup
                if _popup?
                    if @selectedUnits? and _popup.marker?.unit == @selectedUnits.first()
                        prevent = true
                    else
                        @popups.removeLayer _popup
                _.delay (=> prevent = false), delay

            marker.on hideEvent, popupOff
            marker.on showEvent, _.debounce(popupOn, delay)

        createPopup: (unit, opts, offset) ->
            popup = @createPopupWidget opts, offset
            if unit?
                htmlContent = "<div class='unit-name'>#{unit.getText 'name'}</div>"
                popup.setContent htmlContent
            popup
        createPopupWidget: (opts, offset) ->
            defaults =
                closeButton: false
                autoPan: false
                zoomAnimation: false
                className: 'unit'
                maxWidth: 500
                minWidth: 150
            if opts?
                opts = _.defaults opts, defaults
            else
                opts = defaults
            if offset? then opts.offset = offset
            new widgets.LeftAlignedPopup opts

        createIcon: (unit, services) ->
            color = app.colorMatcher.unitColor(unit) or 'rgb(255, 255, 255)'
            if MARKER_POINT_VARIANT
                ctor = widgets.PointCanvasIcon
            else
                ctor = widgets.PlantCanvasIcon
            iconOptions = {}
            if unit.collection?.hasReducedPriority()
                iconOptions.reducedProminence = true
            icon = new ctor ICON_SIZE, color, unit.id, iconOptions

    return MapBaseView

define \
[
    'leaflet',
    'backbone',
    'app/map'
], (
    L,
    Backbone,
    MapUtils: MapUtils
) ->

    VIEWPOINTS =
        # meters to show everything within in every direction
        singleUnitImmediateVicinity: 200
        singleObjectEmbedded: 400

    _latitudeDeltaFromRadius = (radiusMeters) ->
        (radiusMeters / 40075017) * 360

    _longitudeDeltaFromRadius = (radiusMeters, latitude) ->
        _latitudeDeltaFromRadius(radiusMeters) / Math.cos(L.LatLng.DEG_TO_RAD * latitude)

    boundsFromRadius = (radiusMeters, latLng) ->
        delta = L.latLng _latitudeDeltaFromRadius(radiusMeters),
            _longitudeDeltaFromRadius(radiusMeters, latLng.lat)
        min = L.latLng latLng.lat - delta.lat, latLng.lng - delta.lng
        max = L.latLng latLng.lat + delta.lat, latLng.lng + delta.lng
        L.latLngBounds [min, max]

    class MapStateModel extends Backbone.Model
        # Models map center, bounds and zoom in a unified way.
        initialize: (@opts, @embedded) ->
            @userHasModifiedView = false
            @wasAutomatic = false
            @zoom = null
            @bounds = null
            @center = null

            @listenTo @opts.selectedPosition, 'change:value', @onSelectPosition

        setMap: (@map) ->
            @map.mapState = @
            @map.on 'moveend', _.bind(@onMoveEnd, @)

        onSelectPosition: (position) =>
            if position.isSet() then @setUserModified()

        onMoveEnd: ->
            unless @wasAutomatic
                @setUserModified()
            @wasAutomatic = false

        setUserModified: ->
            @userHasModifiedView = true

        adaptToLayer: (layer) ->
            @adaptToBounds layer.getBounds()

        adaptToBounds: (bounds) ->
            mapBounds = @map.getBounds()
            # Don't pan just to center the view if the bounds are already
            # contained, unless the map can be zoomed in.
            if bounds? and (@map.getZoom() == @map.getBoundsZoom(bounds) and mapBounds.contains bounds)
                return

            if @opts.route?.has 'plan'
                # Transit plan fitting is the simplest case, handle it and return.
                if bounds?
                    @map.fitBounds bounds,
                        paddingTopLeft: [20,0]
                        paddingBottomRight: [20,20]
                return

            viewOptions =
                center: null
                zoom: null
                bounds: null
            zoom = Math.max MapUtils.getZoomlevelToShowAllMarkers(), @map.getZoom()
            EMBED_RADIUS = VIEWPOINTS['singleObjectEmbedded']
            if @opts.selectedUnits.isSet()
                if @embedded == true
                    viewOptions.zoom = null
                    viewOptions.bounds = boundsFromRadius EMBED_RADIUS,
                        MapUtils.latLngFromGeojson(@opts.selectedUnits.first())
                else
                    viewOptions.center = MapUtils.latLngFromGeojson @opts.selectedUnits.first()
                    viewOptions.zoom = zoom
            else if @opts.selectedPosition.isSet()
                if @embedded == true
                    viewOptions.zoom = null
                    viewOptions.bounds = boundsFromRadius EMBED_RADIUS,
                        MapUtils.latLngFromGeojson(@opts.selectedPosition.value())
                else
                    viewOptions.center = MapUtils.latLngFromGeojson @opts.selectedPosition.value()
                    radiusFilter = @opts.selectedPosition.value().get 'radiusFilter'
                    if radiusFilter?
                        viewOptions.zoom = null
                        viewOptions.bounds = bounds
                    else
                        viewOptions.zoom = zoom

            if @opts.selectedDivision.isSet()
                viewOptions = @_widenToDivision @opts.selectedDivision.value(), viewOptions
            if @opts.services.size() or @opts.searchResults.size() and @opts.selectedUnits.isEmpty()
                if bounds?
                    unless @opts.selectedPosition.isEmpty() and mapBounds.contains bounds
                        if @embedded == true
                            @map.fitBounds bounds
                            return
                        else
                            # Only zoom in, unless current map bounds is empty of units.
                            unitsInsideMap = @_objectsInsideBounds mapBounds, @opts.units
                            unless @opts.selectedPosition.isEmpty() and unitsInsideMap
                                viewOptions = @_widenViewMinimally @opts.units, viewOptions

            @setMapView viewOptions

        setMapView: (viewOptions) ->
            unless viewOptions?
                return
            bounds = viewOptions.bounds
            if bounds
                # Don't pan just to center the view if the bounds are already
                # contained, unless the map can be zoomed in.
                if (@map.getZoom() == @map.getBoundsZoom(bounds) and
                    @map.getBounds().contains bounds) then return
                @map.fitBounds viewOptions.bounds,
                    paddingTopLeft: [20, 0]
                    paddingBottomRight: [20, 20]
            else if viewOptions.center and viewOptions.zoom
                @map.setView viewOptions.center, viewOptions.zoom

        centerLatLng: (latLng, opts) ->
            zoom = @map.getZoom()
            if @opts.selectedPosition.isSet()
                zoom = MapUtils.getZoomlevelToShowAllMarkers()
            else if @opts.selectedUnits.isSet()
                zoom = MapUtils.getZoomlevelToShowAllMarkers()
            @map.setView latLng, zoom

        adaptToLatLngs: (latLngs) ->
            if latLngs.length == 0
                return
            @adaptToBounds L.latLngBounds latLngs

        _objectsInsideBounds: (bounds, objects) ->
            objects.find (object) ->
                latLng = MapUtils.latLngFromGeojson (object)
                if latLng?
                    return bounds.contains latLng
                false

        _widenToDivision: (division, viewOptions) ->
            mapBounds = @map.getBounds()
            viewOptions.center = null
            viewOptions.zoom = null
            bounds = L.latLngBounds L.GeoJSON.geometryToLayer(division.get('boundary'), null, null, {}).getBounds()
            if mapBounds.contains bounds
                viewOptions = null
            else
                viewOptions.bounds = bounds
            viewOptions

        _widenViewMinimally: (units, viewOptions) ->
            UNIT_COUNT = 2
            mapBounds = @map.getBounds()
            center = viewOptions.center or @map.getCenter()
            sortedUnits =
                units.chain()
                .filter (unit) => unit.has 'location'
                # TODO: profile?
                .sortBy (unit) => center.distanceTo MapUtils.latLngFromGeojson(unit)
                .value()

            topLatLngs = []
            unitsFound = {}
            if @opts.services.size()
                _.each @opts.services.pluck('id'), (id) =>
                    unitsFound[id] = UNIT_COUNT

                # We want to have at least UNIT_COUNT visible units
                # per service.
                for unit in sortedUnits
                    if _.isEmpty unitsFound
                        break
                    service = unit.collection.filters?.service
                    if service?
                        countLeft = unitsFound[service]
                        if countLeft?
                            unitsFound[service] -= 1
                            if unitsFound[service] == 0
                                delete unitsFound[service]
                        topLatLngs.push MapUtils.latLngFromGeojson(unit)
            # All of the search results have to be visible.
            else if @opts.searchResults.isSet()
                topLatLngs = _(sortedUnits).map (unit) =>
                    MapUtils.latLngFromGeojson(unit)
            if sortedUnits?.length
                viewOptions.bounds =
                    L.latLngBounds topLatLngs
                    .extend center
                viewOptions.center = null
                viewOptions.zoom = null

            viewOptions


        zoomIn: ->
            @wasAutomatic = true
            @map.setZoom @map.getZoom() + 1

define [
    'leaflet',
    'backbone',
    'backbone.marionette',
    'leaflet.markercluster',
    'leaflet.activearea',
    'i18next',
    'app/widgets',
    'app/models',
    'app/p13n',
    'app/jade',
    'app/map-base-view',
    'app/transit-map',
    'app/map',
    'app/base',
    'app/map-state-model',
    'app/views/exporting',
    'app/views/location-refresh-button'
], (
    leaflet,
    Backbone,
    Marionette,
    markercluster,
    leaflet_activearea,
    i18n,
    widgets,
    models,
    p13n,
    jade,
    MapBaseView,
    TransitMapMixin,
    map,
    mixOf: mixOf
    MapStateModel,
    ExportingView,
    LocationRefreshButtonView
) ->

    ICON_SIZE = 40
    if getIeVersion() and getIeVersion() < 9
        ICON_SIZE *= .8
    MARKER_POINT_VARIANT = false
    DEFAULT_CENTER = [60.171944, 24.941389] # todo: depends on city

    class MapView extends mixOf MapBaseView, TransitMapMixin
        tagName: 'div'
        initialize: (@opts, @mapOpts) ->
            super @opts, @mapOpts
            @selectedServices = @opts.services
            @searchResults = @opts.searchResults
            #@listenTo @units, 'add', @drawUnits
            # @selectedPosition = @opts.selectedPosition
            @selectedDivision = @opts.selectedDivision
            @userPositionMarkers =
                accuracy: null
                position: null
                clicked: null

            @listenTo @selectedServices, 'add', (service, collection) =>
                if collection.size() == 1
                    @markers = {}
            @listenTo @selectedServices, 'remove', (model, collection) =>
                if collection.size() == 0
                    @markers = {}

            @listenTo @selectedDivision, 'change:value', (model) =>
                @divisionLayer.clearLayers()
                @drawDivision model.value()

            @listenTo @units, 'unit:highlight', @highlightUnselectedUnit
            @listenTo @units, 'batch-remove', @removeUnits
            @listenTo @units, 'remove', @removeUnit
            @listenTo @selectedUnits, 'reset', @handleSelectedUnit
            @listenTo p13n, 'position', @handlePosition

            if @selectedPosition.isSet()
                @listenTo @selectedPosition.value(), 'change:radiusFilter', @radiusFilterChanged
            @listenTo @selectedPosition, 'change:value', (wrapper, value) =>
                previous = wrapper.previous 'value'
                if previous?
                    @stopListening previous
                if value?
                    @listenTo value, 'change:radiusFilter', @radiusFilterChanged
                @handlePosition value, center: true

            MapView.setMapActiveAreaMaxHeight
                maximize:
                    @selectedPosition.isEmpty() and @selectedUnits.isEmpty()

            @initializeTransitMap
                route: @opts.route
                selectedUnits: @selectedUnits
                selectedPosition: @selectedPosition

            #$(window).resize => _.defer(_.bind(@recenter, @))

        onMapClicked: (ev) ->
            unless @hasClickedPosition? then @hasClickedPosition = false
            if @hasClickedPosition
                @infoPopups.clearLayers()
                @map.removeLayer @userPositionMarkers['clicked']
                @hasClickedPosition = false
            else
                if @pendingPosition?
                    position = @pendingPosition
                else
                    position = new models.CoordinatePosition
                        isDetected: false
                position.set 'location',
                    coordinates: [ev.latlng.lng, ev.latlng.lat]
                    accuracy: 0
                    type: 'Point'
                if @pendingPosition?
                    @pendingPosition = null
                    $('#map').css 'cursor', 'auto'
                else
                    position.set 'name', null
                    @hasClickedPosition = true
                @handlePosition position, initial: true

        requestLocation: (position) ->
            $('#map').css 'cursor', 'crosshair'
            @pendingPosition = position

        radiusFilterChanged: (position, radius) ->
            @divisionLayer.clearLayers()
            unless radius?
                return
            latLng = L.GeoJSON.geometryToLayer(position.get('location'))
            poly = new widgets.CirclePolygon latLng.getLatLng(), radius, {invert: true, stroke: false}
            poly.circle.options.fill = false
            poly.addTo @divisionLayer
            poly.circle.addTo @divisionLayer

        handleSelectedUnit: (units, options) ->
            if units.isEmpty()
                # The previously selected unit might have been a bbox unit.
                @_removeBboxMarkers @map.getZoom(), map.MapUtils.getZoomlevelToShowAllMarkers()
                MapView.setMapActiveAreaMaxHeight maximize: true
                return
            unit = units.first()
            latLng = unit.marker?.getLatLng()
            if latLng?
                @map.adaptToLatLngs [latLng]
            unless unit.hasBboxFilter()
                @_removeBboxMarkers()
                @_skipBboxDrawing = false
            _.defer => @highlightSelectedUnit unit

        handlePosition: (positionObject, opts) ->
            # TODO: clean up this method
            unless positionObject?
                for key in ['clicked', 'address']
                    layer = @userPositionMarkers[key]
                    if layer then @map.removeLayer layer

            isSelected = positionObject == @selectedPosition.value()

            key = positionObject?.origin()
            if key != 'detected'
                @infoPopups.clearLayers()

            prev = @userPositionMarkers[key]
            if prev then @map.removeLayer prev

            if (key == 'address') and @userPositionMarkers.clicked?
                @map.removeLayer @userPositionMarkers.clicked
            if (key == 'clicked') and isSelected and @userPositionMarkers.address?
                @map.removeLayer @userPositionMarkers.address

            location = positionObject?.get 'location'
            unless location then return

            accuracy = location.accuracy
            accuracyMarker = L.circle latLng, accuracy, weight: 0

            latLng = map.MapUtils.latLngFromGeojson positionObject
            marker = map.MapUtils.createPositionMarker latLng, accuracy, positionObject.origin()
            marker.position = positionObject
            marker.on 'click', => app.commands.execute 'selectPosition', positionObject
            if isSelected or opts?.center
                @map.refitAndAddMarker marker
            else
                marker.addTo @map

            @userPositionMarkers[key] = marker

            if isSelected
                @infoPopups.clearLayers()

            popup = @createPositionPopup positionObject, marker

            if not positionObject?.isDetectedLocation() or
                @selectedUnits.isEmpty() and (
                    @selectedPosition.isEmpty() or
                    @selectedPosition.value() == positionObject)
                pop = => @infoPopups.addLayer popup
                unless positionObject.get 'preventPopup'
                    if isSelected or (opts?.initial and not positionObject.get('preventPopup'))
                        pop()
                        if isSelected
                            $(popup._wrapper).addClass 'selected'

            positionObject.popup = popup

        width: ->
            @$el.width()
        height: ->
            @$el.height()

        removeUnits: (options) ->
            @allMarkers.clearLayers()
            @drawUnits @units
            unless @selectedUnits.isEmpty()
                @highlightSelectedUnit @selectedUnits.first()
            if @units.isEmpty()
                @showAllUnitsAtHighZoom()

        removeUnit: (unit, units, options) ->
            if unit.marker?
                @allMarkers.removeLayer unit.marker
                delete unit.marker

        getServices: ->
            @selectedServices

        createPositionPopup: (positionObject, marker) ->
            latLng = map.MapUtils.latLngFromGeojson(positionObject)
            address = positionObject.humanAddress()
            unless address
                address = i18n.t 'map.retrieving_address'
            if positionObject == @selectedPosition.value()
                popupContents =
                    (ctx) =>
                        "<div class=\"unit-name\">#{ctx.name}</div>"
                offsetY = switch positionObject.origin()
                    when 'detected' then 10
                    when 'address' then 10
                    else 38
                popup = @createPopup(null, null, L.point(0, offsetY))
                    .setContent popupContents
                        name: address
                    .setLatLng latLng
            else
                popupContents =
                    (ctx) =>
                        ctx.detected = positionObject?.isDetectedLocation()
                        $popupEl = $ jade.template 'position-popup', ctx
                        $popupEl.on 'click', (e) =>
                            unless positionObject == @selectedPosition.value()
                                e.stopPropagation()
                                @listenTo positionObject, 'reverse-geocode', =>
                                    app.commands.execute 'selectPosition', positionObject
                                marker.closePopup()
                                @infoPopups.clearLayers()
                                @map.removeLayer positionObject.popup
                                if positionObject.isReverseGeocoded()
                                    positionObject.trigger 'reverse-geocode'

                        $popupEl[0]
                offsetY = switch positionObject.origin()
                    when 'detected' then -53
                    when 'clicked' then -15
                    when 'address' then -50
                offset = L.point 0, offsetY
                popupOpts =
                    closeButton: false
                    className: 'position'
                    autoPan: false
                    offset: offset
                    autoPanPaddingTopLeft: L.point 30, 80
                    autoPanPaddingBottomRight: L.point 30, 80
                popup = L.popup(popupOpts)
                    .setLatLng latLng
                    .setContent popupContents
                        name: address

            positionObject.reverseGeocode?().done =>
                popup.setContent popupContents
                    name: positionObject.humanAddress()
            popup

        highlightSelectedUnit: (unit) ->
            # Prominently highlight the marker whose details are being
            # examined by the user.
            unless unit?
                return
            marker = unit.marker
            popup = marker?.popup
            unless popup
                return
            popup.selected = true
            @_clearOtherPopups popup, clearSelected: true
            unless @popups.hasLayer popup
                popup.setLatLng marker.getLatLng()
                @popups.addLayer popup
            @listenToOnce unit, 'change:selected', (unit) =>
                $(marker?._icon).removeClass 'selected'
                $(marker?.popup._wrapper).removeClass 'selected'
                @popups.removeLayer marker?.popup
            $(marker?._icon).addClass 'selected'
            $(marker?.popup._wrapper).addClass 'selected'

        selectMarker: (event) ->
            marker = event.target
            unit = marker.unit
            app.commands.execute 'selectUnit', unit

        drawUnit: (unit, units, options) ->
            location = unit.get 'location'
            if location?
                marker = @createMarker unit
                @allMarkers.addLayer marker

        getCenteredView: ->
            if @selectedPosition.isSet()
                center: map.MapUtils.latLngFromGeojson @selectedPosition.value()
                zoom: map.MapUtils.getZoomlevelToShowAllMarkers()
            else if @selectedUnits.isSet()
                center: map.MapUtils.latLngFromGeojson @selectedUnits.first()
                zoom: Math.max @getMaxAutoZoom(), @map.getZoom()
            else
                null

        resetMap: ->
            # With different projections the base layers cannot
            # be changed on a live map.
            window.location.reload true

        handleP13nChange: (path, newVal) ->
            if path[0] != 'map_background_layer'
                return

            oldLayer = @map._baseLayer
            oldCrs = @map.crs

            mapStyle = p13n.get 'map_background_layer'
            {layer: newLayer, crs: newCrs} = map.MapMaker.makeBackgroundLayer style: mapStyle

            if newCrs.code != oldCrs.code
                @resetMap()
                return

            @map.addLayer newLayer
            @map.removeLayer oldLayer
            @map._baseLayer = newLayer

        addMapActiveArea: ->
            @map.setActiveArea 'active-area'
            MapView.setMapActiveAreaMaxHeight
                maximize: @selectedUnits.isEmpty() and @selectedPosition.isEmpty()

        initializeMap: ->
            @setInitialView()
            window.debugMap = map
            @listenTo p13n, 'change', @handleP13nChange
            # The line below is for debugging without clusters.
            # @allMarkers = L.featureGroup()
            @popups = L.layerGroup()
            @infoPopups = L.layerGroup()

            #L.control.scale(imperial: false).addTo(@map);

            L.control.zoom(
                position: 'bottomright'
                zoomInText: "<span class=\"icon-icon-zoom-in\"></span><span class=\"sr-only\">#{i18n.t('assistive.zoom_in')}</span>"
                zoomOutText: "<span class=\"icon-icon-zoom-out\"></span><span class=\"sr-only\">#{i18n.t('assistive.zoom_out')}</span>").addTo @map

            new widgets.ControlWrapper(new LocationRefreshButtonView(), position: 'bottomright').addTo @map
            new widgets.ControlWrapper(new ExportingView(), position: 'bottomright').addTo @map

            @popups.addTo @map
            @infoPopups.addTo @map

            @debugGrid = L.layerGroup().addTo(@map)
            @debugCircles = {}

            @_addMapMoveListeners()

            # If the user has allowed location requests before,
            # try to get the initial location now.
            if p13n.getLocationRequested()
                p13n.requestLocation()

            @previousZoomlevel = @map.getZoom()
            @drawInitialState()

        _removeBboxMarkers: (zoom, zoomLimit) ->
            unless @markers?
                return
            if @markers.length == 0
                return
            if zoom? and zoomLimit?
                if zoom >= zoomLimit
                    return
            @_skipBboxDrawing = true
            if @selectedServices.isSet()
                return
            toRemove = _.filter @markers, (m) =>
                unit = m?.unit
                ret = unit?.collection?.hasReducedPriority() and not unit?.get 'selected'
            app.commands.execute 'clearFilters'
            @allMarkers.removeLayers toRemove
            @_clearOtherPopups null, null

        _addMapMoveListeners: ->
            zoomLimit = map.MapUtils.getZoomlevelToShowAllMarkers()
            @map.on 'zoomanim', (data) =>
                @_skipBboxDrawing = false
                @_removeBboxMarkers data.zoom, zoomLimit
            @map.on 'zoomend', =>
                @_removeBboxMarkers @map.getZoom(), zoomLimit
            @map.on 'moveend', =>
                # TODO: cleaner way to prevent firing from refit
                if @skipMoveend
                    @skipMoveend = false
                    return
                @showAllUnitsAtHighZoom()

        postInitialize: ->
            @addMapActiveArea()
            @initializeMap()
            @_addMouseoverListeners @allMarkers

        @mapActiveAreaMaxHeight: =>
            screenWidth = $(window).innerWidth()
            screenHeight = $(window).innerHeight()
            Math.min(screenWidth * 0.4, screenHeight * 0.3)

        preAdapt: =>
            MapView.setMapActiveAreaMaxHeight()

        @setMapActiveAreaMaxHeight: (options) =>
            # Sets the height of the map shown in views that have a slice of
            # map visible on mobile.
            defaults = maximize: false
            options = options or {}
            _.extend defaults, options
            options = defaults
            if $(window).innerWidth() <= appSettings.mobile_ui_breakpoint
                height = MapView.mapActiveAreaMaxHeight()
                $activeArea = $ '.active-area'
                if options.maximize
                    $activeArea.css 'height', 'auto'
                    $activeArea.css 'bottom', 0
                else
                    $activeArea.css 'height', height
                    $activeArea.css 'bottom', 'auto'
            else
                $('.active-area').css 'height', 'auto'
                $('.active-area').css 'bottom', 0

        recenter: ->
            view = @getCenteredView()
            unless view?
                return
            @map.setView view.center, view.zoom, pan: duration: 0.5

        refitBounds: ->
            @skipMoveend = true
            @map.fitBounds @allMarkers.getBounds(),
                maxZoom: @getMaxAutoZoom()
                animate: true

        fitItinerary: (layer) ->
            @map.fitBounds layer.getBounds(),
                paddingTopLeft: [20,20]
                paddingBottomRight: [20,20]

        showAllUnitsAtHighZoom: ->
            if $(window).innerWidth() <= appSettings.mobile_ui_breakpoint
                return
            if @map.getZoom() >= map.MapUtils.getZoomlevelToShowAllMarkers()
                if @selectedUnits.isSet() and not @selectedUnits.first().collection?.filters?.bbox?
                    return
                if @selectedServices.isSet()
                    return
                if @searchResults.isSet()
                    return
                transformedBounds = map.MapUtils.overlappingBoundingBoxes @map
                bboxes = []
                for bbox in transformedBounds
                    bboxes.push "#{bbox[0][0]},#{bbox[0][1]},#{bbox[1][0]},#{bbox[1][1]}"
                if @mapOpts.level?
                    level = @mapOpts.level
                    delete @mapOpts.level
                app.commands.execute 'addUnitsWithinBoundingBoxes', bboxes, level
    MapView

define [
    'leaflet',
    'proj4leaflet',
    'underscore',
    'app/base',
], (
    leaflet,
    p4j,
    _,
    sm
) ->

    RETINA_MODE = window.devicePixelRatio > 1

    getMaxBounds = (layer) ->
        L.latLngBounds L.latLng(59.5, 24.2), L.latLng(60.5, 25.5)

    wmtsPath = (style, language) ->
        stylePath =
            if style == 'accessible_map'
                if language == 'sv'
                    "osm-sm-visual-sv/etrs_tm35fin"
                else
                    "osm-sm-visual/etrs_tm35fin"
            else if RETINA_MODE
                if language == 'sv'
                    "osm-sm-sv-hq/etrs_tm35fin_hq"
                else
                    "osm-sm-hq/etrs_tm35fin_hq"
            else
                if language == 'sv'
                    "osm-sm-sv/etrs_tm35fin"
                else
                    "osm-sm/etrs_tm35fin"
        path = [
            "http://geoserver.hel.fi/mapproxy/wmts",
            stylePath,
            "{z}/{x}/{y}.png"
        ]
        path.join '/'

    makeLayer =
        tm35:
            crs: ->
                crsName = 'EPSG:3067'
                projDef = '+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
                bounds = L.bounds L.point(-548576, 6291456), L.point(1548576, 8388608)
                originNw = [bounds.min.x, bounds.max.y]
                crsOpts =
                    resolutions: [8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125]
                    bounds: bounds
                    transformation: new L.Transformation 1, -originNw[0], -1, originNw[1]
                new L.Proj.CRS crsName, projDef, crsOpts

            layer: (opts) ->
                L.tileLayer wmtsPath(opts.style, opts.language),
                    maxZoom: 15
                    minZoom: 6
                    continuousWorld: true
                    tms: false

        gk25:
            crs: ->
                crsName = 'EPSG:3879'
                projDef = '+proj=tmerc +lat_0=0 +lon_0=25 +k=1 +x_0=25500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'

                bounds = [25440000, 6630000, 25571072, 6761072]
                new L.Proj.CRS.TMS crsName, projDef, bounds,
                    resolutions: [256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125, 0.0625, 0.03125]

            layer: (opts) ->
                geoserverUrl = (layerName, layerFmt) ->
                    "http://geoserver.hel.fi/geoserver/gwc/service/tms/1.0.0/#{layerName}@ETRS-GK25@#{layerFmt}/{z}/{x}/{y}.#{layerFmt}"
                if opts.style == 'ortographic'
                    new L.Proj.TileLayer.TMS geoserverUrl("hel:orto2013", "jpg"), opts.crs,
                        maxZoom: 10
                        minZoom: 2
                        continuousWorld: true
                        tms: false
                else
                    guideMapUrl = geoserverUrl("hel:Karttasarja", "gif")
                    guideMapOptions =
                        maxZoom: 12
                        minZoom: 2
                        continuousWorld: true
                        tms: false
                    (new L.Proj.TileLayer.TMS guideMapUrl, opts.crs, guideMapOptions).setOpacity 0.8

    SMap = L.Map.extend
        refitAndAddLayer: (layer) ->
            @mapState.adaptToLayer layer
            @addLayer layer
        refitAndAddMarker: (marker) ->
            @mapState.adaptToLatLngs [marker.getLatLng()]
            @addLayer marker
        adaptToLatLngs: (latLngs) ->
            @mapState.adaptToLatLngs latLngs
        adapt: ->
            @mapState.adaptToBounds null

    class MapMaker
        @makeBackgroundLayer: (options) ->
            coordinateSystem = switch options.style
                when 'guidemap' then 'gk25'
                when 'ortographic' then 'gk25'
                else 'tm35'
            layerMaker = makeLayer[coordinateSystem]
            crs = layerMaker.crs()
            options.crs = crs
            tileLayer = layerMaker.layer options
            tileLayer.on 'tileload', (e) =>
                e.tile.setAttribute 'alt', ''
            layer: tileLayer
            crs: crs
        @createMap: (domElement, options, mapOptions, mapState) ->
            {layer: layer, crs: crs} = MapMaker.makeBackgroundLayer options
            defaultMapOptions =
                crs: crs
                continuusWorld: true
                worldCopyJump: false
                zoomControl: false
                closePopupOnClick: false
                maxBounds: getMaxBounds options.style
                layers: [layer]
            _.extend defaultMapOptions, mapOptions
            map = new SMap domElement, defaultMapOptions
            mapState?.setMap map
            map.crs = crs
            map._baseLayer = layer
            map

    class MapUtils
        @createPositionMarker: (latLng, accuracy, type, opts) ->
            Z_INDEX = -1000
            switch type
                when 'detected'
                    opts =
                        icon: L.divIcon
                            iconSize: L.point 40, 40
                            iconAnchor: L.point 20, 39
                            className: 'servicemap-div-icon'
                            html: '<span class="icon-icon-you-are-here"></span'
                        zIndexOffset: Z_INDEX
                    marker = L.marker latLng, opts
                when 'clicked'
                    marker = L.circleMarker latLng,
                        color: '#666'
                        weight: 2
                        opacity: 1
                        fill: false
                        clickable: if opts?.clickable? then opts.clickable else false
                        zIndexOffset: Z_INDEX
                    marker.setRadius 6
                when 'address'
                    opts =
                        zIndexOffset: Z_INDEX
                        icon: L.divIcon
                            iconSize: L.point 40, 40
                            iconAnchor: L.point 20, 39
                            className: 'servicemap-div-icon'
                            html: '<span class="icon-icon-address"></span'
                    marker = L.marker latLng, opts
            return marker

        @overlappingBoundingBoxes: (map) ->
            crs = map.crs
            if map._originalGetBounds?
                latLngBounds = map._originalGetBounds()
            else
                latLngBounds = map.getBounds()
            METER_GRID = 1000
            DEBUG_GRID = false
            ne = crs.project latLngBounds.getNorthEast()
            sw = crs.project latLngBounds.getSouthWest()
            min = x: ne.x, y: sw.y
            max = y: ne.y, x: sw.x

            snapToGrid = (coord) ->
                parseInt(coord / METER_GRID) * METER_GRID
            coordinates = {}
            for dim in ['x', 'y']
                coordinates[dim] = coordinates[dim] or {}
                for value in [min[dim] .. max[dim]]
                    coordinates[dim][parseInt(snapToGrid(value))] = true

            pairs = _.flatten(
                [parseInt(x), parseInt(y)] for x in _.keys(coordinates.x) for y in _.keys(coordinates.y),
                true)

            bboxes = _.map pairs, ([x, y]) -> [[x, y], [x + METER_GRID, y + METER_GRID]]
            if DEBUG_GRID
                @debugGrid.clearLayers()
                for bbox in bboxes
                    sw = crs.projection.unproject(L.point(bbox[0]...))
                    ne = crs.projection.unproject(L.point(bbox[1]...))
                    sws = [sw.lat, sw.lng].join()
                    nes = [ne.lat, ne.lng].join()
                    unless @debugCircles[sws]
                        @debugGrid.addLayer L.circle(sw, 10)
                        @debugCircles[sws] = true
                    unless @debugCircles[nes]
                        @debugGrid.addLayer L.circle(ne, 10)
                        @debugCircles[nes] = true
                    # rect = L.rectangle([sw, ne])
                    # @debugGrid.addLayer rect
            bboxes

        @latLngFromGeojson: (object) ->
            L.latLng object?.get('location')?.coordinates?.slice(0).reverse()

        @getZoomlevelToShowAllMarkers: ->
            layer = p13n.get('map_background_layer')
            if layer == 'guidemap'
                return 8
            else if layer == 'ortographic'
                return 8
            else
                return 14

    makeDistanceComparator = (p13n) =>
        createFrom = (position) =>
            (obj) =>
                [a, b] = [MapUtils.latLngFromGeojson(position), MapUtils.latLngFromGeojson(obj)]
                result = a.distanceTo b
                result
        position = p13n.getLastPosition()
        if position?
            createFrom position

    MapMaker: MapMaker
    MapUtils: MapUtils
    makeDistanceComparator: makeDistanceComparator

define [
    'moment',
    'underscore',
    'raven',
    'backbone',
    'i18next',
    'app/base',
    'app/settings',
    'app/spinner',
    'app/alphabet',
    'app/accessibility'
], (
    moment,
    _,
    Raven,
    Backbone,
    i18n,
    {mixOf: mixOf, pad: pad, withDeferred: withDeferred}
    settings,
    SMSpinner,
    alphabet,
    accessibility
) ->

    BACKEND_BASE = appSettings.service_map_backend
    LINKEDEVENTS_BASE = appSettings.linkedevents_backend
    OPEN311_BASE = appSettings.open311_backend
    OPEN311_WRITE_BASE = appSettings.open311_write_backend + '/'

    # TODO: remove and handle in geocoder
    MUNICIPALITIES =
        49: 'espoo'
        91: 'helsinki'
        92: 'vantaa'
        235: 'kauniainen'
    MUNICIPALITY_IDS = _.invert MUNICIPALITIES

    Backbone.ajax = (request) ->
        request = settings.applyAjaxDefaults request
        return Backbone.$.ajax.call Backbone.$, request

    class FilterableCollection extends Backbone.Collection
        initialize: (options) ->
            @filters = {}
        setFilter: (key, val) ->
            if not val
                if key of @filters
                    delete @filters[key]
            else
                @filters[key] = val
            @
        clearFilters: ->
            @filters = {}
        fetch: (options) ->
            data = _.clone @filters
            if options.data?
                data = _.extend data, options.data
            options.data = data
            super options

    class RESTFrameworkCollection extends FilterableCollection
        parse: (resp, options) ->
            # Transform Django REST Framework response into PageableCollection
            # compatible structure.
            @fetchState =
                count: resp.count
                next: resp.next
                previous: resp.previous
            super resp.results, options

    class WrappedModel extends Backbone.Model
        initialize: (model) ->
            super()
            @wrap model
        wrap: (model) ->
            @set 'value', model or null
        value: ->
            @get 'value'
        isEmpty: ->
            return not @has 'value'
        isSet: ->
            return not @isEmpty()

    class GeoModel
        getLatLng: ->
            if @latLng?
                @latLng
            coords = @get('location')?.coordinates
            if coords?
                @latLng = L.GeoJSON.coordsToLatLng coords
            else
                null

        getDistanceToLastPosition: ->
            position = p13n.getLastPosition()
            if position?
                latLng = @getLatLng()
                if latLng?
                    position.getLatLng().distanceTo latLng
                else
                    Number.MAX_VALUE

    class SMModel extends Backbone.Model
        # FIXME/THINKME: Should we take care of translation only in
        # the view level? Probably.
        getText: (attr) ->
            val = @get attr
            if attr in @translatedAttrs
                return p13n.getTranslatedAttr val
            return val
        toJSON: (options) ->
            data = super()
            if not @translatedAttrs
                return data
            for attr in @translatedAttrs
                if attr not of data
                    continue
                data[attr] = p13n.getTranslatedAttr data[attr]
            return data

        url: ->
            ret = super
            if ret.substr -1 != '/'
                ret = ret + '/'
            return ret

        urlRoot: ->
            return "#{BACKEND_BASE}/#{@resourceName}/"

    class SMCollection extends RESTFrameworkCollection
        initialize: (models, options) ->
            @filters = {}
            @currentPage = 1
            if options?
                @pageSize = options.pageSize || 25
                if options.setComparator
                    @setDefaultComparator()
            super options

        url: ->
            obj = new @model
            return "#{BACKEND_BASE}/#{obj.resourceName}/"

        isSet: ->
            return not @isEmpty()

        setFilter: (key, val) ->
            if not val
                if key of @filters
                    delete @filters[key]
            else
                @filters[key] = val
            return @

        clearFilters: ->
            @filters = {}

        fetchNext: (options) ->
            if @fetchState? and not @fetchState.next
                return false

            @currentPage++
            defaults = {reset: false, remove: false}
            if options?
                options = _.extend options, defaults
            else
                options = defaults
            @fetch options

        fetch: (options) ->
            if options?
                options = _.clone options
            else
                options = {}

            unless options.data?
                options.data = {}
            options.data.page = @currentPage
            options.data.page_size = @pageSize

            if options.spinnerOptions?.container
                spinner = new SMSpinner(options.spinnerOptions)
                spinner.start()

                success = options.success
                error = options.error

                options.success = (collection, response, options) ->
                    spinner.stop()
                    success?(collection, response, options)

                options.error = (collection, response, options) ->
                    spinner.stop()
                    error?(collection, response, options)

            delete options.spinnerOptions

            super options

        fetchFields: (start, end, fields) ->
            # Fetches more model details for a specified range
            # in the collection.
            if not fields
                return $.Deferred().resolve().promise()
            filtered = _(@slice(start, end)).filter (m) =>
                for field in fields
                    if m.get(field) == undefined
                        return true
                return false
            idsToFetch = _.pluck filtered, 'id'
            unless idsToFetch.length
                return $.Deferred().resolve().promise()
            @fetch
                remove: false
                data:
                    page_size: idsToFetch.length
                    id: idsToFetch.join ','
                    include: fields.join ','

        getComparatorKeys: -> ['default', 'alphabetic', 'alphabetic_reverse']
        getComparator: (key, direction) =>
            switch key
                when 'alphabetic'
                    alphabet.makeComparator direction
                when 'alphabetic_reverse'
                    alphabet.makeComparator -1
                when 'distance'
                    (x) => x.getDistanceToLastPosition()
                when 'distance_precalculated'
                    (x) => x.get 'distance'
                when 'default'
                    (x) => -x.get 'score'
                when 'accessibility'
                    (x) => x.getShortcomingCount()
                else
                    null
        comparatorWrapper: (fn) =>
            unless fn
                return fn
            if fn.length == 2
                (a, b) =>
                    fn a.getComparisonKey(), b.getComparisonKey()
            else
                fn

        setDefaultComparator: ->
            @setComparator @getComparatorKeys()[0]
        setComparator: (key, direction) ->
            index = @getComparatorKeys().indexOf(key)
            if index != -1
                @currentComparator = index
                @currentComparatorKey = key
                @comparator = @comparatorWrapper @getComparator(key, direction)
        cycleComparator: ->
            unless @currentComparator?
                @currentComparator = 0
            @currentComparator += 1
            @currentComparator %= @getComparatorKeys().length
            @reSort @getComparatorKeys()[@currentComparator]
        reSort: (key, direction) ->
            @setComparator key, direction
            if @comparator?
                @sort()
            key
        getComparatorKey: ->
            @currentComparatorKey

        hasReducedPriority: ->
            false

    class Unit extends mixOf SMModel, GeoModel
        resourceName: 'unit'
        translatedAttrs: ['name', 'description', 'street_address']

        initialize: (options) ->
            super options
            @eventList = new EventList()
            @feedbackList = new FeedbackList()

        getEvents: (filters, options) ->
            if not filters?
                filters = {}
            if 'start' not of filters
                filters.start = 'today'
            if 'sort' not of filters
                filters.sort = 'start_time'
            filters.location = "tprek:#{@get 'id'}"
            @eventList.filters = filters
            if not options?
                options =
                    reset: true
            else if not options.reset
                options.reset = true
            @eventList.fetch options

        getFeedback: (options) ->
            @feedbackList.setFilter 'service_object_id', @id
            #@feedbackList.setFilter 'updated_after', '2015-05-20'
            options = options or {}
            _.extend options, reset: true
            @feedbackList.fetch options

        isDetectedLocation: ->
            false
        isPending: ->
            false

        otpSerializeLocation: (opts) ->
            if opts.forceCoordinates
                coords = @get('location').coordinates
                "#{coords[1]},#{coords[0]}"
            else
                "poi:tprek:#{@get 'id'}"

        getSpecifierText: ->
            specifierText = ''
            unless @get('services')?
                return specifierText
            level = null
            for service in @get 'services'
                if not level or service.level < level
                    specifierText = service.name[p13n.getLanguage()]
                    level = service.level
            return specifierText

        getComparisonKey: ->
            p13n.getTranslatedAttr @get('name')

        toJSON: (options) ->
            data = super()
            openingHours = _.filter @get('connections'), (c) ->
                c.section == 'opening_hours' and p13n.getLanguage() of c.name
            lang = p13n.getLanguage()
            if openingHours.length > 0
                data.opening_hours = _(openingHours)
                    .chain()
                    .sortBy 'type'
                    .map (hours) =>
                        content: hours.name[lang]
                        url: hours.www_url?[lang]
                    .value()

            highlights = _.filter @get('connections'), (c) ->
                c.section == 'miscellaneous' and p13n.getLanguage() of c.name
            data.highlights = _.sortBy highlights, (c) -> c.type

            links = _.filter @get('connections'), (c) ->
                c.section == 'links' and p13n.getLanguage() of c.name
            data.links = _.sortBy links, (c) -> c.type
            data

        hasBboxFilter: ->
            @collection?.filters?.bbox?

        hasAccessibilityData: ->
            # TODO: re-enable these services when data ready
            fn = (x)-> x.id in [33467, 33399]
            blacklistHits = _(@get('services')).filter(fn).length
            @get('accessibility_properties')?.length and blacklistHits == 0

        getTranslatedShortcomings: ->
            profiles = p13n.getAccessibilityProfileIds()
            {status: status, results: shortcomings} = accessibility.getTranslatedShortcomings profiles, @

        getShortcomingCount: ->
            unless @hasAccessibilityData()
                return Number.MAX_VALUE
            shortcomings = @getTranslatedShortcomings()
            @shortcomingCount = 0
            for __, group of shortcomings.results
                @shortcomingCount += _.values(group).length
            @shortcomingCount

    class UnitList extends SMCollection
        model: Unit
        comparator: null
        initialize: (models, opts) ->
            super models, opts
            @forcedPriority = opts?.forcedPriority
        getComparatorKeys: ->
            keys = []
            if p13n.hasAccessibilityIssues() then keys.push 'accessibility'
            if @overrideComparatorKeys?
                return _(@overrideComparatorKeys).union keys
            _(keys).union ['default', 'distance', 'alphabetic', 'alphabetic_reverse']
        hasReducedPriority: ->
            ret = if @forcedPriority
                false
            else
                @filters?.bbox?
            return ret

    class Department extends SMModel
        resourceName: 'department'
        translatedAttrs: ['name']

    class DepartmentList extends SMCollection
        model: Department

    class Organization extends SMModel
        resourceName: 'organization'
        translatedAttrs: ['name']

    class OrganizationList extends SMCollection
        model: Organization

    class AdministrativeDivision extends SMModel
        resourceName: 'administrative_division'
        translatedAttrs: ['name']
        getEmergencyCareUnit: ->
            if @get('type') == 'emergency_care_district'
                switch @get('ocd_id')
                    when 'ocd-division/country:fi/kunta:helsinki/päivystysalue:haartmanin_päivystysalue'
                        return 11828 # Haartman
                    when 'ocd-division/country:fi/kunta:helsinki/päivystysalue:marian_päivystysalue'
                        return 4060 # Malmi
                    # The next ID anticipates a probable change in the division name
                    when 'ocd-division/country:fi/kunta:helsinki/päivystysalue:malmin_päivystysalue'
                        return 4060 # Malmi
            null
    class AdministrativeDivisionList extends SMCollection
        model: AdministrativeDivision

    class AdministrativeDivisionType extends SMModel
        resourceName: 'administrative_division_type'

    class AdministrativeDivisionTypeList extends SMCollection
        model: AdministrativeDivision

    class Service extends SMModel
        resourceName: 'service'
        translatedAttrs: ['name']
        initialize: ->
            @set 'units', new models.UnitList null, setComparator: true
            units = @get 'units'
            units.overrideComparatorKeys = ['alphabetic', 'alphabetic_reverse', 'distance']
            units.setDefaultComparator()
        getSpecifierText: ->
            specifierText = ''
            unless @get('ancestors')?
                return specifierText
            for ancestor, index in @get 'ancestors'
                if index > 0
                    specifierText += ' • '
                specifierText += ancestor.name[p13n.getLanguage()]
            return specifierText
        getComparisonKey: ->
            p13n.getTranslatedAttr @get('name')

    class Street extends SMModel
        resourceName: 'street'
        humanAddress: ->
            name = p13n.getTranslatedAttr @get('name')
            "#{name}, #{@getMunicipalityName()}"
        getMunicipalityName: ->
            i18n.t "municipality.#{@get('municipality')}"

    class StreetList extends SMCollection
        model: Street

    class Position extends mixOf SMModel, GeoModel
        resourceName: 'address'
        origin: -> 'clicked'
        isPending: ->
            false
        urlRoot: ->
            "#{BACKEND_BASE}/#{@resourceName}"
        parse: (response, options) ->
            data = super response, options
            street = data.street
            if street
                data.street = new Street street
            data
        isDetectedLocation: ->
            false
        isReverseGeocoded: ->
            @get('street')?
        getSpecifierText: ->
            @getMunicipalityName()
        slugifyAddress: ->
            SEPARATOR = '-'
            municipality = @get('street').get('municipality')

            slug = []
            add = (x) -> slug.push x

            street = @get('street').get('name').fi.toLowerCase().replace(/\ /g, SEPARATOR)
            add @get('number')

            numberEnd = @get 'number_end'
            letter = @get 'letter'
            if numberEnd then add "#{SEPARATOR}#{numberEnd}"
            if letter then slug[slug.length-1] += SEPARATOR + letter
            @slug = "#{municipality}/#{street}/#{slug.join(SEPARATOR)}"
            @slug
        humanAddress: (opts)->
            street = @get 'street'
            result = []
            if street?
                result.push p13n.getTranslatedAttr(street.get('name'))
                result.push @humanNumber()
                if not opts?.exclude?.municipality and street.get('municipality')
                    last = result.pop()
                    last += ','
                    result.push last
                    result.push @getMunicipalityName()
                result.join(' ')
            else
                null
        getMunicipalityName: ->
            @get('street').getMunicipalityName()
        getComparisonKey: (model) ->
            street = @get 'street'
            result = []
            if street?
                result.push i18n.t("municipality.#{street.get('municipality')}")
                [number, letter] = [@get('number'), @get('letter')]
                result.push pad(number)
                result.push letter
            result.join ''

        _humanNumber: ->
            result = []
            if @get 'number'
                result.push @get 'number'
            if @get 'number_end'
                result.push '-'
                result.push @get 'number_end'
            if @get 'letter'
                result.push @get 'letter'
            result
        humanNumber: ->
            @_humanNumber().join ''
        otpSerializeLocation: (opts) ->
            coords = @get('location').coordinates
            "#{coords[1]},#{coords[0]}"

    class AddressList extends SMCollection
        model: Position

    class CoordinatePosition extends Position
        origin: ->
            if @isDetectedLocation()
                'detected'
            else
                super()
        initialize: (attrs) ->
            @isDetected = if attrs?.isDetected? then attrs.isDetected else false
        isDetectedLocation: ->
            @isDetected
        reverseGeocode: ->
            withDeferred (deferred) =>
                unless @get('street')?
                    posList = models.PositionList.fromPosition @
                    @listenTo posList, 'sync', =>
                        bestMatch = posList.first()
                        if bestMatch.get('distance') > 500
                            bestMatch.set 'name', i18n.t 'map.unknown_address'
                        @set bestMatch.toJSON()
                        deferred.resolve()
                        @trigger 'reverse-geocode'
        isPending: ->
            !@get('location')?

    class AddressPosition extends Position
        origin: -> 'address'
        initialize: (data) ->
            unless data?
                return
            super
            @set 'location',
                coordinates: data.location.coordinates
                type: 'Point'
        isDetectedLocation: ->
            false

    class PositionList extends SMCollection
        resourceName: 'address'
        @fromPosition: (position) ->
            instance = new PositionList()
            name = position.get('street')?.get('name')
            location = position.get 'location'
            instance.model = Position
            if location and not name
                instance.fetch data:
                    lat: location.coordinates[1]
                    lon: location.coordinates[0]
            else if name and not location
                opts = data:
                    municipality: position.get('street').get('municipality')
                    number: position.get('number')
                    street: name
                instance.fetch opts
            instance

        @fromSlug: (municipality, streetName, numberPart) ->
            SEPARATOR = /-/g
            numberParts = numberPart.split SEPARATOR
            number = numberParts[0]
            number = numberPart.replace /-.*$/, ''
            street = new Street ({
                name: streetName.replace(SEPARATOR, ' '),
                municipality: municipality})
            @fromPosition new Position
                street: street
                number: number
        getComparatorKeys: -> ['alphabetic']
        # parse: (resp, options) ->
        #     super resp.results, options
        url: ->
            "#{BACKEND_BASE}/#{@resourceName}/"

    class RoutingParameters extends Backbone.Model
        initialize: (attributes)->
            @set 'endpoints', attributes?.endpoints.slice(0) or [null, null]
            @set 'origin_index', attributes?.origin_index or 0
            @set 'time_mode', attributes?.time_mode or 'depart'
            @pendingPosition = new CoordinatePosition isDetected: false, preventPopup: true
            @listenTo @, 'change:time_mode', -> @triggerComplete()

        swapEndpoints: (opts)->
            @set 'origin_index', @_getDestinationIndex()
            unless opts?.silent
                @trigger 'change'
                @triggerComplete()
        setOrigin: (object, opts) ->
            index = @get 'origin_index'
            @get('endpoints')[index] = object
            @trigger 'change'
            unless opts?.silent
                @triggerComplete()
        setDestination: (object) ->
            @get('endpoints')[@_getDestinationIndex()] = object
            @trigger 'change'
            @triggerComplete()
        getDestination: ->
            @get('endpoints')[@_getDestinationIndex()]
        getOrigin: ->
            @get('endpoints')[@_getOriginIndex()]
        getEndpointName: (object) ->
            if not object?
                return ''
            else if object.isDetectedLocation()
                if object.isPending()
                    return i18n.t('transit.location_pending')
                else
                    return i18n.t('transit.current_location')
            else if object instanceof CoordinatePosition
                return i18n.t('transit.user_picked_location')
            else if object instanceof Unit
                return object.getText('name')
            else if object instanceof Position
                return object.humanAddress()
        getEndpointLocking: (object) ->
            return object instanceof models.Unit
        isComplete: ->
            for endpoint in @get 'endpoints'
                unless endpoint? then return false
                if endpoint instanceof Position
                    if endpoint.isPending()
                        return false
            true
        ensureUnitDestination: ->
            if @getOrigin() instanceof Unit
                @swapEndpoints
                    silent: true
        triggerComplete: ->
            if @isComplete()
                @trigger 'complete'
        setTime: (time, opts) ->
            datetime = @getDatetime()
            mt = moment(time)
            m = moment(datetime)
            m.hours mt.hours()
            m.minutes mt.minutes()
            datetime = m.toDate()
            @set 'time', datetime, opts
            @triggerComplete()
        setDate: (date, opts) ->
            datetime = @getDatetime()
            md = moment(date)
            datetime.setDate md.date()
            datetime.setMonth md.month()
            datetime.setYear md.year()
            @set 'time', datetime, opts
            @triggerComplete()
        setTimeAndDate: (date) ->
            @setTime(date)
            @setDate(date)
        setDefaultDatetime: ->
            @set 'time', @getDefaultDatetime()
            @triggerComplete()
        clearTime: ->
            @set 'time', null
        getDefaultDatetime: (currentDatetime) ->
            time = moment new Date()
            mode = @get 'time_mode'
            if mode == 'depart'
                return time.toDate()
            time.add 60, 'minutes'
            minutes = time.minutes()
            # Round upwards to nearest 10 min
            time.minutes (minutes - minutes % 10 + 10)
            time.toDate()
        getDatetime: ->
            time = @get('time')
            unless time?
                time = @getDefaultDatetime()
            time

        isTimeSet: ->
            @get('time')?
        setTimeMode: (timeMode) ->
            @set 'time_mode', timeMode
            @triggerComplete()

        _getOriginIndex: ->
            @get 'origin_index'
        _getDestinationIndex: ->
            (@_getOriginIndex() + 1) % 2

    class Language extends Backbone.Model

    class LanguageList extends Backbone.Collection
        model: Language

    class ServiceList extends SMCollection
        model: Service
        initialize: ->
            super
            @chosenService = null
        expand: (id, spinnerOptions = {}) ->
            if not id
                @chosenService = null
                @fetch
                    data:
                        level: 0
                    spinnerOptions: spinnerOptions
                    success: =>
                        @trigger 'finished'
            else
                @chosenService = new Service(id: id)
                @chosenService.fetch
                    success: =>
                        @fetch
                            data:
                                parent: id
                            spinnerOptions: spinnerOptions
                            success: =>
                                @trigger 'finished'

    class SearchList extends SMCollection
        model: (attrs, options) ->
                typeToModel =
                    service: Service
                    unit: Unit
                    address: Position

                type = attrs.object_type
                if type of typeToModel
                    return new typeToModel[type](attrs, options)
                else
                    Raven.captureException(
                        new Error("Unknown search result type '#{type}', #{attrs.object_type}")
                    )
                    return new Backbone.Model(attrs, options)

        search: (query, options) ->
            @currentPage = 1
            @query = query
            opts = _.extend {}, options
            opts.data =
                q: query
                language: p13n.getLanguage()
                only: 'unit.name,service.name,unit.location,unit.root_services'
                include: 'unit.accessibility_properties,service.ancestors,unit.services'
            city = p13n.get('city')
            if city
                opts.data.municipality = city
            @fetch opts
            opts

        url: ->
            return "#{BACKEND_BASE}/search/"

    class LinkedEventsModel extends SMModel
        urlRoot: ->
            return "#{LINKEDEVENTS_BASE}/#{@resourceName}/"

    class LinkedEventsCollection extends SMCollection
        url: ->
            obj = new @model
            return "#{LINKEDEVENTS_BASE}/#{obj.resourceName}/"

        parse: (resp, options) ->
            @fetchState =
                count: resp.meta.count
                next: resp.meta.next
                previous: resp.meta.previous
            RESTFrameworkCollection.__super__.parse.call @, resp.data, options


    class Event extends LinkedEventsModel
        resourceName: 'event'
        translatedAttrs: ['name', 'info_url', 'description', 'short_description',
                           'location_extra_info']
        toJSON: (options) ->
            data = super()
            data.links = _.filter @get('external_links'), (link) ->
                link.language == p13n.getLanguage()
            data

        getUnit: () ->
            unitId = @get('location')['@id'].match(/^.*tprek%3A(\d+)/)
            unless unitId?
                return null
            return new models.Unit id: unitId[1]


    class EventList extends LinkedEventsCollection
        model: Event

    class Open311Model extends SMModel
        sync: (method, model, options) ->
            _.defaults options, emulateJSON: true, data: extensions: true
            super method, model, options
        resourceNamePlural: ->
            "#{@resourceName}s"
        urlRoot: ->
            return "#{OPEN311_BASE}/#{@resourceNamePlural()}"

    class FeedbackItem extends Open311Model
        resourceName: 'request'
        url: ->
            return "#{@urlRoot()}/#{@id}.json"
        parse: (resp, options) ->
            if resp.length == 1
                return super resp[0], options
            super resp, options

    class FeedbackItemType extends Open311Model
        # incoming feedback

    class FeedbackList extends FilterableCollection
        fetch: (options) ->
            options = options or {}
            _.defaults options,
                emulateJSON: true,
                data: extensions: true
            super options
        model: FeedbackItem
        url: ->
            obj = new @model
            return "#{OPEN311_BASE}/#{obj.resourceNamePlural()}.json"

    class FeedbackMessage extends SMModel
        # outgoing feedback
        # TODO: combine the two?
        initialize: ->
            @set 'can_be_published', true
            @set 'service_request_type', 'OTHER'
            @set 'description', ''

        _serviceCodeFromPersonalisation: (type) ->
            switch type
                when 'hearing_aid' then 128
                when 'visually_impaired' then 126
                when 'wheelchair' then 121
                when 'reduced_mobility' then 123
                when 'rollator' then 124
                when 'stroller' then 125
                else 11
        validate: (attrs, options) ->
            if attrs.description == ''
                description: 'description_required'
            else if attrs.description.trim().length < 10
                @set 'description', attrs.description
                description: 'description_length'
        serialize: ->
            json = _.pick @toJSON(), 'title', 'first_name', 'description',
                'email', 'service_request_type', 'can_be_published'
            viewpoints = @get 'accessibility_viewpoints'
            if viewpoints?.length
                service_code = @_serviceCodeFromPersonalisation viewpoints[0]
            else
                if @get 'accessibility_enabled'
                    service_code = 11
                else
                    service_code = 1363
            json.service_code = service_code
            json.service_object_id = @get('unit').get 'id'
            json.service_object_type = 'http://www.hel.fi/servicemap/v2'
            json
        sync: (method, model, options) ->
            json = @serialize()
            unless @validationError
                if method == 'create'
                    $.post @urlRoot(), @serialize(), => @trigger 'sent'
        urlRoot: -> OPEN311_WRITE_BASE

    exports =
        Unit: Unit
        Service: Service
        UnitList: UnitList
        Department: Department
        DepartmentList: DepartmentList
        Organization: Organization
        OrganizationList: OrganizationList
        ServiceList: ServiceList
        AdministrativeDivision: AdministrativeDivision
        AdministrativeDivisionList: AdministrativeDivisionList
        AdministrativeDivisionType: AdministrativeDivisionType
        AdministrativeDivisionTypeList: AdministrativeDivisionTypeList
        SearchList: SearchList
        Language: Language
        LanguageList: LanguageList
        Event: Event
        WrappedModel: WrappedModel
        EventList: EventList
        RoutingParameters: RoutingParameters
        Position: Position
        CoordinatePosition: CoordinatePosition
        AddressPosition: AddressPosition
        PositionList: PositionList
        AddressList: AddressList
        FeedbackItem: FeedbackItem
        FeedbackList: FeedbackList
        FeedbackMessage: FeedbackMessage
        Street: Street
        StreetList: StreetList

    # Expose models to browser console to aid in debugging
    window.models = exports

    return exports

# Personalization support code

SUPPORTED_LANGUAGES = ['fi', 'en', 'sv']

makeMomentLang = (lang) ->
    if lang == 'en'
        return 'en-gb'
    return lang

momentDeps = ("moment/#{makeMomentLang(lang)}" for lang in SUPPORTED_LANGUAGES)

p13nDeps = [
    'module',
    'app/models',
    'underscore',
    'backbone',
    'i18next',
    'moment'].concat momentDeps

define p13nDeps, (
    module,
    models,
    _,
    Backbone,
    i18n,
    moment
) ->

    LOCALSTORAGE_KEY = 'servicemap_p13n'
    CURRENT_VERSION = 1
    LANGUAGE_NAMES =
        fi: 'suomi'
        sv: 'svenska'
        en: 'English'
    FALLBACK_LANGUAGES = ['en', 'fi']

    ACCESSIBILITY_GROUPS = {
        senses: ['hearing_aid', 'visually_impaired', 'colour_blind'],
        mobility: ['wheelchair', 'reduced_mobility', 'rollator', 'stroller'],
    }

    ALLOWED_VALUES =
        accessibility:
            mobility: [null, 'wheelchair', 'reduced_mobility', 'rollator', 'stroller']
        transport: ['by_foot', 'bicycle', 'public_transport', 'car']
        transport_detailed_choices:
            public: ['bus', 'tram', 'metro', 'train', 'ferry']
            bicycle: ['bicycle_parked', 'bicycle_with']
        language: SUPPORTED_LANGUAGES
        map_background_layer: ['servicemap', 'ortographic', 'guidemap', 'accessible_map']
        city: [null, 'helsinki', 'espoo', 'vantaa', 'kauniainen']

    PROFILE_IDS =
        'wheelchair': 1
        'reduced_mobility': 2
        'rollator': 3
        'stroller': 4
        'visually_impaired': 5
        'hearing_aid': 6

    # When adding a new personalization attribute, you must fill in a
    # sensible default.
    DEFAULTS =
        language: appSettings.default_language
        first_visit: true
        skip_tour: false
        hide_tour: false
        location_requested: false
        map_background_layer: 'servicemap'
        accessibility:
            hearing_aid: false
            visually_impaired: false
            colour_blind: false
            mobility: null
        city: null
        transport:
            by_foot: false
            bicycle: false
            public_transport: true
            car: false
        transport_detailed_choices:
            public:
                bus: true
                tram: true
                metro: true
                train: true
                ferry: true
            bicycle:
                bicycle_parked: true
                bicycle_with: false

    deepExtend = (target, source, allowedValues) ->
        for prop of target
            if prop not of source
                continue
            sourceIsObject = !!source[prop] and typeof source[prop] == 'object'
            targetIsObject = !!target[prop] and typeof target[prop] == 'object'
            if targetIsObject != sourceIsObject
                console.error "Value mismatch for #{prop}: #{typeof source[prop]} vs. #{typeof target[prop]}"
                continue

            if targetIsObject
                deepExtend target[prop], source[prop], allowedValues[prop] or {}
                continue
            if prop of allowedValues
                if target[prop] not in allowedValues[prop]
                    console.error "Invalid value for #{prop}: #{target[prop]}"
                    continue
            target[prop] = source[prop]

    class ServiceMapPersonalization
        constructor: ->
            _.extend @, Backbone.Events

            @attributes = _.clone DEFAULTS
            # FIXME: Autodetect language? Browser capabilities?
            if module.config().localStorageEnabled == false
                @localStorageEnabled = false
            else
                @localStorageEnabled = @testLocalStorageEnabled()
            @_fetch()

            @deferred = i18n.init
                lng: @getLanguage()
                resGetPath: appSettings.static_path + 'locales/__lng__.json'
                fallbackLng: FALLBACK_LANGUAGES

            #TODO: This should be moved to a more appropriate place (and made nicer)
            i18n.addPostProcessor "fixFinnishStreetNames", (value, key, options) ->
                REPLACEMENTS = "_allatiivi_": [
                    [/katu$/, "kadulle"],
                    [/polku$/, "polulle"],
                    [/ranta$/, "rannalle"],
                    [/ramppia$/, "rampille"],
                    [/$/, "lle"]
                ],
                "_partitiivi_": [
                    [/tie$/, "tietä"],
                    [/Kehä I/, "Kehä I:tä"]
                    [/Kehä III/, "Kehä III:a"]
                    [/ä$/, "ää"],
                    [/$/, "a"]
                ]
                for grammaticalCase, rules of REPLACEMENTS
                    if value.indexOf(grammaticalCase) > -1
                        for replacement in rules
                            if options.street.match(replacement[0])
                                options.street = options.street.replace(replacement[0], replacement[1]);
                                return value.replace(grammaticalCase, options.street)

            moment.locale makeMomentLang(@getLanguage())
            # debugging: make i18n available from JS console
            window.i18nDebug = i18n

        testLocalStorageEnabled: () =>
            val = '_test'
            try
                localStorage.setItem val, val
                localStorage.removeItem val
                return true
            catch e
                return false

        _handleLocation: (pos, positionObject) =>
            if pos.coords.accuracy > 10000
                @trigger 'position_error'
                return
            unless positionObject?
                positionObject = new models.CoordinatePosition isDetected: true
            cb = =>
                coords = pos['coords']
                positionObject.set 'location',
                    coordinates: [coords.longitude, coords.latitude]
                positionObject.set 'accuracy', pos.coords.accuracy
                @lastPosition = positionObject
                @trigger 'position', positionObject
                if not @get 'location_requested'
                    @set 'location_requested', true
            if appSettings.user_location_delayed
                setTimeout cb, 3000
            else
                cb()

        _handleLocationError: (error) =>
            @trigger 'position_error'
            @set 'location_requested', false

        setVisited: ->
            @_setValue ['first_visit'], false

        getLastPosition: ->
            return @lastPosition

        getLocationRequested: ->
            return @get 'location_requested'

        _setValue: (path, val) ->
            pathStr = path.join '.'
            vars = @attributes
            allowed = ALLOWED_VALUES
            dirs = path.slice 0
            propName = dirs.pop()
            for name in dirs
                if name not of vars
                    throw new Error "Attempting to set invalid variable name: #{pathStr}"
                vars = vars[name]
                if not allowed
                    continue
                if name not of allowed
                    allowed = null
                    continue
                allowed = allowed[name]

            if allowed and propName of allowed
                if val not in allowed[propName]
                    throw new Error "Invalid value for #{pathStr}: #{val}"
            else if typeof val != 'boolean'
                throw new Error "Invalid value for #{pathStr}: #{val} (should be boolean)"

            oldVal = vars[propName]
            if oldVal == val
                return
            vars[propName] = val

            # save changes
            @_save()
            # notify listeners
            @trigger 'change', path, val
            if path[0] == 'accessibility'
                @trigger 'accessibility-change'
            val

        toggleMobility: (val) ->
            oldVal = @getAccessibilityMode 'mobility'
            if val == oldVal
                @_setValue ['accessibility', 'mobility'], null
            else
                @_setValue ['accessibility', 'mobility'], val
        toggleAccessibilityMode: (modeName) ->
            oldVal = @getAccessibilityMode modeName
            @_setValue ['accessibility', modeName], !oldVal
        setAccessibilityMode: (modeName, val) ->
            @_setValue ['accessibility', modeName], val
        getAccessibilityMode: (modeName) ->
            accVars = @get 'accessibility'
            if not modeName of accVars
                throw new Error "Attempting to get invalid accessibility mode: #{modeName}"
            return accVars[modeName]
        toggleCity: (val) ->
            oldVal = @get 'city'
            if val == oldVal
                val = null
            @_setValue ['city'], val

        getAllAccessibilityProfileIds: ->
            rawIds = _.invert PROFILE_IDS
            ids = {}
            for rid, name of rawIds
                suffixes = switch
                    when _.contains(["1", "2", "3"], rid) then ['A', 'B', 'C']
                    when _.contains(["4", "6"], rid) then ['A']
                    when "5" == rid then ['A', 'B']
                for s in suffixes
                    ids[rid + s] = name
            ids

        getAccessibilityProfileIds: (filterTransit) ->
            # filterTransit: if true, only return profiles which
            # affect transit routing.
            ids = {}
            accVars = @get 'accessibility'
            transport = @get 'transport'
            mobility = accVars['mobility']
            key = PROFILE_IDS[mobility]
            if key
                if key in [1, 2, 3, 5]
                    key += if transport.car then 'B' else 'A'
                else
                    key += 'A'
                ids[key] = mobility
            disabilities = ['visually_impaired']
            unless filterTransit
                disabilities.push 'hearing_aid'
            for disability in disabilities
                val = @getAccessibilityMode disability
                if val
                    key = PROFILE_IDS[disability]
                    if disability == 'visually_impaired'
                        key += if transport.car then 'B' else 'A'
                    else
                        key += 'A'
                    ids[key] = disability
            ids

        hasAccessibilityIssues: ->
            ids = @getAccessibilityProfileIds()
            _.size(ids) > 0

        setTransport: (modeName, val) ->
            modes = @get 'transport'
            if val
                if modeName == 'by_foot'
                    for m of modes
                        modes[m] = false
                else if modeName in ['car', 'bicycle']
                    for m of modes
                        if m == 'public_transport'
                            continue
                        modes[m] = false
                else if modeName == 'public_transport'
                    modes.by_foot = false
            else
                otherActive = false
                for m of modes
                    if m == modeName
                        continue
                    if modes[m]
                        otherActive = true
                        break
                if not otherActive
                    return

            @_setValue ['transport', modeName], val

        getTransport: (modeName) ->
            modes = @get 'transport'
            if not modeName of modes
                throw new Error "Attempting to get invalid transport mode: #{modeName}"
            return modes[modeName]

        toggleTransport: (modeName) ->
            oldVal = @getTransport modeName
            @setTransport modeName, !oldVal

        toggleTransportDetails: (group, modeName) ->
            oldVal = @get('transport_detailed_choices')[group][modeName]
            if !oldVal
                if modeName == 'bicycle_parked'
                    @get('transport_detailed_choices')[group].bicycle_with = false
                if modeName == 'bicycle_with'
                    @get('transport_detailed_choices')[group].bicycle_parked = false
            @_setValue ['transport_detailed_choices', group, modeName], !oldVal

        requestLocation: (positionModel) ->
            if appSettings.user_location_override
                override = appSettings.user_location_override
                coords =
                    latitude: override[0]
                    longitude: override[1]
                    accuracy: 10
                @_handleLocation coords: coords
                return

            if 'geolocation' not of navigator
                return
            posOpts =
                enableHighAccuracy: false
                timeout: 30000
            navigator.geolocation.getCurrentPosition ((pos) => @_handleLocation(pos, positionModel)),
                @_handleLocationError, posOpts

        set: (attr, val) ->
            if not attr of @attributes
                throw new Error "attempting to set invalid attribute: #{attr}"
            @attributes[attr] = val
            @trigger 'change', attr, val
            @_save()

        get: (attr) ->
            if not attr of @attributes
                return undefined
            return @attributes[attr]

        _verifyValidState: ->
            transportModesCount = _.filter(@get('transport'), _.identity).length
            if transportModesCount == 0
                @setTransport 'public_transport', true

        _fetch: ->
            if not @localStorageEnabled
                return

            str = localStorage.getItem LOCALSTORAGE_KEY
            if not str
                return

            storedAttrs = JSON.parse str
            deepExtend @attributes, storedAttrs, ALLOWED_VALUES
            @_verifyValidState()

        _save: ->
            if not @localStorageEnabled
                return

            data = _.extend @attributes, version: CURRENT_VERSION
            str = JSON.stringify data
            localStorage.setItem LOCALSTORAGE_KEY, str

        getProfileElement: (name) ->
            icon: "icon-icon-#{name.replace '_', '-'}"
            text: i18n.t("personalisation.#{name}")

        getProfileElements: (profiles) ->
            _.map(profiles, @getProfileElement)

        getLanguage: ->
            return appSettings.default_language

        getTranslatedAttr: (attr) ->
            if not attr
                return attr

            if not attr instanceof Object
                console.error "translated attribute didn't get a translation object", attr
                return attr

            # Try primary choice first, fallback to whatever's available.
            languages = [@getLanguage()].concat SUPPORTED_LANGUAGES
            for lang in languages
                if lang of attr
                    return attr[lang]

            console.error "no supported languages found", attr
            return null

        getSupportedLanguages: ->
            _.map SUPPORTED_LANGUAGES, (l) ->
                code: l
                name: LANGUAGE_NAMES[l]

        getHumanizedDate: (time) ->
            m = moment time
            now = moment()
            sod = now.startOf 'day'
            diff = m.diff sod, 'days', true
            if diff < -6 or diff >= 7
                humanize = false
            else
                humanize = true
            if humanize
                s = m.calendar()
                s = s.replace /( (klo|at))* \d{1,2}[:.]\d{1,2}$/, ''
            else
                if now.year() != m.year()
                    format = 'L'
                else
                    format = switch @getLanguage()
                        when 'fi' then 'Do MMMM[ta]'
                        when 'en' then 'D MMMM'
                        when 'sv' then 'D MMMM'
                s = m.format format
            return s

        setMapBackgroundLayer: (layerName) ->
            @_setValue ['map_background_layer'], layerName

        getMapBackgroundLayers: ->
            a =_(ALLOWED_VALUES.map_background_layer)
                .chain()
                .union ['accessible_map']
                .map (layerName) =>
                    name: layerName,
                    selected: @get('map_background_layer') == layerName
                .value()

    # Make it a globally accessible variable for convenience
    window.p13n = new ServiceMapPersonalization
    return window.p13n

define ['backbone.marionette', 'URI'], (Marionette, URI) ->

    class BaseRouter extends Backbone.Marionette.AppRouter
        initialize: (options) ->
            super options
            @controller = options.controller
            @makeMapView = options.makeMapView
            @appRoute /^\/?([^\/]*)$/, 'renderHome'
            @appRoute /^unit\/?([^\/]*)$/, 'renderUnit'
            @appRoute /^division\/?(.*?)$/, 'renderDivision'
            @appRoute /^address\/(.*?)$/, 'renderAddress'
            @appRoute /^search(\?[^\/]*)$/, 'renderSearch'
            @appRoute /^division(\?.*?)$/, 'renderMultipleDivisions'

        onPostRouteExecute: ->

        executeRoute: (callback, args, context) ->
            callback?.apply(@, args)?.done (opts) =>
                mapOpts = {}
                if context.query?
                    mapOpts.bbox = context.query.bbox
                    mapOpts.level = context.query.level
                @makeMapView mapOpts
                opts?.afterMapInit?()
                @onPostRouteExecute()

        processQuery: (q) ->
            if q.bbox? and q.bbox.match /([0-9]+\.?[0-9+],)+[0-9]+\.?[0-9+]/
                q.bbox = q.bbox.split ','
            if q.ocd_id? and q.ocd_id.match /([^,]+,)*[^,]+/
                q.ocdId = q.ocd_id.split ','
                delete q.ocd_id
            return q

        execute: (callback, args) ->
            # The map view must only be initialized once
            # the state encoded in the route URL has been
            # reconstructed. The state affects the map
            # centering, zoom, etc.o
            context = {}
            lastArg = args[args.length - 1]
            fullUri = new URI window.location.toString()
            unless args.length < 1 or lastArg == null
                newArgs = URI(lastArg).segment()
            else
                newArgs = []
            if fullUri.query()
                context.query = @processQuery fullUri.search(true)
                if context.query.map?
                    p13n.setMapBackgroundLayer context.query.map
                if context.query.city?
                    p13n.set 'city', context.query.city
                newArgs.push context
            @executeRoute callback, newArgs, context

        routeEmbedded: (uri) ->
            # An alternative implementation of 'static' routing
            # for browsers without pushState when creating
            # an embedded view.
            path = uri.segment()
            resource = path[0]
            callback = if resource == 'division'
                if 'ocd_id' of uri.search(true)
                    'renderMultipleDivisions'
                else
                    'renderDivision'
            else
                switch resource
                    when '' then 'renderHome'
                    when 'unit' then 'renderUnit'
                    when 'search' then 'renderSearch'
                    when 'address' then 'renderAddress'
            uri.segment 0, '' # remove resource from path
            relativeUri = new URI uri.pathname() + uri.search()
            callback = _.bind @controller[callback], @controller
            @execute callback, [relativeUri.toString()]

define [
    'backbone',
    'typeahead.bundle',
    'app/p13n',
    'app/settings'
],
(
    Backbone,
    ta,
    p13n,
    settings
) ->

    lang = p13n.getLanguage()
    servicemapEngine = new Bloodhound
        name: 'suggestions'
        remote:
            url: appSettings.service_map_backend + "/search/?language=#{lang}&page_size=4&input="
            replace: (url, query) =>
                url += query
                city = p13n.get('city')
                if city
                    url += "&municipality=#{city}"
                url
            ajax: settings.applyAjaxDefaults {}
            filter: (parsedResponse) ->
                parsedResponse.results
            rateLimitWait: 50
        datumTokenizer: (datum) -> Bloodhound.tokenizers.whitespace datum.name[lang]
        queryTokenizer: Bloodhound.tokenizers.whitespace
    linkedeventsEngine = new Bloodhound
        name: 'events_suggestions'
        remote:
            url: appSettings.linkedevents_backend + "/search/?language=#{lang}&page_size=4&input=%QUERY"
            ajax: settings.applyAjaxDefaults {}
            filter: (parsedResponse) ->
                parsedResponse.data
            rateLimitWait: 50
        datumTokenizer: (datum) -> Bloodhound.tokenizers.whitespace datum.name[lang]
        queryTokenizer: Bloodhound.tokenizers.whitespace

    servicemapEngine.initialize()
    linkedeventsEngine.initialize()

    linkedeventsEngine: linkedeventsEngine
    servicemapEngine: servicemapEngine

define ->

    ieVersion = getIeVersion()

    applyAjaxDefaults = (settings) ->
        settings.cache = true
        if not ieVersion
            return settings
        if ieVersion >= 10
            return settings

        # JSONP for older IEs
        settings.dataType = 'jsonp'
        settings.data = settings.data || {}
        settings.data.format = 'jsonp'
        return settings

    return {
        applyAjaxDefaults: applyAjaxDefaults
    }

define [
    'underscore',
    'spin'
], (
    _,
    Spinner
) ->

    class SMSpinner

        DEFAULTS =
            lines: 12,                      # The number of lines to draw
            length: 7,                      # The length of each line
            width: 5,                       # The line thickness
            radius: 10,                     # The radius of the inner circle
            rotate: 0,                      # Rotation offset
            corners: 1,                     # Roundness (0..1)
            color: '#000',                  # #rgb or #rrggbb
            direction: 1,                   # 1: clockwise, -1: counterclockwise
            speed: 1,                       # Rounds per second
            trail: 100,                     # Afterglow percentage
            opacity: 1/4,                   # Opacity of the lines
            fps: 20,                        # Frames per second when using setTimeout()
            zIndex: 2e9,                    # Use a high z-index by default
            className: 'spinner',           # CSS class to assign to the element
            top: '50%',                     # center vertically
            left: '50%',                    # center horizontally
            position: 'absolute'            # element position
            hideContainerContent: false   # if true, hides all child elements inside spinner container

        constructor: (options) ->
            @options = _.extend(DEFAULTS, options)
            @container = @options.container
            @finished = false

        start: ->
            if @finished then return
            if @container
                if @options.hideContainerContent
                    $(@container).children().css('visibility', 'hidden')

                @spinner = new Spinner(@options).spin(@container)

        stop: ->
            @finished = true
            if @container and @spinner
                @spinner.stop()
                if @options.hideContainerContent
                    $(@container).children().css('visibility', 'visible')

    return SMSpinner

define [
    'bootstrap-tour',
    'i18next',
    'app/jade',
    'app/models',
], (
    _bst, # imports Tour
    {t: t},
    jade,
    models
) ->

    # TODO: vary by municipality
    unit = new models.Unit id:8215
    STEPS = [
        {
            orphan: true
        },
        {
            element: '#navigation-header'
            placement: 'bottom'
            backdrop: true
        },
        {
            element: '#search-region'
            placement: 'right'
            backdrop: true
            onShow: (tour) ->
                $container = $('#search-region')
                $input = $container.find('input')
                $input.typeahead('val', '')
                # TODO: translate example query
                $input.typeahead('val', 'terve')
                $input.val 'terve'
                $input.click()
            onHide: ->
                $container = $('#search-region')
                $input = $container.find('input')
                $input.typeahead('val', '')
        },
        {
            element: '#browse-region'
            placement: 'right'
            backdrop: true
            onShow: (tour) ->
                $container = $('#browse-region')
                _.defer =>
                    $container.click()
        },
        {
            element: '.service-hover-color-50003'
            placement: 'right'
            backdrop: true
        },
        {
            element: '.leaflet-marker-icon'
            placement: 'bottom'
            backdrop: false
            onShow: (tour) ->
                unit.fetch
                    data: include: 'root_services,department,municipality,services'
                    success: -> app.commands.execute 'selectUnit', unit
        },
        {
            element: '.route-section'
            placement: 'right'
            backdrop: true
            onNext: ->
                app.commands.execute 'clearSelectedUnit'
        },
        {
            element: '#personalisation'
            placement: 'left'
            backdrop: true
        },
        {
            element: '#personalisation'
            placement: 'left'
            backdrop: true,
            onShow: ->
                $('#personalisation .personalisation-button').click()
            onHide: ->
                $('#personalisation .ok-button').click()
        },
        {
            element: '#service-cart'
            placement: 'left'
            backdrop: true
        },
        {
            element: '#language-selector'
            placement: 'left'
            backdrop: true
        },
        {
            element: '#persistent-logo .feedback-prompt'
            placement: 'left'
            backdrop: true
        },
        {
            onShow: (tour) ->
                app.commands.execute 'home'
                # TODO: default zoom
                p13n.set 'skip_tour', true
                $('#app-container').one 'click', =>
                    tour.end()
            onShown: (tour) ->
                $container = $ tour.getStep(tour.getCurrentStep()).container
                $step = $($container).children()
                $step.attr('tabindex', -1).focus()
                $('.tour-success', $container).on 'click', (ev) =>
                    tour.end()
                $container.find('a.service').on 'click', (ev) =>
                    tour.end()
                    app.commands.execute 'addService',
                        new models.Service(id: $(ev.currentTarget).data('service'))
            orphan: true
        },
    ]
    NUM_STEPS = STEPS.length
    getExamples = =>
        [
            {
                key: 'health'
                name: t('tour.examples.health')
                service: 25002
            },
            {
                key: 'beach'
                name: t('tour.examples.beach')
                service: 33467
            },
            {
                key: 'art'
                name: t('tour.examples.art')
                service: 25658
            },
            {
                key: 'glass_recycling'
                name: t('tour.examples.glass_recycling')
                service: 29475
            },
        ]

    startTour: ->
        selected = p13n.getLanguage()
        languages = _.chain p13n.getSupportedLanguages()
            .map (l) => l.code
            .filter (l) => l != selected
            .value()
        tour = new Tour
            template: (i, step) ->
                step.length = NUM_STEPS - 2
                step.languages = languages
                step.first = step.next == 1
                step.last = step.next == -1
                if step.last
                    step.examples = getExamples()
                jade.template 'tour', step
            storage : false
            container: '#tour-region'
            onShown: (tour) ->
                $step = $('#' + @id)
                $step.attr('tabindex', -1).focus()
            onEnd: (tour) ->
                p13n.set 'skip_tour', true
                p13n.trigger 'tour-skipped'
        for step, i in STEPS
            step.title = t("tour.steps.#{i}.title")
            step.content = t("tour.steps.#{i}.content")
            tour.addStep step
        tour.start true

define ->

    # Original structure from:
    # https://github.com/reitti/reittiopas/blob/90a4d5f20bed3868b5fb608ee1a1c7ce77b70ed8/web/js/utils.coffee
    hslColors =
        #walk: '#9ab9c9' # walking; HSL official color is too light #bee4f8
        walk: '#7a7a7a' # changed from standard for legibility
        wait: '#999999' # waiting time at a stop
        1:    '#007ac9' # Helsinki internal bus lines
        2:    '#00985f' # Trams
        3:    '#007ac9' # Espoo internal bus lines
        4:    '#007ac9' # Vantaa internal bus lines
        5:    '#007ac9' # Regional bus lines
        6:    '#ff6319' # Metro
        7:    '#00b9e4' # Ferry
        8:    '#007ac9' # U-lines
        12:   '#64be14' # Commuter trains
        21:   '#007ac9' # Helsinki service lines
        22:   '#007ac9' # Helsinki night buses
        23:   '#007ac9' # Espoo service lines
        24:   '#007ac9' # Vantaa service lines
        25:   '#007ac9' # Region night buses
        36:   '#007ac9' # Kirkkonummi internal bus lines
        38:   '#007ac9' # Undocumented, assumed bus
        39:   '#007ac9' # Kerava internal bus lines

    googleColors =
        WALK: hslColors.walk
        CAR: hslColors.walk
        BICYCLE: hslColors.walk
        WAIT: hslColors.wait
        0: hslColors[2]
        1: hslColors[6]
        2: hslColors[12]
        3: hslColors[5]
        4: hslColors[7]
        109: hslColors[12]

    class TransitMapMixin
        initializeTransitMap: (opts) ->
            @listenTo opts.route, 'change:plan', (route) =>
                if route.has 'plan'
                    @drawItinerary route
                else
                    @clearItinerary()
            if opts.selectedUnits?
                @listenTo opts.selectedUnits, 'reset', @clearItinerary
            if opts.selectedPosition?
                @listenTo opts.selectedPosition, 'change:value', @clearItinerary

        # Renders each leg of the route to the map
        createRouteLayerFromItinerary: (itinerary) ->
            routeLayer = L.featureGroup()
            alertLayer = L.featureGroup()
            legs = itinerary.legs

            sum = (xs) -> _.reduce(xs, ((x, y) -> x+y), 0)
            totalWalkingDistance = sum(leg.distance for leg in legs when leg.distance and not leg.routeType?)
            totalWalkingDuration = sum(leg.duration for leg in legs when leg.distance and not leg.routeType?)

            routeIncludesTransit = _.any(leg.routeType? for leg in legs)

            mins = Math.ceil(itinerary.duration/1000/60)
            walkMins = Math.ceil(totalWalkingDuration/1000/60)
            walkKms = Math.ceil(totalWalkingDistance/100)/10

            for leg in legs
                points = (new L.LatLng(point[0], point[1]) for point in leg.legGeometry.points)
                color = googleColors[leg.routeType ? leg.mode]
                style =
                    color: color
                    stroke: true
                    fill: false
                    opacity: 0.8

                polyline = new L.Polyline points, style

                # Make zooming to the leg via click possible.
                polyline.on 'click', (e) ->
                    @._map.fitBounds(polyline.getBounds())
                    if marker?
                        marker.openPopup()
                polyline.addTo routeLayer

                if leg.alerts
                    style =
                        color: '#ff3333'
                        opacity: 0.2
                        fillOpacity: 0.4
                        weight: 5
                        clickable: true
                    for alert in leg.alerts
                        if alert.geometry
                            alertpoly = new L.geoJson alert.geometry, style: style
                            if alert.alertDescriptionText
                                alertpoly.bindPopup alert.alertDescriptionText.someTranslation, closeButton: false
                            alertpoly.addTo alertLayer

                # Always show route and time information at the leg start position
                if false
                    stop = leg.from
                    lastStop = leg.to
                    point = y: stop.lat, x: stop.lon
                    icon = L.divIcon className: "navigator-div-icon"
                    label = "<span style='font-size: 24px;'><img src='static/images/#{google_icons[leg.routeType ? leg.mode]}' style='vertical-align: sub; height: 24px'/><span>#{leg.route}</span></span>"

                    marker = L.marker(new L.LatLng(point.y, point.x), {icon: icon}).addTo(routeLayer)
                        .bindPopup "<b>Time: #{moment(leg.startTime).format("HH:mm")}&mdash;#{moment(leg.endTime).format("HH:mm")}</b><br /><b>From:</b> #{stop.name or ""}<br /><b>To:</b> #{lastStop.name or ""}"

            route: routeLayer, alerts: alertLayer

        drawItinerary: (route) ->
            if @routeLayer?
                @clearItinerary()
            {route: @routeLayer, alerts: @alertLayer} =
                @createRouteLayerFromItinerary route.getSelectedItinerary()
            @skipMoveend = true
            @map.refitAndAddLayer @routeLayer
            @map.addLayer @alertLayer
            #_.defer => window.mapView.fitItinerary(@routeLayer)

        clearItinerary: ->
            if @routeLayer
                @map.removeLayer @routeLayer
                @map.adapt()
            if @alertLayer
                @map.removeLayer @alertLayer
            @routeLayer = null
            @alertLayer = null

define [
    'backbone',
    'leaflet'
], (
    Backbone,
    L
) ->
    # General functions taken from https://github.com/HSLdevcom/navigator-proto

    modeMap =
        tram: 'TRAM'
        bus: 'BUS'
        metro: 'SUBWAY'
        ferry: 'FERRY'
        train: 'RAIL'

    # Route received from OTP is encoded so it needs to be decoded.
    # translated from https://github.com/ahocevar/openlayers/blob/master/lib/OpenLayers/Format/EncodedPolyline.js
    decodePolyline = (encoded, dims) ->
        # Start from origo
        point = (0 for i in [0...dims])

        # Loop over the encoded input string
        i = 0
        points = while i < encoded.length
            for dim in [0...dims]
                result = 0
                shift = 0
                loop
                    b = encoded.charCodeAt(i++) - 63
                    result |= (b & 0x1f) << shift
                    shift += 5
                    break unless b >= 0x20

                point[dim] += if result & 1 then ~(result >> 1) else result >> 1

            # Keep a copy in the result list
            point.slice(0)

        return points

    # (taken from https://github.com/HSLdevcom/navigator-proto)
    # clean up oddities in routing result data from OTP
    otpCleanup = (data) ->
        for itinerary in data.plan?.itineraries or []
            legs = itinerary.legs
            length = legs.length
            last = length-1

            # if there's time past walking in either end, add that to walking
            # XXX what if it's not walking?
            if not legs[0].routeType and legs[0].startTime != itinerary.startTime
                legs[0].startTime = itinerary.startTime
                legs[0].duration = legs[0].endTime - legs[0].startTime
            if not legs[last].routeType and legs[last].endTime != itinerary.endTime
                legs[last].endTime = itinerary.endTime
                legs[last].duration = legs[last].endTime - legs[last].startTime

            newLegs = []
            time = itinerary.startTime # tracks when next leg should start
            for leg in itinerary.legs
                # Route received from OTP is encoded so it needs to be decoded.
                points = decodePolyline leg.legGeometry.points, 2
                points = ((x * 1e-5 for x in coords) for coords in points)
                leg.legGeometry.points = points

                # if there's unaccounted time before a walking leg
                if leg.startTime - time > 1000 and leg.routeType == null
                    # move non-transport legs to occur before wait time
                    waitTime = leg.startTime-time
                    time = leg.endTime
                    leg.startTime -= waitTime
                    leg.endTime -= waitTime
                    newLegs.push leg
                    # add the waiting time as a separate leg
                    newLegs.push createWaitLeg leg.endTime, waitTime,
                        _.last(leg.legGeometry.points), leg.to.name
                # else if there's unaccounted time before a leg
                else if leg.startTime - time > 1000
                    waitTime = leg.startTime-time
                    time = leg.endTime
                    # add the waiting time as a separate leg
                    newLegs.push createWaitLeg leg.startTime - waitTime,
                        waitTime, leg.legGeometry.points[0], leg.from.name
                    newLegs.push leg
                else
                    newLegs.push leg
                    time = leg.endTime # next leg should start when this ended
            itinerary.legs = newLegs
        return data

    createWaitLeg = (startTime, duration, point, placename) ->
        leg =
            mode: "WAIT"
            routeType: null # non-transport
            route: ""
            duration: duration
            startTime: startTime
            endTime: startTime + duration
            legGeometry: {points: [point]}
            from:
                lat: point[0]
                lon: point[1]
                name: placename
        leg.to = leg.from
        return leg

    class Route extends Backbone.Model
        initialize: ->
            @set 'selected_itinerary', 0
            @set 'plan', null
            @listenTo @, 'change:selected_itinerary', =>
                @trigger 'change:plan', @

        abort: ->
            if not @xhr
                return
            @xhr.abort()
            @xhr = null

        requestPlan: (from, to, opts) ->
            opts = opts or {}

            if @xhr
                @xhr.abort()
                @xhr = null

            modes = ['WALK']
            if opts.bicycle
                modes = ['BICYCLE']
            if opts.car
                if opts.transit
                    modes = ['CAR_PARK', 'WALK']
                else
                    modes = ['CAR']
            if opts.transit
                modes.push 'TRANSIT'
            else
                modes = _.union modes,
                    _(opts.modes).map (m) => modeMap[m]

            data =
                fromPlace: from
                toPlace: to
                mode: modes.join ','
                numItineraries: 3
                showIntermediateStops: 'true'
                locale: p13n.getLanguage()

            if opts.wheelchair
                data.wheelchair = true

            if opts.walkReluctance
                data.walkReluctance = opts.walkReluctance

            if opts.walkBoardCost
                data.walkBoardCost = opts.walkBoardCost

            if opts.walkSpeed
                data.walkSpeed = opts.walkSpeed

            if opts.minTransferTime
                data.minTransferTime = opts.minTransferTime

            if opts.date and opts.time
                data.date = opts.date
                data.time = opts.time

            if opts.arriveBy
                data.arriveBy = true

            args =
                dataType: 'json'
                url: appSettings.otp_backend
                data: data
                success: (data) =>
                    @xhr = null
                    if 'error' of data
                        @trigger 'error'
                        return

                    data = otpCleanup data
                    @set 'selected_itinerary', 0
                    @set 'plan', data.plan
                error: =>
                    @clear()
                    @trigger 'error'

            @xhr = $.ajax args

        getSelectedItinerary: ->
            @get('plan').itineraries[@get 'selected_itinerary']

        clear: ->
            @set 'plan', null

    exports =
        Route: Route

define ->
    # Include the UserVoice JavaScript SDK (only needed once on a page)
    init = (locale) ->
        if locale == 'sv'
            locale = 'sv-SE'
        UserVoice = window.UserVoice or []
        window.UserVoice = UserVoice
        (->
          uv = document.createElement("script")
          uv.type = "text/javascript"
          uv.async = true
          uv.src = "//widget.uservoice.com/f5qbSk7oBie0rWE0W4ig.js"
          s = document.getElementsByTagName("script")[0]
          s.parentNode.insertBefore uv, s
          return
        )()

        # Set colors
        UserVoice.push [
          "set"
          {
            locale: locale
            accent_color: "#1964e6"
            trigger_color: "white"
            post_idea_enabled: false
            smartvote_enabled: false
            screenshot_enabled: false
            trigger_background_color: "rgba(46, 49, 51, 0.6)"
          }
        ]

    # Or, use your own custom trigger:
    #UserVoice.push(['addTrigger', '#id', { mode: 'contact' }]);
    return init: init

define [
    'app/views/base',
], (
    base
) ->

    class AccessibilityPersonalisationView extends base.SMItemView
        className: 'accessibility-personalisation'
        template: 'accessibility-personalisation'
        initialize: (@activeModes) ->
        serializeData: ->
            accessibility_viewpoints: @activeModes

define [
    'underscore',
    'i18next',
    'moment',
    'app/accessibility',
    'app/accessibility-sentences',
    'app/p13n',
    'app/views/base',

], (
    _,
    i18n,
    moment,
    accessibility,
    accessibilitySentences,
    p13n,
    base,
)  ->

    class AccessibilityViewpointView extends base.SMItemView
        template: 'accessibility-viewpoint-summary'

        initialize: (opts) ->
            @filterTransit = opts?.filterTransit or false
            @template = @options.template or @template
        serializeData: ->
            profiles = p13n.getAccessibilityProfileIds @filterTransit
            profile_set: _.keys(profiles).length
            profiles: p13n.getProfileElements profiles


    class AccessibilityDetailsView extends base.SMLayout
        className: 'unit-accessibility-details'
        template: 'unit-accessibility-details'
        regions:
            'viewpointRegion': '.accessibility-viewpoint'
        events:
            'click #accessibility-collapser': 'toggleCollapse'
        toggleCollapse: ->
            @collapsed = !@collapsed
            true # important: bubble the event
        initialize: ->
            @listenTo p13n, 'change', @render
            @listenTo accessibility, 'change', @render
            @collapsed = true
            @accessibilitySentences = {}
            accessibilitySentences.fetch id: @model.id,
                (data) =>
                    @accessibilitySentences = data
                    @render()
        onRender: ->
            if @model.hasAccessibilityData()
                @viewpointRegion.show new AccessibilityViewpointView()

        _calculateSentences: ->
             _.object _.map(
                 @accessibilitySentences.sentences,
                     (sentences, groupId) =>
                         [p13n.getTranslatedAttr(@accessibilitySentences.groups[groupId]),
                          _.map(sentences, (sentence) -> p13n.getTranslatedAttr sentence)])

        serializeData: ->
            hasData = @model.hasAccessibilityData()
            shortcomingsPending = false

            profiles = p13n.getAccessibilityProfileIds()
            if _.keys(profiles).length
                profileSet = true
            else
                profileSet = false
                profiles = p13n.getAllAccessibilityProfileIds()

            if hasData
                {status: status, results: shortcomings} = @model.getTranslatedShortcomings()
                shortcomingsPending = (status == 'pending')
            else
                shortcomings = {}

            shortcomingsCount = 0
            for __, group of shortcomings
                shortcomingsCount += _.values(group).length

            sentenceGroups = []
            details = []
            if 'error' of @accessibilitySentences
                details = null
                sentenceGroups = null
                sentenceError = true
            else
                details = @_calculateSentences()
                sentenceGroups = _.map _.values(@accessibilitySentences.groups), (v) ->
                    p13n.getTranslatedAttr(v)
                sentenceError = false

            collapseClasses = []
            headerClasses = []
            if @collapsed
                headerClasses.push 'collapsed'
            else
                collapseClasses.push 'in'

            shortText = ''
            if _.keys(profiles).length
                if hasData
                    if shortcomingsCount
                        if profileSet
                            headerClasses.push 'has-shortcomings'
                            shortText = i18n.t('accessibility.shortcoming_count', {count: shortcomingsCount})
                    else
                        if shortcomingsPending
                            headerClasses.push 'shortcomings-pending'
                            shortText = i18n.t('accessibility.pending')
                        else if profileSet
                            headerClasses.push 'no-shortcomings'
                            shortText = i18n.t('accessibility.no_shortcomings')
                else
                    groups = @accessibilitySentences.groups
                    unless (groups? and _(groups).keys().length > 0)
                        shortText = i18n.t('accessibility.no_data')

            iconClass = if profileSet
                p13n.getProfileElements(profiles).pop()['icon']
            else
                'icon-icon-wheelchair'

            has_data: hasData
            profile_set: profileSet
            icon_class: iconClass
            shortcomings_pending: shortcomingsPending
            shortcomings_count: shortcomingsCount
            shortcomings: shortcomings
            groups: sentenceGroups
            details: details
            sentence_error: sentenceError
            header_classes: headerClasses.join ' '
            collapse_classes: collapseClasses.join ' '
            short_text: shortText
            feedback: @getDummyFeedback()

        getDummyFeedback: ->
            now = new Date()
            yesterday = new Date(now.setDate(now.getDate() - 1))
            lastMonth = new Date(now.setMonth(now.getMonth() - 1))
            feedback = []
            feedback.push(
                time: moment(yesterday).calendar()
                profile: 'wheelchair user.'
                header: 'The ramp is too steep'
                content: "The ramp is just bad! It's not connected to the entrance stand out clearly. Outside the door there is sufficient room for moving e.g. with a wheelchair. The door opens easily manually."
            )
            feedback.push(
                time: moment(lastMonth).calendar()
                profile: 'rollator user'
                header: 'Not accessible at all and the staff are unhelpful!!!!'
                content: "The ramp is just bad! It's not connected to the entrance stand out clearly. Outside the door there is sufficient room for moving e.g. with a wheelchair. The door opens easily manually."
            )

            feedback

        leaveFeedbackOnAccessibility: (event) ->
            event.preventDefault()
            # TODO: Add here functionality for leaving feedback.


    AccessibilityDetailsView: AccessibilityDetailsView
    AccessibilityViewpointView: AccessibilityViewpointView

define [
    'backbone.marionette',
    'app/jade',
    'app/base'
], (
     Marionette,
     jade,
     mixOf: mixOf
)->


    class SMTemplateMixin
        mixinTemplateHelpers: (data) ->
            jade.mixinHelpers data
            return data
        getTemplate: ->
            return jade.getTemplate @template

    class KeyboardHandlerMixin
        keyboardHandler: (callback, keys) =>
            codes = _(keys).map (key) =>
                switch key
                    when 'enter' then 13
                    when 'space' then 32
            handle = _.bind(callback, @)
            (event) =>
                event.stopPropagation()
                if event.which in codes then handle event

    SMItemView: class SMItemView extends mixOf Marionette.ItemView, SMTemplateMixin, KeyboardHandlerMixin
    SMCollectionView: class SMCollectionView extends mixOf Marionette.CollectionView, SMTemplateMixin, KeyboardHandlerMixin
    SMLayout: class SMLayout extends mixOf Marionette.Layout, SMTemplateMixin, KeyboardHandlerMixin

define [
    'app/views/base',
], (
    base
) ->

    class ToolMenuItem extends base.SMItemView
        className: 'context-menu-item'
        tagName: 'li'
        template: 'context-menu-item'
        initialize: (opts) ->
            super opts
            @$el.on 'click', @model.get('action')

    class ContextMenuCollectionView extends base.SMCollectionView
        className: 'context-menu'
        tagName: 'ul'
        itemView: ToolMenuItem

    class ContextMenuView extends base.SMLayout
        className: 'context-menu-wrapper'
        template: 'context-menu-wrapper'
        initialize: (@opts) ->
        regions:
            contents: '.contents'
        onRender: ->
            @contents.show new ContextMenuCollectionView @opts

    ContextMenuView

define [
    'app/p13n',
    'app/jade',
    'app/views/base',
    'URI'
], (
    p13n,
    jade,
    base,
    URI
)  ->

    class TitleView extends base.SMItemView
        initialize: ({href: @href}) ->
        className:
            'title-control'
        render: =>
            @el.innerHTML = jade.template 'embedded-title', lang: p13n.getLanguage(), href: @href
            @el

define [
    'app/dateformat',
    'app/views/base',
], (
    dateformat,
    base,
) ->

    class EventDetailsView extends base.SMLayout
        id: 'event-view-container'
        className: 'navigation-element'
        template: 'event'
        events:
            'click .back-button': 'goBack'
            'click .sp-name a': 'goBack'
        type: 'event'

        initialize: (options) ->
            @embedded = options.embedded
            @servicePoint = @model.get('unit')

        serializeData: ->
            data = @model.toJSON()
            data.embedded_mode = @embedded
            startTime = @model.get 'start_time'
            endTime = @model.get 'end_time'
            data.datetime = dateformat.humanizeEventDatetime(
                startTime, endTime, 'large')
            if @servicePoint?
                data.sp_name = @servicePoint.get 'name'
                data.sp_url = @servicePoint.get 'www_url'
                data.sp_phone = @servicePoint.get 'phone'
            else
                data.sp_name = @model.get('location_extra_info')
                data.prevent_back = true
            data

        goBack: (event) ->
            event.preventDefault()
            app.commands.execute 'clearSelectedEvent'
            app.commands.execute 'selectUnit', @servicePoint

define ['underscore', 'URI', 'backbone', 'app/views/base', 'app/views/context-menu', 'app/p13n', 'i18next'], (_, URI, Backbone, base, ContextMenu, p13n, i18n) ->

    class ExportingView extends base.SMLayout
        template: 'exporting'
        regions:
            exportingContext: '#exporting-context'
        events:
            'click': 'openMenu'
        openMenu: (ev) ->
            ev.preventDefault()
            ev.stopPropagation()
            if @exportingContext.currentView?
                @exportingContext.reset()
                return
            models = [
                new Backbone.Model
                    name: i18n.t 'tools.embed_action'
                    action: _.bind @exportEmbed, @
            ]
            menu = new ContextMenu collection: new Backbone.Collection models
            @exportingContext.show menu
            $(document).one 'click', (ev) =>
                @exportingContext.reset()
        exportEmbed: (ev) ->
            url = URI window.location.href
            directory = url.directory()
            directory = '/embedder' + directory
            url.directory directory
            url.port ''
            query = url.search true
            query.bbox = @getMapBoundsBbox()
            city = p13n.get 'city'
            if city?
                query.city = city
            background = p13n.get('map_background_layer')
            if background not in ['servicemap', 'guidemap']
                query.map = background
            query.ratio = parseInt(100 * window.innerHeight / window.innerWidth)
            url.search query
            window.location.href = url.toString()
        getMapBoundsBbox: ->
            # TODO: don't break architecture thusly
            __you_shouldnt_access_me_like_this = window.mapView.map
            wrongBbox = __you_shouldnt_access_me_like_this._originalGetBounds().toBBoxString().split ','
            rightBbox = _.map [1,0,3,2], (i) -> wrongBbox[i].slice(0,8)
            rightBbox.join ','
        render: ->
            super()
            @el

define [
    'app/views/base',
    'app/tour'
],
(
    base,
    tour,
) ->

    class TourStartButton extends base.SMItemView
        className: 'feature-tour-start'
        template: 'feature-tour-start'
        events:
            'click .close-button' : 'hideTour'
            'click .prompt-button' : 'showTour'
        hideTour: (ev) ->
            p13n.set 'hide_tour', true
            @trigger 'close'
            ev.stopPropagation()
        showTour: (ev) ->
            tour.startTour()
            @trigger 'close'

define [
    'app/views/base',
], (
    base,
) ->

    class FeedbackConfirmationView extends base.SMItemView
        template: 'feedback-confirmation'
        className: 'content modal-dialog'
        events:
            'click .ok-button': '_close'
        initialize: (@unit) ->
        serializeData: ->
            unit: @unit.toJSON()
        _close: ->
            app.commands.execute 'closeFeedback'

define [
    'underscore',
    'app/views/base',
    'app/views/accessibility-personalisation',
    'i18next',
], (
    _,
    base,
    AccessibilityPersonalisationView,
    t: t,
) ->

    class FeedbackFormView extends base.SMLayout
        template: 'feedback-form'
        className: 'content modal-dialog'
        regions:
            accessibility: '#accessibility-section'
        events:
            'submit': '_submit'
            'change input[type=checkbox]': '_onCheckboxChanged'
            'change input[type=radio]': '_onRadioButtonChanged'
            'click .personalisations li': '_onPersonalisationClick'
            'blur input[type=text]': '_onFormInputBlur'
            'blur input[type=email]': '_onFormInputBlur'
            'blur textarea': '_onFormInputBlur'

        initialize: (
            unit: @unit
            model: @model
        ) ->
        onRender: ->
            @_adaptInputWidths @$el, 'input[type=text]'
            @accessibility.show new AccessibilityPersonalisationView(@model.get('accessibility_viewpoints') or [])

        serializeData: ->
            keys = [
                'title', 'first_name', 'description',
                'email', 'accessibility_viewpoints',
                'can_be_published', 'service_request_type'
            ]
            value = (key) => @model.get(key) or ''
            values = _.object keys, _(keys).map(value)
            values.accessibility_enabled = @model.get('accessibility_enabled') or false
            values.email_enabled = @model.get('email_enabled') or false
            values.unit = @unit.toJSON()
            values

        _adaptInputWidths: ($el, selector) ->
            _.defer =>
                $el.find(selector).each ->
                    pos = $(@).position().left
                    width = 440
                    width -= pos
                    $(@).css 'width', "#{width}px"
                $el.find('textarea').each -> $(@).css 'width', "460px"

        _submit: (ev) ->
            ev.preventDefault()
            @model.set 'unit', @unit
            @model.save()

        _onCheckboxChanged: (ev) ->
            target = ev.currentTarget
            checked = target.checked
            $hiddenSection = $(target).closest('.form-section').find('.hidden-section')
            if checked
                $hiddenSection.removeClass 'hidden'
                @_adaptInputWidths $hiddenSection, 'input[type=email]'
            else
                $hiddenSection.addClass 'hidden'
            @_setModelField @_getModelFieldId($(target)), checked

        _onRadioButtonChanged: (ev) ->
            $target = $(ev.currentTarget)
            name = $target.attr 'name'
            value = $target.val()
            @model.set @_getModelFieldId($target, attrName='name'), value

        _onFormInputBlur: (ev) ->
            $target = $ ev.currentTarget
            contents = $target.val()
            id = @_getModelFieldId $target
            success = @_setModelField id, contents
            $container = $target.closest('.form-section').find('.validation-error')
            if success
                $container.addClass 'hidden'
            else
                error = @model.validationError
                $container.html t("feedback.form.validation.#{error[id]}")
                $container.removeClass 'hidden'

        _getModelFieldId: ($target, attrName='id') ->
            try
                $target.attr(attrName).replace /open311-/, ''
            catch TypeError
                null

        _setModelField: (id, val) ->
            @model.set id, val, validate: true

        _onPersonalisationClick: (ev) ->
            $target = $(ev.currentTarget)
            type = $target.data 'type'
            $target.closest('#accessibility-section').find('li').removeClass 'selected'
            $target.addClass 'selected'
            @model.set 'accessibility_viewpoints', [type]

define [
    'underscore',
    'app/models',
    'app/views/base',
], (
    _,
    models,
    base
) ->

    class LanguageSelectorView extends base.SMItemView
        template: 'language-selector'
        # events:
        #     'click .language': 'selectLanguage'
        languageSubdomain:
            fi: 'palvelukartta'
            sv: 'servicekarta'
            en: 'servicemap'
        initialize: (opts) ->
            @p13n = opts.p13n
            @languages = @p13n.getSupportedLanguages()
            @refreshCollection()
            @listenTo p13n, 'url', =>
                @render()
        selectLanguage: (ev) ->
            l = $(ev.currentTarget).data('language')
            window.location.reload()
        _replaceUrl: (withWhat) ->
            href = window.location.href
            if href.match /^http[s]?:\/\/[^.]+\.hel\..*/
                return href.replace /\/\/[^.]+./, "//#{withWhat}."
            else
                return href
        serializeData: ->
            data = super()
            for i, val of data.items
                val.link = @_replaceUrl @languageSubdomain[val.code]
            data
        refreshCollection: ->
            selected = @p13n.getLanguage()
            languageModels = _.map @languages, (l) ->
                new models.Language
                    code: l.code
                    name: l.name
                    selected: l.code == selected
            @collection = new models.LanguageList _.filter languageModels, (l) -> !l.get('selected')

define ['app/views/base'], (base) ->

    class LocationRefreshButtonView extends base.SMLayout
        template: 'location-refresh-button'
        events:
            'click': 'resetPosition'
        resetPosition: (ev) ->
            ev.stopPropagation()
            ev.preventDefault()
            app.commands.execute 'resetPosition'
        render: ->
            super()
            @el

define [
    'app/views/base',
    'app/views/event-details',
    'app/views/service-tree',
    'app/views/position-details',
    'app/views/unit-details',
    'app/views/search-input',
    'app/views/search-results',
    'app/views/sidebar-region',
    'app/map-view'
], (
    base,
    EventDetailsView,
    ServiceTreeView,
    PositionDetailsView,
    UnitDetailsView,
    SearchInputView,
    {SearchLayoutView: SearchLayoutView,
    UnitListLayoutView: UnitListLayoutView},
    SidebarRegion,
    MapView
) ->

    class NavigationLayout extends base.SMLayout
        className: 'service-sidebar'
        template: 'navigation-layout'
        regionType: SidebarRegion
        regions:
            header: '#navigation-header'
            contents: '#navigation-contents'
        onShow: ->
            @header.show new NavigationHeaderView
                layout: this
                searchState: @searchState
                searchResults: @searchResults
                selectedUnits: @selectedUnits
        initialize: (options) ->
            @serviceTreeCollection = options.serviceTreeCollection
            @selectedServices = options.selectedServices
            @searchResults = options.searchResults
            @selectedUnits = options.selectedUnits
            @units = options.units
            @selectedEvents = options.selectedEvents
            @selectedPosition = options.selectedPosition
            @searchState = options.searchState
            @routingParameters = options.routingParameters
            @route = options.route
            @breadcrumbs = [] # for service-tree view
            @openViewType = null # initially the sidebar is closed.
            @addListeners()
        addListeners: ->
            @listenTo @searchResults, 'ready', ->
                @change 'search'
            @listenTo @serviceTreeCollection, 'finished', ->
                @openViewType = null
                @change 'browse'
            @listenTo @selectedServices, 'reset', (coll, opts) ->
                unless opts?.skip_navigate
                    @change 'browse'
            @listenTo @selectedPosition, 'change:value', (w, value) ->
                previous = @selectedPosition.previous 'value'
                if previous?
                    @stopListening previous
                if value?
                    @listenTo value, 'change:radiusFilter', @radiusFilterChanged
                if @selectedPosition.isSet()
                    @change 'position'
                else if @openViewType == 'position'
                    @closeContents()
            @listenTo @selectedServices, 'add', (service) ->
                @closeContents()
                @service = service
                @listenTo @service.get('units'), 'finished', =>
                    @change 'service-units'
            @listenTo @selectedServices, 'remove', (service, coll) =>
                if coll.isEmpty()
                    if @openViewType == 'service-units'
                        @closeContents()
                else
                    @change 'service-units'
            @listenTo @selectedUnits, 'reset', (unit, coll, opts) ->
                currentViewType = @contents.currentView?.type
                if currentViewType == 'details'
                    if @searchResults.isEmpty() and @selectedUnits.isEmpty()
                        @closeContents()
                unless @selectedUnits.isEmpty()
                    @change 'details'
            @listenTo @selectedUnits, 'remove', (unit, coll, opts) ->
                @change null
            @listenTo @selectedEvents, 'reset', (unit, coll, opts) ->
                unless @selectedEvents.isEmpty()
                    @change 'event'
            @contents.on('show', @updateMaxHeights)
            $(window).resize @updateMaxHeights
            @listenTo(app.vent, 'landing-page-cleared', @setMaxHeight)
        updateMaxHeights: =>
            @setMaxHeight()
            currentViewType = @contents.currentView?.type
            MapView.setMapActiveAreaMaxHeight
                maximize: not currentViewType or currentViewType == 'search'
        setMaxHeight: =>
            # Set the sidebar content max height for proper scrolling.
            $limitedElement = @$el.find('.limit-max-height')
            return unless $limitedElement.length
            maxHeight = $(window).innerHeight() - $limitedElement.offset().top
            $limitedElement.css 'max-height': maxHeight
            @$el.find('.map-active-area').css 'padding-bottom', MapView.mapActiveAreaMaxHeight()
        getAnimationType: (newViewType) ->
            currentViewType = @contents.currentView?.type
            if currentViewType
                switch currentViewType
                    when 'event'
                        return 'right'
                    when 'details'
                        switch newViewType
                            when 'event' then return 'left'
                            when 'details' then return 'up-and-down'
                            else return 'right'
                    when 'service-tree'
                        return @contents.currentView.animationType or 'left'
            return null

        closeContents: ->
            @change null
            @openViewType = null
            @header.currentView.updateClasses null
            MapView.setMapActiveAreaMaxHeight maximize: true

        radiusFilterChanged: (value) ->
            if value.get('radiusFilter') > 0
                @listenToOnce @units, 'finished', =>
                    @change 'radius'

        change: (type) ->

            # Don't react if browse is already opened
            return if type is 'browse' and @openViewType is 'browse'

            switch type
                when 'browse'
                    view = new ServiceTreeView
                        collection: @serviceTreeCollection
                        selectedServices: @selectedServices
                        breadcrumbs: @breadcrumbs
                when 'radius'
                    view = new UnitListLayoutView
                        fullCollection: @units
                        collectionType: 'radius'
                        position: @selectedPosition.value()
                        resultType: 'unit'
                        onlyResultType: true
                when 'search'
                    view = new SearchLayoutView
                        collection: @searchResults
                when 'service-units'
                    view = new UnitListLayoutView
                        fullCollection: @units
                        collectionType: 'service'
                        resultType: 'unit'
                        onlyResultType: true
                when 'details'
                    view = new UnitDetailsView
                        model: @selectedUnits.first()
                        route: @route
                        parent: @
                        routingParameters: @routingParameters
                        searchResults: @searchResults
                        selectedUnits: @selectedUnits
                        selectedPosition: @selectedPosition
                when 'event'
                    view = new EventDetailsView
                        model: @selectedEvents.first()
                when 'position'
                    view = new PositionDetailsView
                        model: @selectedPosition.value()
                        route: @route
                        selectedPosition: @selectedPosition
                        routingParameters: @routingParameters
                else
                    @opened = false
                    view = null
                    @contents.reset()

            @updatePersonalisationButtonClass type

            if view?
                @contents.show view, animationType: @getAnimationType(type)
                @openViewType = type
                @opened = true
                @listenToOnce view, 'user:close', (ev) =>
                    if type == 'details'
                        if not @selectedServices.isEmpty()
                            @change 'service-units'
                        else if 'distance' of @units.filters
                            @change 'radius'
            unless type == 'details'
                # TODO: create unique titles for routes that require it
                app.vent.trigger 'site-title:change', null

        updatePersonalisationButtonClass: (type) ->
            # Update personalisation icon visibility.
            # Notice: "hidden" class only affects narrow media.
            if type in ['browse', 'search', 'details', 'event', 'position']
                $('#personalisation').addClass 'hidden'
            else
                $('#personalisation').removeClass 'hidden'

    class NavigationHeaderView extends base.SMLayout
        # This view is responsible for rendering the navigation
        # header which allows the user to switch between searching
        # and browsing.
        className: 'container'
        template: 'navigation-header'
        regions:
            search: '#search-region'
            browse: '#browse-region'

        events:
            'click .header': 'open'
            'keypress .header': 'toggleOnKeypress'
            'click .action-button.close-button': 'close'

        initialize: (options) ->
            @navigationLayout = options.layout
            @searchState = options.searchState
            @searchResults = options.searchResults
            @selectedUnits = options.selectedUnits

        onShow: ->
            searchInputView = new SearchInputView(@searchState, @searchResults)
            @search.show searchInputView
            @listenTo searchInputView, 'open', =>
                @updateClasses 'search'
                @navigationLayout.updatePersonalisationButtonClass 'search'
            @browse.show new BrowseButtonView()

        _open: (actionType) ->
            @updateClasses actionType
            @navigationLayout.change actionType

        open: (event) ->
            @_open $(event.currentTarget).data('type')

        toggleOnKeypress: (event) ->
            target = $(event.currentTarget).data('type')
            isNavigationVisible = !!$('#navigation-contents').children().length

            # An early return if the key is not 'enter'
            return if event.keyCode isnt 13

            if isNavigationVisible
                @_close target
            else
                @_open target

        _close: (headerType) ->
            @updateClasses null

            # Clear search query if search is closed.
            if headerType is 'search'
                @$el.find('input').val('')
                app.commands.execute 'closeSearch'
            if headerType is 'search' and not @selectedUnits.isEmpty()
                # Don't switch out of unit details when closing search.
                return
            @navigationLayout.closeContents()

        close: (event) ->
            event.preventDefault()
            event.stopPropagation()
            unless $(event.currentTarget).hasClass('close-button')
                return false
            headerType = $(event.target).closest('.header').data('type')
            @_close headerType

        updateClasses: (opening) ->
            classname = "#{opening}-open"
            if @$el.hasClass classname
                return
            @$el.removeClass().addClass('container')
            if opening?
                @$el.addClass classname

    class BrowseButtonView extends base.SMItemView
        template: 'navigation-browse'


    NavigationLayout

define [
    'app/p13n',
    'app/views/base',
    'app/views/accessibility-personalisation'
], (
    p13n,
    base,
    AccessibilityPersonalisationView
)  ->

    class PersonalisationView extends base.SMLayout
        className: 'personalisation-container'
        template: 'personalisation'
        regions:
            accessibility: '#accessibility-personalisation'
        events: ->
            'click .personalisation-button': 'personalisationButtonClick'
            'keydown .personalisation-button': @keyboardHandler @personalisationButtonClick, ['space', 'enter']
            'click .ok-button': 'toggleMenu'
            'keydown .ok-button': @keyboardHandler @toggleMenu, ['space']
            'click .select-on-map': 'selectOnMap'
            'click .personalisations a': 'switchPersonalisation'
            'keydown .personalisations a': @keyboardHandler @switchPersonalisation, ['space']
            'click .personalisation-message a': 'openMenuFromMessage'
            'click .personalisation-message .close-button': 'closeMessage'

        personalisationIcons:
            'city': [
                'helsinki'
                'espoo'
                'vantaa'
                'kauniainen'
            ]
            'senses': [
                'hearing_aid'
                'visually_impaired'
                'colour_blind'
            ]
            'mobility': [
                'wheelchair'
                'reduced_mobility'
                'rollator'
                'stroller'
            ]

        initialize: ->
            $(window).resize @setMaxHeight
            @listenTo p13n, 'change', ->
                @setActivations()
                @renderIconsForSelectedModes()
            @listenTo p13n, 'user:open', -> @personalisationButtonClick()

        personalisationButtonClick: (ev) ->
            ev?.preventDefault()
            unless $('#personalisation').hasClass('open')
                @toggleMenu(ev)

        toggleMenu: (ev) ->
            ev?.preventDefault()
            $('#personalisation').toggleClass('open')

        openMenuFromMessage: (ev) ->
            ev?.preventDefault()
            @toggleMenu()
            @closeMessage()

        closeMessage: (ev) ->
            @$('.personalisation-message').removeClass('open')

        selectOnMap: (ev) ->
            # Add here functionality for seleecting user's location from the map.
            ev.preventDefault()

        renderIconsForSelectedModes: ->
            $container = @$('.selected-personalisations').empty()
            for group, types of @personalisationIcons
                for type in types
                    if @modeIsActivated(type, group)
                        if group == 'city'
                            iconClass = 'icon-icon-coat-of-arms-' + type.split('_').join('-')
                        else
                            iconClass = 'icon-icon-' + type.split('_').join('-')
                        $icon = $("<span class='#{iconClass}'></span>")
                        $container.append($icon)

        modeIsActivated: (type, group) ->
            activated = false
            # FIXME
            if group == 'city'
                activated = p13n.get('city') == type
            else if group == 'mobility'
                activated = p13n.getAccessibilityMode('mobility') == type
            else
                activated = p13n.getAccessibilityMode type
            return activated

        setActivations: ->
            $list = @$el.find '.personalisations'
            $list.find('li').each (idx, li) =>
                $li = $(li)
                type = $li.data 'type'
                group = $li.data 'group'
                $button = $li.find('a[role="button"]')
                activated = @modeIsActivated(type, group)
                if activated
                    $li.addClass 'selected'
                else
                    $li.removeClass 'selected'
                $button.attr 'aria-pressed', activated

        switchPersonalisation: (ev) ->
            ev.preventDefault()
            parentLi = $(ev.target).closest 'li'
            group = parentLi.data 'group'
            type = parentLi.data 'type'

            if group == 'mobility'
                p13n.toggleMobility type
            else if group == 'senses'
                modeIsSet = p13n.toggleAccessibilityMode type
                currentBackground = p13n.get 'map_background_layer'
                if type in ['visually_impaired', 'colour_blind']
                    newBackground = null
                    if modeIsSet
                        newBackground = 'accessible_map'
                    else if currentBackground == 'accessible_map'
                        newBackground = 'servicemap'
                    if newBackground
                        p13n.setMapBackgroundLayer newBackground
            else if group == 'city'
                p13n.toggleCity type

        render: (opts) ->
            super opts
            @renderIconsForSelectedModes()
            @setActivations()

        onRender: ->
            @accessibility.show new AccessibilityPersonalisationView []
            @setMaxHeight()

        setMaxHeight: =>
            # TODO: Refactor this when we get some onDomAppend event.
            # The onRender function that calls setMaxHeight runs before @el
            # is inserted into DOM. Hence calculating heights and positions of
            # the template elements is currently impossible.
            personalisationHeaderHeight = 56
            windowWidth = $(window).width()
            offset = 0
            if windowWidth >= appSettings.mobile_ui_breakpoint
                offset = $('#personalisation').offset().top
            maxHeight = $(window).innerHeight() - personalisationHeaderHeight - offset
            @$el.find('.personalisation-content').css 'max-height': maxHeight

define [
    'underscore',
    'app/models',
    'app/map-view',
    'app/views/base',
    'app/views/route'
], (
    _,
    models,
    MapView,
    base,
    RouteView
) ->

    class PositionDetailsView extends base.SMLayout
        type: 'position'
        id: 'details-view-container'
        className: 'navigation-element limit-max-height'
        template: 'position'
        regions:
            'areaServices': '.area-services-placeholder'
            'adminDivisions': '.admin-div-placeholder'
            'routeRegion': '.section.route-section'
        events:
            'click .map-active-area': 'showMap'
            'click .mobile-header': 'showContent'
            'click .icon-icon-close': 'selfDestruct'
            'click #reset-location': 'resetLocation'
            'click #add-circle': 'addCircle'
        initialize: (options) ->
            @selectedPosition = options.selectedPosition
            @route = options.route
            @parent = options.parent
            @routingParameters = options.routingParameters
            @sortedDivisions = [
                'postcode_area',
                'neighborhood',
                'rescue_district',
                'health_station_district',
                'maternity_clinic_district',
                'income_support_district',
                'lower_comprehensive_school_district_fi',
                'lower_comprehensive_school_district_sv',
                'upper_comprehensive_school_district_fi',
                'upper_comprehensive_school_district_sv'
                ]

            @divList = new models.AdministrativeDivisionList()
            @listenTo @model, 'reverse-geocode', =>
                @fetchDivisions().done =>
                    @render()
            @divList.comparator = (a, b) =>
                indexA = _.indexOf @sortedDivisions, a.get('type')
                indexB = _.indexOf @sortedDivisions, b.get('type')
                if indexA < indexB then return -1
                if indexB < indexA then return 1
                return 0
            @listenTo @divList, 'reset', @renderAdminDivs
            @fetchDivisions().done =>
                @render()
        fetchDivisions: ->
            coords = @model.get('location').coordinates
            @divList.fetch
                data:
                    lon: coords[0]
                    lat: coords[1]
                    unit_include: 'name,root_services,location'
                    type: (_.union @sortedDivisions, ['emergency_care_district']).join(',')
                    geometry: 'true'
                reset: true
        serializeData: ->
            data = super()
            data.icon_class = switch @model.origin()
                when 'address' then 'icon-icon-address'
                when 'detected' then 'icon-icon-you-are-here'
                when 'clicked' then 'icon-icon-address'
            data.origin = @model.origin()
            data.neighborhood = @divList.findWhere type: 'neighborhood'
            data.name = @model.humanAddress()
            data

        resetLocation: ->
            app.commands.execute 'resetPosition', @model

        addCircle: ->
            app.commands.execute 'setRadiusFilter', 750

        onRender: ->
            @renderAdminDivs()
            @routeRegion.show new RouteView
                model: @model
                route: @route
                parentView: @
                routingParameters: @routingParameters
                selectedUnits: null
                selectedPosition: @selectedPosition
        renderAdminDivs: ->
            divsWithUnits = @divList.filter (x) -> x.has('unit')
            emergencyDiv = @divList.find (x) ->
                x.get('type') == 'emergency_care_district'
            if divsWithUnits.length > 0
                units = new models.UnitList(
                    divsWithUnits.map (x) ->
                        unit = new models.Unit x.get('unit')
                        unit.set 'area', x
                        if x.get('type') == 'health_station_district'
                            unit.set 'emergencyUnitId', emergencyDiv.getEmergencyCareUnit()
                        unit
                )
                @areaServices.show new UnitListView
                    collection: units
                @adminDivisions.show new DivisionListView
                    collection: new models.AdministrativeDivisionList(@divList.filter (x) => x.get('type') != 'emergency_care_district')
        showMap: (event) ->
            event.preventDefault()
            @$el.addClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: true
        showContent: (event) ->
            event.preventDefault()
            @$el.removeClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: false

        selfDestruct: (event) ->
            event.stopPropagation()
            app.commands.execute 'clearSelectedPosition'

    class DivisionListItemView extends base.SMItemView
        events:
            'click': 'handleClick'
        tagName: 'li'
        template: 'division-list-item'
        handleClick: =>
            app.commands.execute 'toggleDivision', @model
        initialize: =>
            @listenTo @model, 'change:selected', @render

    class DivisionListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'division-list sublist'
        itemView: DivisionListItemView


    class UnitListItemView extends base.SMItemView
        events:
            'click a': 'handleInnerClick'
            'click': 'handleClick'
        tagName: 'li'
        template: 'unit-list-item'
        serializeData: ->
            data = super()
            data
        handleInnerClick: (ev) =>
            ev?.stopPropagation()
        handleClick: (ev) =>
            ev?.preventDefault()
            app.commands.execute 'setUnit', @model
            app.commands.execute 'selectUnit', @model

    class UnitListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'unit-list sublist'
        itemView: UnitListItemView



    PositionDetailsView

define [
    'app/views/base',
], (
    base,
) ->

    class RadiusControlsView extends base.SMItemView
        template: 'radius-controls'
        className: 'radius-controls'
        events: 'change': 'onChange'
        serializeData: ->
            selected: @selected or 750
            values: [
                250, 500, 750, 1000,
                2000, 3000, 4000]
        initialize: (radius: @selected) ->
        onChange: (ev) ->
            @selected = $(ev.target).val()
            @render()
            app.commands.execute 'setRadiusFilter', @selected

define [
    'underscore',
    'moment',
    'bootstrap-datetimepicker',
    'app/p13n',
    'app/models',
    'app/search',
    'app/views/base',
    'app/views/accessibility',
    'app/geocoding',
    'app/jade'
], (
    _,
    moment,
    datetimepicker,
    p13n,
    models,
    search,
    base,
    accessibilityViews,
    geocoding,
    jade
) ->

    class RouteSettingsView extends base.SMLayout
        template: 'route-settings'
        regions:
            'headerRegion': '.route-settings-header'
            'routeControllersRegion': '.route-controllers'
            'accessibilitySummaryRegion': '.accessibility-viewpoint-part'
            'transportModeControlsRegion': '.transport_mode_controls'

        initialize: (attrs) ->
            @unit = attrs.unit
            @listenTo @model, 'change', @updateRegions

        onRender: ->
            @headerRegion.show new RouteSettingsHeaderView
                model: @model
            @routeControllersRegion.show new RouteControllersView
                model: @model
                unit: @unit
            @accessibilitySummaryRegion.show new accessibilityViews.AccessibilityViewpointView
                filterTransit: true
                template: 'accessibility-viewpoint-oneline'
            @transportModeControlsRegion.show new TransportModeControlsView

        updateRegions: ->
            @headerRegion.currentView.render()
            @accessibilitySummaryRegion.currentView.render()
            @transportModeControlsRegion.currentView.render()


    class RouteSettingsHeaderView extends base.SMItemView
        template: 'route-settings-header'
        events:
            'click .settings-summary': 'toggleSettingsVisibility'
            'click .ok-button': 'toggleSettingsVisibility'

        serializeData: ->
            profiles = p13n.getAccessibilityProfileIds true

            origin = @model.getOrigin()
            originName = @model.getEndpointName origin
            if (
                (origin?.isDetectedLocation() and not origin?.isPending()) or
                (origin? and origin instanceof models.CoordinatePosition)
            )
                originName = originName.toLowerCase()

            transportIcons = []
            for mode, value of p13n.get('transport')
                if value
                    transportIcons.push "icon-icon-#{mode.replace('_', '-')}"

            profile_set: _.keys(profiles).length
            profiles: p13n.getProfileElements profiles
            origin_name: originName
            origin_is_pending: @model.getOrigin().isPending()
            transport_icons: transportIcons

        toggleSettingsVisibility: (event) ->
            event.preventDefault()
            $('#route-details').toggleClass('settings-open')
            $('.bootstrap-datetimepicker-widget').hide()
            $('#route-details').trigger "shown"

    class TransportModeControlsView extends base.SMItemView
        template: 'transport-mode-controls'
        events:
            'click .transport-modes a': 'switchTransportMode'

        onRender: =>
            _(['public', 'bicycle']).each (group) =>
                @$el.find(".#{group}-details a").click (ev) =>
                    ev.preventDefault()
                    @switchTransportDetails ev, group

        serializeData: ->
            transportModes = p13n.get('transport')
            bicycleDetailsClasses = ''
            if transportModes.public_transport
                bicycleDetailsClasses += 'no-arrow '
            unless transportModes.bicycle
                bicycleDetailsClasses += 'hidden'
            selectedValues = (modes) =>
                _(modes)
                    .chain()
                    .pairs()
                    .filter (v) => v[1] == true
                    .map (v) => v[0]
                    .value()
            transportModes = selectedValues transportModes
            publicModes = selectedValues p13n.get('transport_detailed_choices').public

            transport_modes: transportModes
            public_modes: publicModes
            transport_detailed_choices: p13n.get('transport_detailed_choices')
            bicycle_details_classes: bicycleDetailsClasses

        switchTransportMode: (ev) ->
            ev.preventDefault()
            type = $(ev.target).closest('li').data 'type'
            p13n.toggleTransport type

        switchTransportDetails: (ev, group) ->
            ev.preventDefault()
            type = $(ev.target).closest('li').data 'type'
            p13n.toggleTransportDetails group, type

    class RouteControllersView extends base.SMItemView
        template: 'route-controllers'
        events:
            'click .preset.unlocked': 'switchToLocationInput'
            'click .preset-current-time': 'switchToTimeInput'
            'click .preset-current-date': 'switchToDateInput'
            'click .time-mode': 'setTimeMode'
            'click .swap-endpoints': 'swapEndpoints'
            'click .tt-suggestion': (e) ->
                e.stopPropagation()
            'click': 'undoChanges'
            # Important: the above click handler requires the following
            # to not disable the time picker widget.
            'click .time': (ev) -> ev.stopPropagation()
            'click .date': (ev) -> ev.stopPropagation()

        initialize: (attrs) ->
            window.debugRoutingControls = @
            @permanentModel = @model
            @pendingPosition = @permanentModel.pendingPosition
            @currentUnit = attrs.unit
            @_reset()

        _reset: ->
            @stopListening @model
            @model = @permanentModel.clone()
            @listenTo @model, 'change', (model, options) =>
                # If the change was an interaction with the datetimepicker
                # widget, we shouldn't re-render.
                unless options?.alreadyVisible
                    @$el.find('input.time').data("DateTimePicker")?.hide()
                    @$el.find('input.time').data("DateTimePicker")?.destroy()
                    @$el.find('input.date').data("DateTimePicker")?.hide()
                    @$el.find('input.date').data("DateTimePicker")?.destroy()
                    @render()
            @listenTo @model.getOrigin(), 'change', @render
            @listenTo @model.getDestination(), 'change', @render

        onRender: ->
            @enableTypeahead '.transit-end input'
            @enableTypeahead '.transit-start input'
            @enableDatetimePicker()

        enableDatetimePicker: ->
            keys = ['time', 'date']
            other = (key) =>
                keys[keys.indexOf(key) + 1 % keys.length]
            inputElement = (key) =>
                @$el.find "input.#{key}"
            otherHider = (key) => =>
                inputElement(other(key)).data("DateTimePicker")?.hide()
            valueSetter = (key) => (ev) =>
                keyUpper = key.charAt(0).toUpperCase() + key.slice 1
                @model["set#{keyUpper}"].call @model, ev.date.toDate(),
                    alreadyVisible: true
                @applyChanges()

            closePicker = true
            _.each keys, (key) =>
                $input = inputElement key
                if $input.length > 0
                    options = {}
                    disablePick = (
                        time: 'pickDate'
                        date: 'pickTime'
                    )[key]
                    options[disablePick] = false

                    $input.datetimepicker options
                    $input.on 'dp.show', =>
                        # If a different picker is shown, don't close
                        # it immediately.
                        # TODO: get rid of unnecessarily complex open/close logic
                        if @activateOnRender != 'date' and @shown? and @shown != key then closePicker = false
                        otherHider(key)()
                        @shown = key
                    $input.on 'dp.change', valueSetter(key)
                    dateTimePicker = $input.data("DateTimePicker")
                    $input.on 'click', =>
                        if closePicker then @_closeDatetimePicker $input
                        closePicker = !closePicker
                    if @activateOnRender == key
                        dateTimePicker.show()
                        $input.attr 'readonly', @_isScreenHeightLow()
            @activateOnRender = null

        applyChanges: ->
            @permanentModel.set @model.attributes
            @permanentModel.triggerComplete()
        undoChanges: ->
            @_reset()
            origin = @model.getOrigin()
            destination = @model.getDestination()
            @model.trigger 'change'

        enableTypeahead: (selector) ->
            @$searchEl = @$el.find selector
            unless @$searchEl.length
                return

            geocoderBackend = new geocoding.GeocoderSourceBackend()
            options = geocoderBackend.getDatasetOptions()
            options.templates.empty = (ctx) -> jade.template 'typeahead-no-results', ctx
            @$searchEl.typeahead null, [options]

            @$searchEl.on 'keyup', (e) =>
                $('.tt-suggestion:first-child').trigger('click') if e.keyCode is 13

            selectAddress = (event, match) =>
                @commit = true
                switch $(event.currentTarget).attr 'data-endpoint'
                    when 'origin'
                        @model.setOrigin match
                    when 'destination'
                        @model.setDestination match

                @applyChanges()

            geocoderBackend.setOptions
                $inputEl: @$searchEl
                selectionCallback: selectAddress

            # Focus on search-elem when #route-details has been opened
            $('#route-details').on "shown", =>
                @$searchEl.attr('tabindex', -1).focus()

        _locationNameAndLocking: (object) ->
            name: @model.getEndpointName object
            lock: @model.getEndpointLocking object

        _isScreenHeightLow: ->
            $(window).innerHeight() < 700

        serializeData: ->
            datetime = moment @model.getDatetime()
            today = new Date()
            tomorrow = moment(today).add 1, 'days'
            # try to avoid opening the mobile virtual keyboard
            disable_keyboard: @_isScreenHeightLow()
            is_today: not @forceDateInput and datetime.isSame(today, 'day')
            is_tomorrow: datetime.isSame tomorrow, 'day'
            params: @model
            origin: @_locationNameAndLocking @model.getOrigin()
            destination: @_locationNameAndLocking @model.getDestination()
            time: datetime.format 'LT'
            date: datetime.format 'L'
            time_mode: @model.get 'time_mode'

        swapEndpoints: (ev) ->
            ev.stopPropagation()
            @permanentModel.swapEndpoints
                silent: true
            @model.swapEndpoints()
            if @model.isComplete()
                @applyChanges()

        switchToLocationInput: (ev) ->
            ev.stopPropagation()
            @_reset()
            position = @pendingPosition
            position.clear()
            switch $(ev.currentTarget).attr 'data-route-node'
                when 'start' then @model.setOrigin position
                when 'end' then @model.setDestination position
            @listenToOnce position, 'change', =>
                @applyChanges()
                @render()
            position.trigger 'request'

        setTimeMode: (ev) ->
            ev.stopPropagation()
            timeMode = $(ev.target).data('value')
            if timeMode != @model.get 'time_mode'
                @model.setTimeMode(timeMode)
                @applyChanges()

        _closeDatetimePicker: ($input) ->
            $input.data("DateTimePicker").hide()
        switchToTimeInput: (ev) ->
            ev.stopPropagation()
            @activateOnRender = 'time'
            @model.setDefaultDatetime()
        switchToDateInput: (ev) ->
            ev.stopPropagation()
            @activateOnRender = 'date'
            @forceDateInput = true
            @model.trigger 'change'

    RouteSettingsView

define [
    'underscore',
    'moment',
    'i18next',
    'app/p13n',
    'app/models',
    'app/spinner',
    'app/views/base',
    'app/views/route-settings'
], (
    _,
    moment,
    i18n,
    p13n,
    models,
    SMSpinner,
    base,
    RouteSettingsView
) ->

    class RouteView extends base.SMLayout
        id: 'route-view-container'
        className: 'route-view'
        template: 'route'
        regions:
            'routeSettingsRegion': '.route-settings'
            'routeSummaryRegion': '.route-summary'
        events:
            'click a.collapser.route': 'toggleRoute'
            'click .show-map': 'showMap'
        initialize: (options) ->
            @parentView = options.parentView
            @selectedUnits = options.selectedUnits
            @selectedPosition = options.selectedPosition
            @route = options.route
            @routingParameters = options.routingParameters
            # Debounce to avoid flooding the OTP server on small time input change.
            @listenTo @routingParameters, 'complete', _.debounce _.bind(@requestRoute, @), 300
            @listenTo p13n, 'change', @changeTransitIcon
            @listenTo @route, 'change:plan', (route) =>
                if route.has 'plan'
                    @routingParameters.set 'route', @route
                    @showRouteSummary @route
            @listenTo p13n, 'change', (path, val) =>
                # if path[0] == 'accessibility'
                #     if path[1] != 'mobility'
                #         return
                # else if path[0] != 'transport'
                #     return
                @requestRoute()

        serializeData: ->
            transit_icon: @getTransitIcon()

        getTransitIcon: () ->
            setModes = _.filter _.pairs(p13n.get('transport')), ([k, v]) -> v == true
            mode = setModes.pop()[0]
            modeIconName = mode.replace '_', '-'
            "icon-icon-#{modeIconName}"

        changeTransitIcon: ->
            $iconEl = @$el.find('#route-section-icon')
            $iconEl.removeClass().addClass @getTransitIcon()

        toggleRoute: (ev) ->
            $element = $(ev.currentTarget)
            if $element.hasClass 'collapsed'
                @showRoute()
            else
                @hideRoute()

        showMap: (ev) ->
            @parentView.showMap(ev)

        showRoute: ->
            # Route planning
            #
            lastPos = p13n.getLastPosition()
            # Ensure that any user entered position is the origin for the new route
            # so that setting the destination won't overwrite the user entered data.
            @routingParameters.ensureUnitDestination()
            @routingParameters.setDestination @model
            previousOrigin = @routingParameters.getOrigin()
            if lastPos
                if not previousOrigin
                    @routingParameters.setOrigin lastPos,
                        silent: true
                @requestRoute()
            else
                @listenTo p13n, 'position', (pos) =>
                    @requestRoute()
                @listenTo p13n, 'position_error', =>
                    @showRouteSummary null
                if not previousOrigin
                    @routingParameters.setOrigin new models.CoordinatePosition
                p13n.requestLocation @routingParameters.getOrigin()

            @routeSettingsRegion.show new RouteSettingsView
                model: @routingParameters
                unit: @model

            @showRouteSummary null

        showRouteSummary: (route) ->
            @routeSummaryRegion.show new RoutingSummaryView
                model: @routingParameters
                noRoute: !route?

        requestRoute: ->
            if not @routingParameters.isComplete()
                return

            spinner = new SMSpinner
                container:
                    @$el.find('#route-details .route-spinner').get(0)

            spinner.start()
            @listenTo @route, 'change:plan', (plan) =>
                spinner.stop()
            @listenTo @route, 'error', =>
                spinner.stop()

            @routingParameters.unset 'route'

            opts = {}

            if p13n.getAccessibilityMode('mobility') == 'wheelchair'
                opts.wheelchair = true
                opts.walkReluctance = 5
                opts.walkBoardCost = 12*60
                opts.walkSpeed = 0.75
                opts.minTransferTime = 3*60+1

            if p13n.getAccessibilityMode('mobility') == 'reduced_mobility'
                opts.walkReluctance = 5
                opts.walkBoardCost = 10*60
                opts.walkSpeed = 0.5

            if p13n.getAccessibilityMode('mobility') == 'rollator'
                opts.wheelchair = true
                opts.walkReluctance = 5
                opts.walkSpeed = 0.5
                opts.walkBoardCost = 12*60

            if p13n.getAccessibilityMode('mobility') == 'stroller'
                opts.walkBoardCost = 10*60
                opts.walkSpeed = 1

            if p13n.getTransport 'bicycle'
                opts.bicycle = true
                # TODO: take/park bike

            if p13n.getTransport 'car'
                opts.car = true

            if p13n.getTransport 'public_transport'
                publicTransportChoices = p13n.get('transport_detailed_choices').public
                selectedVehicles = _(publicTransportChoices)
                    .chain()
                    .pairs().filter(_.last).map(_.first)
                    .value()
                if selectedVehicles.length == _(publicTransportChoices).values().length
                    opts.transit = true
                else
                    opts.transit = false
                    opts.modes = selectedVehicles

            datetime = @routingParameters.getDatetime()
            opts.date = moment(datetime).format('YYYY/MM/DD')
            opts.time = moment(datetime).format('HH:mm')
            opts.arriveBy = @routingParameters.get('time_mode') == 'arrive'

            from = @routingParameters.getOrigin().otpSerializeLocation
                forceCoordinates: opts.car
            to = @routingParameters.getDestination().otpSerializeLocation
                forceCoordinates: opts.car

            @route.requestPlan from, to, opts

        hideRoute: ->
            @route.clear()


    class RoutingSummaryView extends base.SMItemView
        #itemView: LegSummaryView
        #itemViewContainer: '#route-details'
        template: 'routing-summary'
        className: 'route-summary'
        events:
            'click .route-selector a': 'switchItinerary'
            'click .accessibility-viewpoint': 'setAccessibility'

        initialize: (options) ->
            @itineraryChoicesStartIndex = 0
            @detailsOpen = false
            @skipRoute = options.noRoute
            @route = @model.get 'route'

        NUMBER_OF_CHOICES_SHOWN = 3

        LEG_MODES =
            WALK:
                icon: 'icon-icon-by-foot'
                colorClass: 'transit-walk'
                text: i18n.t('transit.walk')
            BUS:
                icon: 'icon-icon-bus'
                colorClass: 'transit-default'
                text: i18n.t('transit.bus')
            BICYCLE:
                icon: 'icon-icon-bicycle'
                colorClass: 'transit-bicycle'
                text: i18n.t('transit.bicycle')
            CAR:
                icon: 'icon-icon-car'
                colorClass: 'transit-car'
                text: i18n.t('transit.car')
            TRAM:
                icon: 'icon-icon-tram'
                colorClass: 'transit-tram'
                text: i18n.t('transit.tram')
            SUBWAY:
                icon: 'icon-icon-subway'
                colorClass: 'transit-subway'
                text: i18n.t('transit.subway')
            RAIL:
                icon: 'icon-icon-train'
                colorClass: 'transit-rail',
                text: i18n.t('transit.rail')
            FERRY:
                icon: 'icon-icon-ferry'
                colorClass: 'transit-ferry'
                text: i18n.t('transit.ferry')
            WAIT:
                icon: '',
                colorClass: 'transit-default'
                text: i18n.t('transit.wait')

        MODES_WITH_STOPS = [
            'BUS'
            'FERRY'
            'RAIL'
            'SUBWAY'
            'TRAM'
        ]

        serializeData: ->
            if @skipRoute
                return skip_route: true

            window.debugRoute = @route

            itinerary = @route.getSelectedItinerary()
            filteredLegs = _.filter(itinerary.legs, (leg) -> leg.mode != 'WAIT')

            mobilityAccessibilityMode = p13n.getAccessibilityMode 'mobility'
            mobilityElement = null
            if mobilityAccessibilityMode
                mobilityElement = p13n.getProfileElement mobilityAccessibilityMode
            else
                mobilityElement = LEG_MODES['WALK']

            legs = _.map(filteredLegs, (leg) =>
                steps = @parseSteps leg

                if leg.mode == 'WALK'
                    icon = mobilityElement.icon
                    if mobilityAccessibilityMode == 'wheelchair'
                        text = i18n.t 'transit.mobility_mode.wheelchair'
                    else
                        text = i18n.t 'transit.walk'
                else
                    icon = LEG_MODES[leg.mode].icon
                    text = LEG_MODES[leg.mode].text
                if leg.from.bogusName
                    startLocation = i18n.t "otp.bogus_name.#{leg.from.name.replace ' ', '_' }"
                start_time: moment(leg.startTime).format('LT')
                start_location: startLocation || p13n.getTranslatedAttr(leg.from.translatedName) || leg.from.name
                distance: @getLegDistance leg, steps
                icon: icon
                transit_color_class: LEG_MODES[leg.mode].colorClass
                transit_mode: text
                route: @getRouteText leg
                transit_destination: @getTransitDestination leg
                steps: steps
                has_warnings: !!_.find(steps, (step) -> step.warning)
            )

            end = {
                time: moment(itinerary.endTime).format('LT')
                name: p13n.getTranslatedAttr(@route.get('plan').to.translatedName) || @route.get('plan').to.name
                address: p13n.getTranslatedAttr(
                    @model.getDestination().get 'street_address'
                )
            }

            route = {
                duration: Math.round(itinerary.duration / 60) + ' min'
                walk_distance: (itinerary.walkDistance / 1000).toFixed(1) + 'km'
                legs: legs
                end: end
            }
            choices = @getItineraryChoices()

            skip_route: false
            profile_set: _.keys(p13n.getAccessibilityProfileIds(true)).length
            itinerary: route
            itinerary_choices: choices
            selected_itinerary_index: @route.get 'selected_itinerary'
            details_open: @detailsOpen
            current_time: moment(new Date()).format('YYYY-MM-DDTHH:mm')

        parseSteps: (leg) ->
            steps = []

            if leg.mode in ['WALK', 'BICYCLE', 'CAR']
                for step in leg.steps
                    warning = null
                    if step.bogusName
                        step.streetName = i18n.t "otp.bogus_name.#{step.streetName.replace ' ', '_' }"
                    else if p13n.getTranslatedAttr step.translatedName
                        step.streetName = p13n.getTranslatedAttr step.translatedName
                    text = i18n.t "otp.step_directions.#{step.relativeDirection}",
                        {street: step.streetName, postProcess: "fixFinnishStreetNames"}
                    if 'alerts' of step and step.alerts.length
                        warning = step.alerts[0].alertHeaderText.someTranslation
                    steps.push(text: text, warning: warning)
            else if leg.mode in MODES_WITH_STOPS and leg.intermediateStops
                if 'alerts' of leg and leg.alerts.length
                    for alert in leg.alerts
                        steps.push(
                            text: ""
                            warning: alert.alertHeaderText.someTranslation
                        )
                for stop in leg.intermediateStops
                    steps.push(
                        text: p13n.getTranslatedAttr(stop.translatedName) || stop.name
                        time: moment(stop.arrival).format('LT')
                    )
            else
                steps.push(text: 'No further info.')


            return steps

        getLegDistance: (leg, steps) ->
            if leg.mode in MODES_WITH_STOPS
                stops = _.reject(steps, (step) -> 'warning' of step)
                return "#{stops.length} #{i18n.t('transit.stops')}"
            else
                return (leg.distance / 1000).toFixed(1) + 'km'

        getTransitDestination: (leg) ->
            if leg.mode in MODES_WITH_STOPS
                return "#{i18n.t('transit.toward')} #{leg.headsign}"
            else
                return ''

        getRouteText: (leg) ->
            route = if leg.route.length < 5 then leg.route else ''
            if leg.mode == 'FERRY'
                route = ''
            return route

        getItineraryChoices: ->
            numberOfItineraries = @route.get('plan').itineraries.length
            start = @itineraryChoicesStartIndex
            stop = Math.min(start + NUMBER_OF_CHOICES_SHOWN, numberOfItineraries)
            _.range(start, stop)

        switchItinerary: (event) ->
            event.preventDefault()
            @detailsOpen = true
            @route.set 'selected_itinerary', $(event.currentTarget).data('index')
            @render()

        setAccessibility: (event) ->
            event.preventDefault()
            p13n.trigger 'user:open'


    RouteView

define [
    'typeahead.bundle',
    'app/models',
    'app/jade',
    'app/search',
    'app/geocoding',
    'app/views/base',
], (
    typeahead,
    models,
    jade,
    search,
    geocoding,
    base
) ->
    class SearchInputView extends base.SMItemView
        classname: 'search-input-element'
        template: 'navigation-search'

        initialize: (@model, @searchResults) ->
            @listenTo @searchResults, 'ready', @adaptToQuery
            @listenTo @searchResults, 'reset', =>
                if @searchResults.isEmpty()
                    @setInputText ''

        adaptToQuery: (model, value, opts) ->
            $container = @$el.find('.action-button')
            $icon = $container.find('span')
            if @isEmpty()
                if @searchResults.query?.length
                    @setInputText @searchResults.query
                    @trigger 'open'
            if @isEmpty() or @getInputText() == @searchResults.query
                $icon.removeClass 'icon-icon-forward-bold'
                $icon.addClass 'icon-icon-close'
                $container.removeClass 'search-button'
                $container.addClass 'close-button'
            else
                $icon.addClass 'icon-icon-forward-bold'
                $icon.removeClass 'icon-icon-close'
                $container.removeClass 'close-button'
                $container.addClass 'search-button'

        events:
            'typeahead:selected': 'autosuggestShowDetails'
            # Important! The following ensures the click
            # will only cause the intended typeahead selection,
            # and doesn't affect the header state
            'click .tt-suggestion': (e) ->
                e.stopPropagation()
            'click input': '_onInputClicked'
            'click .typeahead-suggestion.fulltext': 'executeQuery'
            'click .action-button.search-button': 'search'
            'submit .input-container': 'search'
            'input input': 'checkInputValue'

        checkInputValue: ()->
            if @isEmpty()
                @$searchEl.typeahead('val', '')
                app.commands.execute 'clearSearchResults', navigate: true

        search: (e) ->
            e.stopPropagation()
            unless @isEmpty()
                @$searchEl.typeahead 'close'
                @executeQuery()
            e.preventDefault()

        isEmpty: () ->
            query = @getInputText()
            if query? and query.length > 0
                return false
            return true

        _onInputClicked: (ev) ->
            @trigger 'open'
            ev.stopPropagation()

        _getSearchEl: ->
            if @$searchEl?
                @$searchEl
            else
                @$searchEl = @$el.find 'input.form-control[type=search]'

        setInputText: (query) ->
            $el = @_getSearchEl()
            if $el.length
                $el.typeahead 'val', query

        getInputText: ->
            $el = @_getSearchEl()
            if $el.length
                $el.typeahead 'val'
            else
                null

        onRender: () ->
            @enableTypeahead('input.form-control[type=search]')
            @setTypeaheadWidth()
            $(window).resize => @setTypeaheadWidth()

        setTypeaheadWidth: ->
            windowWidth = window.innerWidth or document.documentElement.clientWidth or document.body.clientWidth
            if windowWidth < appSettings.mobile_ui_breakpoint
                width = $('#navigation-header').width()
                @$el.find('.tt-dropdown-menu').css 'width': width
            else
                @$el.find('.tt-dropdown-menu').css 'width': 'auto'

        enableTypeahead: (selector) ->
            @$searchEl = @$el.find selector
            serviceDataset =
                name: 'service'
                source: search.servicemapEngine.ttAdapter(),
                displayKey: (c) -> c.name[p13n.getLanguage()]
                templates:
                    suggestion: (ctx) -> jade.template 'typeahead-suggestion', ctx
            eventDataset =
                name: 'event'
                source: search.linkedeventsEngine.ttAdapter(),
                displayKey: (c) -> c.name[p13n.getLanguage()]
                templates:
                    suggestion: (ctx) -> jade.template 'typeahead-suggestion', ctx


            # A hack needed to ensure the header is always rendered.
            fullDataset =
                name: 'header'
                # Source has to return non-empty list
                source: (q, c) -> c([{query: q, object_type: 'query'}])
                displayKey: (s) -> s.query
                name: 'full'
                templates:
                    suggestion: (s) -> jade.template 'typeahead-fulltext', s

            @geocoderBackend = new geocoding.GeocoderSourceBackend()
            @$searchEl.typeahead hint: false, [
                fullDataset,
                @geocoderBackend.getDatasetOptions(),
                serviceDataset,
                eventDataset]
            @geocoderBackend.setOptions
                $inputEl: @$searchEl
                selectionCallback: (ev, data) ->
                    app.commands.execute 'selectPosition', data
        getQuery: () ->
            return $.trim @$searchEl.val()

        executeQuery: () ->
            @geocoderBackend.street = null
            @$searchEl.typeahead 'close'
            app.commands.execute 'search', @getInputText()

        autosuggestShowDetails: (ev, data, _) ->
            # Remove focus from the search box to hide keyboards on touch devices.
            # TODO: re-enable in a compatible way
            #$('.search-container input').blur()
            model = null
            objectType = data.object_type
            if objectType == 'address'
                return
            @$searchEl.typeahead 'val', ''
            app.commands.execute 'clearSearchResults', navigate: false
            $('.search-container input').val('')
            @$searchEl.typeahead 'close'
            switch objectType
                when 'unit'
                    model = new models.Unit(data)
                    app.commands.execute 'selectUnit', model, replace: true
                when 'service'
                    app.commands.execute 'addService',
                        new models.Service(data)
                when 'event'
                    app.commands.execute 'selectEvent',
                        new models.Event(data)
                when 'query'
                    app.commands.execute 'search', data.query

define [
    'underscore',
    'i18next',
    'app/models',
    'app/views/base',
    'app/views/radius',
    'app/spinner'
], (
    _,
    i18n,
    models,
    base,
    RadiusControlsView,
    SMSpinner
) ->

    RESULT_TYPES =
        unit: models.UnitList
        service: models.ServiceList
        # event: models.EventList
        address: models.PositionList

    EXPAND_CUTOFF = 3
    PAGE_SIZE = 20

    isElementInViewport = (el) ->
      if typeof jQuery == 'function' and el instanceof jQuery
        el = el[0]
      rect = el.getBoundingClientRect()
      return rect.bottom <= (window.innerHeight or document.documentElement.clientHeight) + (el.offsetHeight * 0)


    class SearchResultView extends base.SMItemView
        template: 'search-result'
        tagName: 'li'
        events: ->
            keyhandler = @keyboardHandler @selectResult, ['enter']
            'click': 'selectResult'
            'keydown': keyhandler
            'focus': 'highlightResult'
            'mouseenter': 'highlightResult'
        initialize: (opts) ->
            @order = opts.order
        selectResult: (ev) ->
            object_type = @model.get('object_type') or 'unit'
            switch object_type
                when 'unit'
                    app.commands.execute 'selectUnit', @model
                when 'service'
                    app.commands.execute 'addService', @model
                when 'address'
                    app.commands.execute 'selectPosition', @model

        highlightResult: (ev) ->
            app.commands.execute 'highlightUnit', @model

        serializeData: ->
            data = super()
            data.specifier_text = @model.getSpecifierText()
            switch @order
                when 'distance'
                    fn = @model.getDistanceToLastPosition
                    if fn?
                        data.distance = fn.apply @model
                when 'accessibility'
                    fn = @model.getShortcomingCount
                    if fn?
                        data.shortcomings = fn.apply @model
            if @model.get('object_type') == 'address'
                data.name = @model.humanAddress exclude: municipality: true
            data

    class SearchResultsView extends base.SMCollectionView
        tagName: 'ul'
        className: 'main-list'
        itemView: SearchResultView
        itemViewOptions: ->
            order: @parent.getComparatorKey()
        initialize: (opts) ->
            super opts
            @parent = opts.parent

    class LocationPromptView extends base.SMItemView
        tagName: 'ul'
        className: 'main-list'
        render: ->
            @$el.html "<li>#{i18n.t('search.location_info')}</li>"
            @

    class SearchResultsLayoutView extends base.SMLayout
        template: 'search-results'
        regions:
            results: '.result-contents'
            controls: '#list-controls'
        className: 'search-results-container'
        events:
            'click .back-button': 'goBack'
            'click .sorting': 'cycleSorting'

        goBack: (ev) ->
            @expansion = EXPAND_CUTOFF
            @requestedExpansion = 0
            @parent.backToSummary()

        cycleSorting: (ev) ->
            @fullCollection.cycleComparator()
            key = @fullCollection.getComparatorKey()
            @renderLocationPrompt = false
            if key == 'distance'
                unless p13n.getLastPosition()?
                    @renderLocationPrompt = true
                    @listenTo p13n, 'position', =>
                        @renderLocationPrompt = false
                        @fullCollection.sort()
                    @listenTo p13n, 'position_error', =>
                        @renderLocationPrompt = false
                    p13n.requestLocation()
            @expansion = 2 * PAGE_SIZE
            @render()

        onBeforeRender: ->
            @collection = new @fullCollection.constructor @fullCollection.slice(0, @expansion)

        nextPage: (ev) ->
            if @expansion == EXPAND_CUTOFF
                # Initial expansion
                delta = 2 * PAGE_SIZE - EXPAND_CUTOFF
            else
                # Already expanded, next page
                delta = PAGE_SIZE
            newExpansion = @expansion + delta

            # Only handle repeated scroll events once.
            if @requestedExpansion == newExpansion then return
            @requestedExpansion = newExpansion

            @expansion = @requestedExpansion
            @render()

        getDetailedFieldset: ->
            switch @resultType
                when 'unit'
                    ['services']
                when 'service'
                    ['ancestors']
                else
                    null

        initialize: ({
            collectionType: @collectionType
            fullCollection: @fullCollection
            resultType: @resultType
            parent: @parent
            onlyResultType: @onlyResultType
            position: @position
        }) ->
            @expansion = EXPAND_CUTOFF
            @$more = null
            @requestedExpansion = 0
            @ready = false
            @ready = true
            if @onlyResultType
                @expansion = 2 * PAGE_SIZE
                @parent?.expand @resultType
            @listenTo @fullCollection, 'hide', =>
                @hidden = true
                @render()
            @listenTo @fullCollection, 'show-all', @nextPage
            @listenTo @fullCollection, 'sort', @render
            @listenTo @fullCollection, 'batch-remove', @render
            @listenTo p13n, 'accessibility-change', =>
                key = @fullCollection.getComparatorKey()
                if p13n.hasAccessibilityIssues()
                    @fullCollection.setComparator 'accessibility'
                else if key == 'accessibility'
                    @fullCollection.setDefaultComparator()
                @fullCollection.sort()
                @render()

        getComparatorKey: ->
            @fullCollection.getComparatorKey()

        serializeData: ->
            if @hidden or not @collection?
                return hidden: true
            data = super()
            if @collection.length
                crumb = switch @collectionType
                    when 'search'
                        i18n.t('sidebar.search_results')
                    when 'radius'
                        if @position?
                            @position.humanAddress()
                data =
                    comparatorKey: @fullCollection.getComparatorKey()
                    controls: @collectionType == 'radius'
                    target: @resultType
                    expanded: @_expanded()
                    showAll: false
                    showMore: false
                    onlyResultType: @onlyResultType
                    crumb: crumb
                    header: i18n.t("search.type.#{@resultType}.count", count: @fullCollection.length)
                if @fullCollection.length > EXPAND_CUTOFF and !@_expanded()
                    data.showAll = i18n.t "search.type.#{@resultType}.show_all",
                        count: @fullCollection.length
                else if @fullCollection.length > @expansion and not @renderLocationPrompt
                    data.showMore = true
            data

        onRender: ->
            if @renderLocationPrompt
                @results.show new LocationPromptView()
                return
            unless @ready
                @ready = true
                return
            collectionView = new SearchResultsView
                collection: @collection
                parent: @
            @listenTo collectionView, 'collection:rendered', =>
                _.defer =>
                    @$more = $(@el).find '.show-more'
                    # Just in case the initial long list somehow
                    # fits inside the page:
                    @tryNextPage()
                    @trigger 'rendered'
            @results.show collectionView
            if @collectionType == 'radius'
                @controls.show new RadiusControlsView radius: @fullCollection.filters.distance

        tryNextPage: ->
            if @$more?.length
                if isElementInViewport @$more
                    @$more.find('.text-content').html i18n.t('accessibility.pending')
                    spinner = new SMSpinner
                        container: @$more.find('.spinner-container').get(0),
                        radius: 5,
                        length: 3,
                        lines: 12,
                        width: 2,
                    spinner.start()
                    @nextPage()

        _expanded: ->
            @expansion > EXPAND_CUTOFF

    class BaseListingLayoutView extends base.SMLayout
        className: -> 'search-results navigation-element limit-max-height'
        events: ->
            'scroll': 'tryNextPage'
        onRender: ->
            view = @getPrimaryResultLayoutView()
            unless view?
                return
            @listenToOnce view, 'rendered', =>
                _.defer => @$el.find('.search-result').first().focus()

    class UnitListLayoutView extends BaseListingLayoutView
        template: 'service-units'
        regions:
            'unitRegion': '.unit-region'
        tryNextPage: ->
            @resultLayoutView.tryNextPage()
        initialize: (opts, rest...) ->
            @resultLayoutView = new SearchResultsLayoutView opts, rest...
        onRender: ->
            @unitRegion.show @resultLayoutView
            super()
        getPrimaryResultLayoutView: ->
            @resultLayoutView

    class SearchLayoutView extends BaseListingLayoutView
        template: 'search-layout'
        type: 'search'
        events: ->
            _.extend {}, super(), 'click .show-all': 'showAllOfSingleType'
        tryNextPage: ->
            if @expanded
                @resultLayoutViews[@expanded]?.tryNextPage()
        expand: (target) ->
            @expanded = target
        showAllOfSingleType: (ev) ->
            ev?.preventDefault()
            target = $(ev.currentTarget).data 'target'
            @expanded = target
            _(@collections).each (collection, key) =>
                if key == target
                    collection.trigger 'show-all'
                else
                    collection.trigger 'hide'
        backToSummary: ->
            @expanded = null
            @render()

        _regionId: (key) ->
            "#{key}Region"
        _getRegionForType: (key) ->
            @getRegion @_regionId(key)

        initialize: ->
            @expanded = null
            @collections = {}
            @resultLayoutViews = {}

            _(RESULT_TYPES).each (val, key) =>
                @collections[key] = new val(null, setComparator: true)
                @addRegion @_regionId(key), ".#{key}-region"

            @listenTo @collection, 'hide', => @$el.hide()

        serializeData: ->
            data = super()
            _(RESULT_TYPES).each (__, key) =>
                @collections[key].set @collection.where(object_type: key)
            #@collections.unit.sort()

            unless @collection.length
                if @collection.query
                    data.noResults = true
                    data.query = @collection.query
            data

        getPrimaryResultLayoutView: ->
            @resultLayoutViews['unit']

        onRender: ->
            @$el.show()
            resultTypeCount = _(@collections).filter((c) => c.length > 0).length
            _(RESULT_TYPES).each (__, key) =>
                if @collections[key].length
                    @resultLayoutViews[key] = new SearchResultsLayoutView
                        resultType: key
                        collectionType: 'search'
                        fullCollection: @collections[key]
                        onlyResultType: resultTypeCount == 1
                        parent: @
                    @_getRegionForType(key).show @resultLayoutViews[key]
            super()

    SearchLayoutView: SearchLayoutView
    UnitListLayoutView: UnitListLayoutView

define [
    'underscore',
    'app/p13n',
    'app/views/base',
], (
    _,
    p13n,
    base
)  ->

    class ServiceCartView extends base.SMItemView
        template: 'service-cart'
        tagName: 'ul'
        className: 'expanded container main-list'
        events: ->
            'click .personalisation-container .maximizer': 'maximize'
            'keydown .personalisation-container .maximizer': @keyboardHandler @maximize, ['space', 'enter']
            'click .button.cart-close-button': 'minimize'
            'click .button.close-button': 'closeService'
            'keydown .button.close-button': @keyboardHandler @closeService, ['space', 'enter']
            'click input': 'selectLayerInput'
            'click label': 'selectLayerLabel'
        initialize: (opts) ->
            @collection = opts.collection
            @listenTo @collection, 'add', @maximize
            @listenTo @collection, 'remove', =>
                if @collection.length
                    @render()
                else
                    @minimize()
            @listenTo @collection, 'reset', @render
            @listenTo @collection, 'minmax', @render
            @listenTo p13n, 'change', (path, value) =>
                if path[0] == 'map_background_layer' then @render()
            if @collection.length
                @minimized = false
            else
                @minimized = true
        maximize: ->
            @minimized = false
            @collection.trigger 'minmax'
        minimize: ->
            @minimized = true
            @collection.trigger 'minmax'
        onRender: ->
            if @minimized
                @$el.removeClass 'expanded'
                @$el.addClass 'minimized'
            else
                @$el.addClass 'expanded'
                @$el.removeClass 'minimized'
                _.defer =>
                    @$el.find('input:checked').first().focus()
        serializeData: ->
            if @minimized
                return minimized: true
            data = super()
            data.layers = p13n.getMapBackgroundLayers()
            data
        closeService: (ev) ->
            app.commands.execute 'removeService', $(ev.currentTarget).data('service')
        _selectLayer: (value) ->
            p13n.setMapBackgroundLayer value
        selectLayerInput: (ev) ->
            @_selectLayer $(ev.currentTarget).attr('value')
        selectLayerLabel: (ev) ->
            @_selectLayer $(ev.currentTarget).data('layer')

define [
    'i18next',
    'app/views/base'
],
(
    {t: t},
    {SMItemView: SMItemView}
) ->
    ServiceMapDisclaimersView: class ServiceMapDisclaimersView extends SMItemView
        template: 'description-of-service'
        className: 'content modal-dialog about'
        serializeData: ->
            lang: p13n.getLanguage()
    ServiceMapDisclaimersOverlayView: class ServiceMapDisclaimersOverlayView extends SMItemView
        template: 'disclaimers-overlay'
        serializeData: ->
            layer = p13n.get('map_background_layer')
            if layer in ['servicemap', 'accessible_map']
                copyrightLink = "https://www.openstreetmap.org/copyright"
            copyright: t "disclaimer.copyright.#{layer}"
            copyrightLink: copyrightLink
        events:
            'click #about-the-service': 'onAboutClick'
        onAboutClick: (ev) ->
            app.commands.execute 'showServiceMapDescription'

define [
    'underscore',
    'i18next',
    'app/models'
    'app/views/base',
], (
    _,
    i18n,
    models,
    base
)  ->

    class ServiceTreeView extends base.SMLayout
        id: 'service-tree-container'
        className: 'navigation-element'
        template: 'service-tree'
        events: ->
            openOnKbd = @keyboardHandler @openService, ['enter']
            toggleOnKbd = @keyboardHandler @toggleLeafButton, ['enter', 'space']
            'click .service.has-children': 'openService'
            'keydown .service.parent': openOnKbd
            'keydown .service.has-children': openOnKbd
            'keydown .service.has-children a.show-icon': toggleOnKbd
            'click .service.parent': 'openService'
            'click .crumb': 'handleBreadcrumbClick'
            'click .service.leaf': 'toggleLeaf'
            'keydown .service.leaf': toggleOnKbd
            'click .service .show-icon': 'toggleButton'
            'mouseenter .service .show-icon': 'showTooltip'
            'mouseleave .service .show-icon': 'removeTooltip'
        type: 'service-tree'

        initialize: (options) ->
            @selectedServices = options.selectedServices
            @breadcrumbs = options.breadcrumbs
            @animationType = 'left'
            @scrollPosition = 0
            @listenTo @selectedServices, 'remove', @render
            @listenTo @selectedServices, 'add', @render
            @listenTo @selectedServices, 'reset', @render

        toggleLeaf: (event) ->
            @toggleElement($(event.currentTarget).find('.show-icon'))
        toggleLeafButton: (event) ->
            @toggleElement $(event.currentTarget)

        toggleButton: (event) ->
            @removeTooltip()
            event.preventDefault()
            event.stopPropagation()
            @toggleElement($(event.target))

        showTooltip: (event) ->
            @removeTooltip()
            @$tooltipElement = $("<div id=\"tooltip\">#{i18n.t('sidebar.show_tooltip')}</div>")
            $targetEl = $(event.currentTarget)
            $('body').append @$tooltipElement
            buttonOffset = $targetEl.offset()
            originalOffset = @$tooltipElement.offset()
            @$tooltipElement.css 'top', "#{buttonOffset.top + originalOffset.top}px"
            @$tooltipElement.css 'left', "#{buttonOffset.left + originalOffset.left}px"
        removeTooltip: (event) ->
            @$tooltipElement?.remove()

        getShowIconClasses: (showing, rootId) ->
            if showing
                return "show-icon selected service-color-#{rootId}"
            else
                return "show-icon service-hover-color-#{rootId}"

        toggleElement: ($targetElement) ->
            serviceId = $targetElement.closest('li').data('service-id')
            unless @selected(serviceId) is true
                app.commands.execute 'clearSearchResults'
                service = new models.Service id: serviceId
                service.fetch
                    success: =>
                        app.commands.execute 'addService', service
            else
                app.commands.execute 'removeService', serviceId

        handleBreadcrumbClick: (event) ->
            event.preventDefault()
            # We need to stop the event from bubling to the containing element.
            # That would make the service tree go back only one step even if
            # user is clicking an earlier point in breadcrumbs.
            event.stopPropagation()
            @openService(event)

        openService: (event) ->
            $target = $(event.currentTarget)
            serviceId = $target.data('service-id')
            serviceName = $target.data('service-name')
            @animationType = $target.data('slide-direction')

            if not serviceId
                return null

            if serviceId == 'root'
                serviceId = null
                # Use splice to affect the original breadcrumbs array.
                @breadcrumbs.splice 0, @breadcrumbs.length
            else
                # See if the service is already in the breadcrumbs.
                index = _.indexOf(_.pluck(@breadcrumbs, 'serviceId'), serviceId)
                if index != -1
                    # Use splice to affect the original breadcrumbs array.
                    @breadcrumbs.splice index, @breadcrumbs.length - index
                @breadcrumbs.push(serviceId: serviceId, serviceName: serviceName)

            spinnerOptions =
                container: $target.get(0)
                hideContainerContent: true
            @collection.expand serviceId, spinnerOptions

        onRender: ->
            if @serviceToDisplay
                $targetElement = @$el.find("[data-service-id=#{@serviceToDisplay.id}]").find('.show-icon')
                @serviceToDisplay = false
                @toggleElement($targetElement)

            $ul = @$el.find('ul')
            $ul.on('scroll', (ev) =>
                @scrollPosition = ev.currentTarget.scrollTop)
            $ul.scrollTop(@scrollPosition)
            @scrollPosition = 0
            @setBreadcrumbWidths()

        setBreadcrumbWidths: ->
            CRUMB_MIN_WIDTH = 40
            # We need to use the last() jQuery method here, because at this
            # point the animations are still running and the DOM contains,
            # both the old and the new content. We only want to get the new
            # content and its breadcrumbs as a basis for our calculations.
            $container = @$el.find('.header-item').last()
            $crumbs = $container.find('.crumb')
            return unless $crumbs.length > 1

            # The last breadcrumb is given preference, so separate that from the
            # rest of the breadcrumbs.
            $lastCrumb = $crumbs.last()
            $crumbs = $crumbs.not(':last')

            $chevrons = $container.find('.icon-icon-forward')
            spaceAvailable = $container.width() - ($chevrons.length * $chevrons.first().outerWidth())
            lastWidth = $lastCrumb.width()
            spaceNeeded = lastWidth + $crumbs.length * CRUMB_MIN_WIDTH

            if spaceNeeded > spaceAvailable
                # Not enough space -> make the last breadcrumb narrower.
                lastWidth = spaceAvailable - $crumbs.length * CRUMB_MIN_WIDTH
                $lastCrumb.css('max-width': lastWidth)
                $crumbs.css('max-width': CRUMB_MIN_WIDTH)
            else
                # More space -> Make the other breadcrumbs wider.
                crumbWidth = (spaceAvailable - lastWidth) / $crumbs.length
                $crumbs.css('max-width': crumbWidth)

        selected: (serviceId) ->
            @selectedServices.get(serviceId)?
        close: ->
            @removeTooltip()
            @remove()
            @stopListening()

        serializeData: ->
            classes = (category) ->
                if category.get('children').length > 0
                    return ['service has-children']
                else
                    return ['service leaf']

            listItems = @collection.map (category) =>
                selected = @selected(category.id)

                rootId = category.get 'root'

                id: category.get 'id'
                name: category.getText 'name'
                classes: classes(category).join " "
                has_children: category.attributes.children.length > 0
                unit_count: category.attributes.unit_count or 1
                selected: selected
                root_id: rootId
                show_icon_classes: @getShowIconClasses selected, rootId

            parentItem = {}
            back = null

            if @collection.chosenService
                back = @collection.chosenService.get('parent') or 'root'
                parentItem.name = @collection.chosenService.getText 'name'
                parentItem.rootId = @collection.chosenService.get 'root'

            data =
                back: back
                parent_item: parentItem
                list_items: listItems
                breadcrumbs: _.initial @breadcrumbs # everything but the last crumb

        onRender: ->
            $target = null
            if @collection.chosenService
                $target = @$el.find('li.service.parent.header-item')
            else
                $target = @$el.find('li.service').first()
            _.defer =>
                $target
                .focus()
                .addClass('autofocus')
                .on 'blur', () ->
                    $target.removeClass('autofocus')


define [
    'underscore',
    'backbone.marionette',
    'app/jade',
    'app/animations'
], (
    _,
    Marionette,
    jade,
    animations
) ->

    class SidebarRegion extends Marionette.Region

        SUPPORTED_ANIMATIONS = ['left', 'right']

        _trigger: (eventName, view) =>
            Marionette.triggerMethod.call(@, eventName, view)
            if _.isFunction view.triggerMethod
                view.triggerMethod eventName
            else
                Marionette.triggerMethod.call(view, eventName)

        show: (view, options) =>
            showOptions = options or {}
            @ensureEl()
            isViewClosed = view.isClosed or _.isUndefined(view.$el)
            isDifferentView = view != @currentView
            preventClose =  !!showOptions.preventClose
            _shouldCloseView = not preventClose and isDifferentView
            animationType = showOptions.animationType
            $oldContent = @currentView?.$el

            shouldAnimate = $oldContent?.length and animationType in SUPPORTED_ANIMATIONS and view.template?

            # RENDER WITH ANIMATIONS
            # ----------------------
            if shouldAnimate
                data = view.serializeData?() or {}
                templateString = jade.template view.template, data
                $container = @$el
                $newContent = view.$el.append($(templateString))

                @_trigger('before:render', view)
                @_trigger('before:show', view)

                animationCallback = =>
                    @close() if _shouldCloseView
                    @currentView = view
                    @_trigger('render', view)
                    @_trigger('show', view)

                animations.render($container, $oldContent, $newContent, animationType, animationCallback)

            # RENDER WITHOUT ANIMATIONS
            # -------------------------
            else
                # Close the old view
                @close() if _shouldCloseView

                view.render()
                @_trigger('before:show', view)

                # Attach the view's Html to the region's el
                if isDifferentView or isViewClosed
                    @open view

                @currentView = view
                @_trigger('show', view)

            return @

        # Close the currentView
        close: ->
            view = @currentView
            return if not view or view.isClosed

            # call 'close' or 'remove', depending on which is found
            if view.close
                view.close()
            else if view.remove
                view.remove()

            Marionette.triggerMethod.call(@, 'close', view)
            delete @currentView

    return SidebarRegion

define [
    'app/p13n',
    'app/jade',
    'app/views/base',
], (
    p13n,
    jade,
    base
)  ->

    class TitleView extends base.SMItemView
        className:
            'title-control'
        render: =>
            @el.innerHTML = jade.template 'title-view', lang: p13n.getLanguage(), root: appSettings.url_prefix
            @el

    class LandingTitleView extends base.SMItemView
        template: 'landing-title-view'
        id: 'title'
        className: 'landing-title-control'
        initialize: ->
            @listenTo(app.vent, 'title-view:hide', @hideTitleView)
            @listenTo(app.vent, 'title-view:show', @unHideTitleView)
        serializeData: ->
            isHidden: @isHidden
            lang: p13n.getLanguage()
        hideTitleView: ->
            $('body').removeClass 'landing'
            @isHidden = true
            @render()
        unHideTitleView: ->
            $('body').addClass 'landing'
            @isHidden = false
            @render()

    TitleView: TitleView
    LandingTitleView: LandingTitleView

define [
    'i18next',
    'harvey',
    'app/p13n',
    'app/dateformat',
    'app/draw',
    'app/map-view',
    'app/views/base',
    'app/views/route',
    'app/views/accessibility'
], (
    i18n,
    _harvey,
    p13n,
    dateformat,
    draw,
    MapView,
    base,
    RouteView,
    {AccessibilityDetailsView: AccessibilityDetailsView}
)  ->

    class UnitDetailsView extends base.SMLayout
        id: 'details-view-container'
        className: 'navigation-element'
        template: 'details'
        regions:
            'routeRegion': '.section.route-section'
            'accessibilityRegion': '.section.accessibility-section'
            'eventsRegion': '.event-list'
            'feedbackRegion': '.feedback-list'
        events:
            'click .back-button': 'userClose'
            'click .icon-icon-close': 'userClose'
            'click .map-active-area': 'showMap'
            'click .show-map': 'showMap'
            'click .mobile-header': 'showContent'
            'click .show-more-events': 'showMoreEvents'
            'click .disabled': 'preventDisabledClick'
            'click .set-accessibility-profile': 'openAccessibilityMenu'
            'click .leave-feedback': 'leaveFeedbackOnAccessibility'
            'click .section.main-info .description .body-expander': 'toggleDescriptionBody'
            'show.bs.collapse': 'scrollToExpandedSection'
            'click .send-feedback': '_onClickSendFeedback'
        type: 'details'

        initialize: (options) ->
            @INITIAL_NUMBER_OF_EVENTS = 5
            @NUMBER_OF_EVENTS_FETCHED = 20
            @embedded = options.embedded
            @searchResults = options.searchResults
            @selectedUnits = options.selectedUnits
            @selectedPosition = options.selectedPosition
            @routingParameters = options.routingParameters
            @route = options.route
            @listenTo @searchResults, 'reset', @render

        _$getMobileHeader: ->
            @$el.find '.mobile-header'
        _$getDefaultHeader: ->
            @$el.find '.content .main-info .header'
        _hideHeader: ($header) ->
            $header.attr 'aria-hidden', 'true'
        _showHeader: ($header) ->
            $header.removeAttr 'aria-hidden'
        _attachMobileHeaderListeners: ->
            Harvey.attach '(max-width:767px)',
                on: =>
                    @_hideHeader @_$getDefaultHeader()
                    @_showHeader @_$getMobileHeader()
            Harvey.attach '(min-width:768px)',
                on: =>
                    @_hideHeader @_$getMobileHeader()
                    @_showHeader @_$getDefaultHeader()
        _onClickSendFeedback: (ev) ->
            app.commands.execute 'composeFeedback', @model
        onRender: ->
            # Events
            #
            if @model.eventList.isEmpty()
                @listenTo @model.eventList, 'reset', (list) =>
                    @updateEventsUi(list.fetchState)
                    @renderEvents(list)
                @model.eventList.pageSize = @INITIAL_NUMBER_OF_EVENTS
                @model.getEvents()
                @model.eventList.pageSize = @NUMBER_OF_EVENTS_FETCHED
                @model.getFeedback()
            else
                @updateEventsUi(@model.eventList.fetchState)
                @renderEvents(@model.eventList)

            if @model.feedbackList.isEmpty()
                @listenTo @model.feedbackList, 'reset', (list) =>
                    @renderFeedback @model.feedbackList
            else
                @renderFeedback @model.feedbackList

            @accessibilityRegion.show new AccessibilityDetailsView
                model: @model
            @routeRegion.show new RouteView
                model: @model
                route: @route
                parentView: @
                routingParameters: @routingParameters
                selectedUnits: @selectedUnits
                selectedPosition: @selectedPosition

            app.vent.trigger 'site-title:change', @model.get('name')
            @_attachMobileHeaderListeners()

            markerCanvas = @$el.find('#details-marker-canvas').get(0)
            markerCanvasMobile = @$el.find('#details-marker-canvas-mobile').get(0)
            context = markerCanvas.getContext('2d')
            contextMobile = markerCanvasMobile.getContext('2d')
            size = 40
            color = app.colorMatcher.unitColor(@model) or 'rgb(0, 0, 0)'
            id = 0
            rotation = 90

            marker = new draw.Plant size, color, id, rotation
            marker.draw context
            marker.draw contextMobile

            _.defer => @$el.find('a').first().focus()

        updateEventsUi: (fetchState) =>
            $eventsSection = @$el.find('.events-section')

            # Update events section short text count.
            if fetchState.count
                shortText = i18n.t 'sidebar.event_count',
                    count: fetchState.count
            else
                # Handle no events -cases.
                shortText = i18n.t('sidebar.no_events')
                @$('.show-more-events').hide()
                $eventsSection.find('.collapser').addClass('disabled')
            $eventsSection.find('.short-text').text(shortText)

            # Remove show more button if all events are visible.
            if !fetchState.next and @model.eventList.length == @eventsRegion.currentView?.collection.length
                @$('.show-more-events').hide()

        userClose: (event) ->
            event.stopPropagation()
            app.commands.execute 'clearSelectedUnit'
            unless @searchResults.isEmpty()
                app.commands.execute 'search', @searchResults.query
            @trigger 'user:close'

        preventDisabledClick: (event) ->
            event.preventDefault()
            event.stopPropagation()

        showMap: (event) ->
            event.preventDefault()
            @$el.addClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: true

        showContent: (event) ->
            event.preventDefault()
            @$el.removeClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: false

        getTranslatedProvider: (providerType) ->
            SUPPORTED_PROVIDER_TYPES = [101, 102, 103, 104, 105]
            if providerType in SUPPORTED_PROVIDER_TYPES
                i18n.t("sidebar.provider_type.#{ providerType }")
            else
                ''

        serializeData: ->
            embedded = @embedded
            data = @model.toJSON()
            data.provider = @getTranslatedProvider @model.get 'provider_type'
            unless @searchResults.isEmpty()
                data.back_to = i18n.t 'sidebar.back_to.search'
            MAX_LENGTH = 20
            description = data.description
            if description
                words = description.split /[ ]+/
                if words.length > MAX_LENGTH + 1
                    data.description_ingress = words[0...MAX_LENGTH].join ' '
                    data.description_body = words[MAX_LENGTH...].join ' '
                else
                    data.description_ingress = description

            data.embedded_mode = embedded
            data.feedback_count = @model.feedbackList.length
            data

        renderEvents: (events) ->
            if events?
                unless events.isEmpty()
                    @$el.find('.section.events-section').removeClass 'hidden'
                    @eventsRegion.show new EventListView
                        collection: events

        _feedbackSummary: (feedbackItems) ->
            count = feedbackItems.size()
            if count
                i18n.t 'feedback.count', count: count
            else
                ''

        renderFeedback: (feedbackItems) ->
            if @model.get('organization') != 91
                return
            if feedbackItems?
                feedbackItems.unit = @model
                feedbackSummary = @_feedbackSummary feedbackItems
                $feedbackSection = @$el.find('.feedback-section')
                $feedbackSection.find('.short-text').text feedbackSummary
                $feedbackSection.find('.feedback-count').text feedbackSummary
                @feedbackRegion.show new FeedbackListView
                    collection: feedbackItems

        showMoreEvents: (event) ->
            event.preventDefault()
            options =
                spinnerOptions:
                    container: @$('.show-more-events').get(0)
                    hideContainerContent: true
            if @model.eventList.length <= @INITIAL_NUMBER_OF_EVENTS
                @model.getEvents({}, options)
            else
                options.success = =>
                    @updateEventsUi(@model.eventList.fetchState)
                @model.eventList.fetchNext(options)

        toggleDescriptionBody: (ev) ->
            $target = $(ev.currentTarget)
            $target.toggle()
            $target.closest('.description').find('.body').toggle()

        scrollToExpandedSection: (event) ->
            $container = @$el.find('.content').first()
            # Don't scroll if route leg is expanded.
            return if $(event.target).hasClass('steps')
            $section = $(event.target).closest('.section')
            scrollTo = $container.scrollTop() + $section.position().top
            $('#details-view-container .content').animate(scrollTop: scrollTo)

        openAccessibilityMenu: (event) ->
            event.preventDefault()
            p13n.trigger 'user:open'


    class EventListRowView extends base.SMItemView
        tagName: 'li'
        template: 'event-list-row'
        events:
            'click .show-event-details': 'showEventDetails'

        serializeData: ->
            startTime = @model.get 'start_time'
            endTime = @model.get 'end_time'
            formattedDatetime = dateformat.humanizeEventDatetime(
                startTime, endTime, 'small')
            name: p13n.getTranslatedAttr(@model.get 'name')
            datetime: formattedDatetime
            info_url: p13n.getTranslatedAttr(@model.get 'info_url')

        showEventDetails: (event) ->
            event.preventDefault()
            app.commands.execute 'selectEvent', @model

    class EventListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'events'
        itemView: EventListRowView
        initialize: (opts) ->
            @parent = opts.parent

    class FeedbackItemView extends base.SMItemView
        tagName: 'li'
        template: 'feedback-list-row'
        initialize: (options) ->
            @unit = options.unit
        serializeData: ->
            data = super()
            data.unit = @unit.toJSON()
            data

    class FeedbackListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'feedback'
        itemView: FeedbackItemView
        itemViewOptions: ->
            unit: @collection.unit

    UnitDetailsView


define [
    'app/draw',
    'leaflet',
    'leaflet.markercluster',
    'underscore',
    'jquery',
    'backbone',
    'app/jade'
], (
    draw,
    leaflet,
    markercluster,
    _,
    $,
    Backbone,
    jade
) ->

    anchor = (size) ->
        x = size.x/3 + 5
        y = size.y/2 + 16
        new L.Point x, y

    SMMarker = L.Marker
    REDUCED_OPACITY = 1

    initializer = ->
        # BEGIN hack to enable transparent markers
        REDUCED_OPACITY = 0.5
        OriginalMarkerCluster = L.MarkerCluster
        SMMarkerCluster = L.MarkerCluster.extend
            setOpacity: (opacity) ->
                children = @getAllChildMarkers()
                reducedProminence = false
                if children.length
                    reducedProminence = children[0].unit?.collection?.hasReducedPriority()
                if reducedProminence and opacity == 1
                    opacity = REDUCED_OPACITY
                OriginalMarkerCluster::setOpacity.call @, opacity
        L.MarkerCluster = SMMarkerCluster

        SMMarker = L.Marker.extend
            setOpacity: (opacity) ->
                if @options.reducedProminence and opacity == 1
                    opacity = REDUCED_OPACITY
                L.Marker::setOpacity.call @, opacity
        # END hack
    createMarker = (args...) ->
        new SMMarker args...

    CanvasIcon = L.Icon.extend
        initialize: (@dimension, options) ->
            @options.iconSize = new L.Point @dimension, @dimension
            @options.iconAnchor = @iconAnchor()
            @options.reducedProminence = options.reducedProminence
            @options.pixelRatio = (el) ->
                context = el.getContext('2d')
                devicePixelRatio = window.devicePixelRatio || 1
                backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1
                return devicePixelRatio / backingStoreRatio
        options:
            className: 'leaflet-canvas-icon'
        setupCanvas: ->
            el = document.createElement 'canvas'
            context = el.getContext('2d')
            # Set ratio based on device dpi
            ratio = @options.pixelRatio(el)
            # If the IE Canvas polyfill is installed, the element needs to be specially
            # initialized.
            if G_vmlCanvasManager?
                G_vmlCanvasManager.initElement el
            @_setIconStyles el, 'icon'
            s = @options.iconSize
            # Set el width based on device dpi
            el.width = s.x * ratio
            el.height = s.y * ratio
            el.style.width = s.x + 'px'
            el.style.height = s.y + 'px'
            # Scale down to normal
            context.scale(ratio, ratio)
            if @options.reducedProminence
                L.DomUtil.setOpacity el, REDUCED_OPACITY
            el
        createIcon: ->
            el = @setupCanvas()
            @draw el.getContext('2d')
            el
        createShadow: ->
            return null
        iconAnchor: ->
            anchor @options.iconSize

    CirclePolygon = L.Polygon.extend
        initialize: (latLng, radius, options) ->
            @circle = L.circle latLng, radius
            latLngs = @_calculateLatLngs()
            L.Polygon.prototype.initialize.call(@, [latLngs], options);
        _calculateLatLngs: ->
            bounds = @circle.getBounds()
            north = bounds.getNorth()
            east = bounds.getEast()
            center = @circle.getLatLng()
            lngRadius = east - center.lng
            latRadius = north - center.lat
            STEPS = 180
            for i in [0 ... STEPS]
                rad = (2 * i * Math.PI) / STEPS
                [center.lat + Math.sin(rad) * latRadius
                 center.lng + Math.cos(rad) * lngRadius]

    PlantCanvasIcon: CanvasIcon.extend
        initialize: (@dimension, @color, id, options) ->
            CanvasIcon.prototype.initialize.call this, @dimension, options
            @plant = new draw.Plant @dimension, @color, id
        draw: (ctx) ->
            @plant.draw ctx

    PointCanvasIcon: CanvasIcon.extend
        initialize: (@dimension, @color, id) ->
            CanvasIcon.prototype.initialize.call this, @dimension
            @drawer = new draw.PointPlant @dimension, @color, 2
        draw: (ctx) ->
            @drawer.draw ctx

    CanvasClusterIcon: CanvasIcon.extend
        initialize: (@count, @dimension, @colors, id, options) ->
            CanvasIcon.prototype.initialize.call this, @dimension, options
            @options.iconSize = new L.Point @dimension + 30, @dimension + 30
            if @count > 5
                @count = 5
            rotations = [130,110,90,70,50]
            translations = [[0,5],[10, 7],[12,8],[15,10],[5, 12]]
            @plants = _.map [1..@count], (i) =>
                new draw.Plant(@dimension, @colors[(i-1) % @colors.length],
                    id, rotations[i-1], translations[i-1])
        draw: (ctx) ->
            for plant in @plants
                plant.draw ctx

    PointCanvasClusterIcon: CanvasIcon.extend
        initialize: (count, @dimension, @colors, id) ->
            CanvasIcon.prototype.initialize.call this, @dimension
            @count = (Math.min(20, count) / 5) * 5
            @radius = 2
            range = =>
                @radius + Math.random() * (@dimension - 2 * @radius)
            @positions = _.map [1..@count], (i) =>
                [range(), range()]
            @clusterDrawer = new draw.PointCluster @dimension, @colors, @positions, @radius
        draw: (ctx) ->
            @clusterDrawer.draw ctx

    LeftAlignedPopup: L.Popup.extend
        _updatePosition: ->
            if !this._map
                return

            pos = this._map.latLngToLayerPoint(this._latlng)
            animated = this._animated
            offset = L.point(this.options.offset)

            properOffset =
                x: 15
                y: -27

            if animated
                pos.y = pos.y + properOffset.y
                pos.x = pos.x + properOffset.x
                L.DomUtil.setPosition(this._container, pos);

            this._containerBottom = -offset.y - (if animated then 0 else pos.y + properOffset.y)
            this._containerLeft = offset.x + (if animated then 0 else pos.x + properOffset.x)

            # bottom position the popup in case the height of the popup changes (images loading etc)
            this._container.style.bottom = this._containerBottom + 'px';
            this._container.style.left = this._containerLeft + 'px';

    ControlWrapper: L.Control.extend
        initialize: (@view, options) ->
            L.Util.setOptions @, options
        onAdd: (map) ->
            @view.render()

    initializer: initializer
    createMarker: createMarker
    CirclePolygon: CirclePolygon

//
(function() {
  var __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function() {
    return {
      mixOf: function() {
        var Mixed, base, mixins;
        base = arguments[0], mixins = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return Mixed = (function(_super) {
          var method, mixin, name, _i, _ref;

          __extends(Mixed, _super);

          function Mixed() {
            return Mixed.__super__.constructor.apply(this, arguments);
          }

          for (_i = mixins.length - 1; _i >= 0; _i += -1) {
            mixin = mixins[_i];
            _ref = mixin.prototype;
            for (name in _ref) {
              method = _ref[name];
              Mixed.prototype[name] = method;
            }
          }

          Mixed;

          return Mixed;

        })(base);
      },
      resolveImmediately: function() {
        return $.Deferred().resolve().promise();
      },
      withDeferred: function(callback) {
        var deferred;
        deferred = $.Deferred();
        callback(deferred);
        return deferred.promise();
      },
      pad: function(number) {
        var pad, str;
        str = "" + number;
        pad = "00000";
        return pad.substring(0, pad.length - str.length) + str;
      }
    };
  });

}).call(this);

//

define [
    'underscore',
    'raven',
    'backbone',
    'app/models'
], (
    _,
    Raven,
    Backbone,
    models
) ->

    # This module is a temporary solution to fetch pre-generated
    # accessibility sentences before we can access all the data allowing
    # them to be generated on demand.

    BASE_URL = 'http://www.hel.fi/palvelukarttaws/rest/v3/unit/'
    LANGUAGES = ['fi', 'sv', 'en']
    TIMEOUT = 10000

    _buildTranslatedObject = (data, base) ->
        _.object _.map(LANGUAGES, (lang) ->
            [lang, data["#{base}_#{lang}"]])

    currentId = 0
    ids = {}
    _generateId = (content) ->
        unless content of ids
            ids[content] = currentId
            currentId += 1
        ids[content]

    _parse = (data) ->
        sentences = { }
        groups = { }
        _.each data.accessibility_sentences, (sentence) ->
            group = _buildTranslatedObject sentence, 'sentence_group'
            key = _generateId group.fi
            groups[key] = group
            unless key of sentences
                sentences[key] = []
            sentences[key].push _buildTranslatedObject(sentence, 'sentence')
        groups:
            groups
        sentences:
            sentences

    fetchAccessibilitySentences = (unit, callback) ->
        args =
            dataType: 'jsonp'
            url: BASE_URL + unit.id
            jsonpCallback: 'jcbAsc'
            cache: true
            success: (data) ->
                callback _parse(data)
            timeout: TIMEOUT
            error: (jqXHR, errorType, exception) ->
                context = {
                    tags:
                        type: 'helfi_rest_api'
                    extra:
                        error_type: errorType
                        jqXHR: jqXHR
                }

                if errorType == 'timeout'
                    Raven.captureException(
                        new Error("Timeout of #{TIMEOUT}ms reached for #{BASE_URL+unit.id}"),
                        context)
                else
                    Raven.captureException exception, context
                callback error: true
        @xhr = $.ajax args

    fetch:
        fetchAccessibilitySentences

"use strict"

define [
    'underscore',
    'backbone'
], (
    _,
    Backbone
) ->

    class Accessibility
        constructor: ->
            _.extend @, Backbone.Events
            #setTimeout @_requestData, 3000
            @_requestData()

        _requestData: =>
            settings =
                url: "#{appSettings.service_map_backend}/accessibility_rule/"
                success: (data) =>
                    @rules = data.rules
                    @messages = data.messages
                    @trigger 'change'
                error: (data) =>
                    throw new Error "Unable to retrieve accessibility data"
            Backbone.ajax settings
        _emitShortcoming: (rule, messages) ->
            if rule.msg == null or rule.msg not of @messages
                return
            msg = @messages[rule.msg]
            if msg?
                segment = rule.path[0]
                unless segment of messages
                    messages[segment] = []
                segmentMessages = messages[segment]
                requirementId = rule.requirement_id
                unless requirementId of segmentMessages
                    segmentMessages[requirementId] = []
                currentMessages = segmentMessages[requirementId]
                if rule.id == requirementId
                    # This is a top level requirement -
                    # only add top level message
                    # if there are no specific messages.
                    unless currentMessages.length
                        currentMessages.push msg
                else
                    currentMessages.push msg
            return

        _calculateShortcomings: (rule, properties, messages, level=None) ->
            if rule.operands[0] not instanceof Object
                op = rule.operands
                prop = properties[op[0]]
                # If the information is not supplied, pretend that everything
                # is fine.
                if not prop
                    return true
                val = op[1]
                if rule.operator == 'NEQ'
                    isOkay = prop != val
                else if rule.operator == 'EQ'
                    isOkay = prop == val
                else
                    throw new Error "invalid operator #{rule.operator}"
                if not isOkay
                    @_emitShortcoming rule, messages
                return isOkay

            retValues = []
            for op in rule.operands
                isOkay = @_calculateShortcomings op, properties, messages, level=level+1
                retValues.push isOkay

            if rule.operator not in ['AND', 'OR']
                throw new Error "invalid operator #{rule.operator}"
            if rule.operator == 'AND' and false not in retValues
                return true
            if rule.operator == 'OR' and true in retValues
                return true

            @_emitShortcoming rule, messages
            return false

        getShortcomings: (properties, profile) ->
            if not @rules?
                return status: 'pending'
            propById = {}
            for p in properties
                propById[p.variable] = p.value
            messages = {}
            rule = @rules[profile]
            level = 0
            @_calculateShortcomings rule, propById, messages, level=level
            status: 'complete'
            messages: messages

        getTranslatedShortcomings: (profiles, model) ->
            shortcomings = {}
            seen = {}
            for pid in _.keys profiles
                shortcoming = @getShortcomings model.get('accessibility_properties'), pid
                if shortcoming.status != 'complete'
                    return status: 'pending', results: {}
                if _.keys(shortcoming.messages).length
                    for segmentId, segmentMessages of shortcoming.messages
                        shortcomings[segmentId] = shortcomings[segmentId] or {}
                        for requirementId, messages of segmentMessages
                            gatheredMessages = []
                            for msg in messages
                                translated = p13n.getTranslatedAttr msg
                                if translated not of seen
                                    seen[translated] = true
                                    gatheredMessages.push msg
                            if gatheredMessages.length
                                shortcomings[segmentId][requirementId] = gatheredMessages
            status: 'success'
            results: shortcomings

    return new Accessibility

define ->

    FINNISH_ALPHABET = 'abcdefghijklmnopqrstuvwxyzåäö'

    # Thank you
    # http://stackoverflow.com/questions/3630645/how-to-compare-utf-8-strings-in-javascript/3633725#3633725
    alpha = (direction, caseSensitive, alphabetOrder = FINNISH_ALPHABET) ->
        compareLetters = (a, b) ->
            [ia, ib] = [alphabetOrder.indexOf(a), alphabetOrder.indexOf(b)]
            if ia == -1 or ib == -1
                if ib != -1
                    return a > 'a'
                if ia != -1
                    return 'a' > b
                return a > b
            ia > ib
        direction = direction or 1
        (a, b) ->
            length = Math.min a.length, b.length
            caseSensitive = caseSensitive or false
            if !caseSensitive
                a = a.toLowerCase()
                b = b.toLowerCase()
            pos = 0
            while a.charAt(pos) == b.charAt(pos) and pos < length
                pos++

            if compareLetters a.charAt(pos), b.charAt(pos)
                direction
            else
                -direction

    #a.sort alpha('ABCDEFGHIJKLMNOPQRSTUVWXYZaàâäbcçdeéèêëfghiïîjklmnñoôöpqrstuûüvwxyÿz')
    makeComparator: alpha

define [
    'TweenLite'
], (
    TweenLite
) ->

    HORIZONTAL_MARGIN = 4
    DURATION_IN_SECONDS = 0.3

    getStartingLeft = (contentWidth, animation) ->
        switch animation
            when 'left' then contentWidth + HORIZONTAL_MARGIN
            when 'right' then -contentWidth - HORIZONTAL_MARGIN
            else 0

    getStartingTop = (contentHeight, animation) ->
        switch animation
            when 'left' then -contentHeight
            when 'right' then -contentHeight
            else 0

    getMoveDistanceInPx = (distance, animation) ->
        switch animation
            when 'left' then "-=#{distance}px"
            when 'right' then "+=#{distance}px"
            else 0

    render = ($container, $oldContent, $newContent, animation, callback) ->
        # Add new content to DOM after the old content.
        $container.append $newContent

        # Measurements - calculate how much the new content needs to be moved.
        contentHeight = $oldContent.height()
        contentWidth = $oldContent.width()
        moveDistance = getMoveDistanceInPx contentWidth + HORIZONTAL_MARGIN, animation

        # Move the new content to correct starting position.
        $newContent.css(
            'position': 'relative'
            'left': getStartingLeft(contentWidth, animation)
            'top': getStartingTop(contentHeight, animation)
        )

        # Make sure the old old content is has position: relative for animations.
        $oldContent.css('position': 'relative')

        # Animate old content and new content.
        TweenLite.to([$oldContent, $newContent], DURATION_IN_SECONDS, {
            left: moveDistance,
            ease: Power2.easeOut,
            onComplete: () ->
                $oldContent.remove()
                $newContent.css 'left': 0, 'top': 0
                callback?()
        })

    return {
        render: render
    }

config =
    baseUrl: appSettings.static_path + 'vendor'
    paths:
        app: '../js'
    shim:
        bootstrap:
            deps: ['jquery']
        backbone:
            deps: ['underscore', 'jquery']
            exports: 'Backbone'
        'typeahead.bundle':
            deps: ['jquery']
        TweenLite:
            deps: ['CSSPlugin', 'EasePack']
        'leaflet.markercluster':
            deps: ['leaflet']
        'leaflet.activearea':
            deps: ['leaflet']
        'bootstrap-datetimepicker':
            deps: ['bootstrap']
        'bootstrap-tour':
            deps: ['bootstrap']
        'iexhr':
            deps: ['jquery']
        'leaflet.snogylop':
            deps: ['leaflet']
    config:
        'app/p13n': localStorageEnabled: true

requirejs.config config

requirejs ['leaflet'], (L) ->
    # Allow calling original getBounds when needed.
    # (leaflet.activearea overrides getBounds)
    L.Map.prototype._originalGetBounds = L.Map.prototype.getBounds

DEBUG_STATE = appSettings.debug_state
VERIFY_INVARIANTS = appSettings.verify_invariants

window.getIeVersion = ->
    isInternetExplorer = ->
        window.navigator.appName is "Microsoft Internet Explorer"

    if not isInternetExplorer()
        return false

    matches = new RegExp(" MSIE ([0-9]+)\\.([0-9])").exec window.navigator.userAgent
    return parseInt matches[1]

if appSettings.sentry_url
    config = {}
    if appSettings.sentry_disable
        config.shouldSendCallback = -> false
    requirejs ['raven'], (Raven) ->
        Raven.config(appSettings.sentry_url, config).install()
        Raven.setExtraContext gitCommit: appSettings.git_commit_id

# Disable Raven thrown errors on local
else
    requirejs ['raven'], (Raven) ->
        Raven.debug = false;

requirejs [
    'app/models',
    'app/p13n',
    'app/map-view',
    'app/landing',
    'app/color',
    'app/tour',
    'backbone',
    'backbone.marionette',
    'jquery',
    'i18next',
    'app/uservoice',
    'app/transit',
    'app/debug',
    'iexhr',
    'app/views/service-cart',
    'app/views/navigation',
    'app/views/personalisation',
    'app/views/language-selector',
    'app/views/title',
    'app/views/feedback-form',
    'app/views/feedback-confirmation',
    'app/views/feature-tour-start',
    'app/views/service-map-disclaimers',
    'app/views/exporting',
    'app/base',
    'app/widgets',
    'app/control',
    'app/router'
],
(
    Models,
    p13n,
    MapView,
    landingPage,
    ColorMatcher,
    tour,
    Backbone,
    Marionette,
    $,
    i18n,
    uservoice,
    transit,
    debug,
    iexhr,
    ServiceCartView,
    NavigationLayout,
    PersonalisationView,
    LanguageSelectorView,
    titleViews,
    FeedbackFormView,
    FeedbackConfirmationView,
    TourStartButton,
    disclaimers,
    ExportingView,
    sm,
    widgets,
    BaseControl,
    BaseRouter
) ->

    LOG = debug.log

    isFrontPage = =>
        Backbone.history.fragment == ''

    class AppControl extends BaseControl
        initialize: (appModels) ->
            super appModels
            #_.extend @, Backbone.Events

            @route = appModels.route
            # Selected events (always of length one)
            @selectedEvents = appModels.selectedEvents

            @_resetPendingFeedback appModels.pendingFeedback

            @listenTo p13n, 'change', (path, val) ->
                if path[path.length - 1] == 'city'
                    @_reFetchAllServiceUnits()

            if DEBUG_STATE
                @eventDebugger = new debug.EventDebugger appModels

        _resetPendingFeedback: (o) ->
            if o?
                @pendingFeedback = o
            else
                @pendingFeedback = new Models.FeedbackMessage()
            appModels.pendingFeedback = @pendingFeedback
            @listenTo appModels.pendingFeedback, 'sent', =>
                app.getRegion('feedbackFormContainer').show new FeedbackConfirmationView(appModels.pendingFeedback.get('unit'))

        atMostOneIsSet: (list) ->
            _.filter(list, (o) -> o.isSet()).length <= 1

        _verifyInvariants: ->
            unless @atMostOneIsSet [@services, @searchResults]
                return new Error "Active services and search results are mutually exclusive."
            unless @atMostOneIsSet [@selectedPosition, @selectedUnits]
                return new Error "Selected positions/units/events are mutually exclusive."
            unless @atMostOneIsSet [@searchResults, @selectedPosition]
                return new Error "Search results & selected position are mutually exclusive."
            return null

        reset: () ->
            @_setSelectedUnits()
            @_clearRadius()
            @selectedPosition.clear()
            @selectedDivision.clear()
            @route.clear()
            @units.reset []
            @services.reset [], silent: true
            @selectedEvents.reset []
            @_resetSearchResults()

        isStateEmpty: () ->
            @selectedPosition.isEmpty() and
            @services.isEmpty() and
            @selectedEvents.isEmpty()

        _resetSearchResults: ->
            @searchResults.query = null
            @searchResults.reset []
            if @selectedUnits.isSet()
                @units.reset [@selectedUnits.first()]
            else if not @units.isEmpty()
                @units.reset()

        clearUnits: (opts) ->
            # Only clears selected units, and bbox units,
            # not removed service units nor search results.
            @route.clear()
            if @searchResults.isSet()
                return
            if opts?.all
                @units.clearFilters()
                @units.reset [], bbox: true
                return
            if @services.isSet()
                return
            if @selectedPosition.isSet() and 'distance' of @units.filters
                return
            if opts?.bbox == false and 'bbox' of @units.filters
                return
            else if opts?.bbox and 'bbox' not of @units.filters
                return
            @units.clearFilters()
            resetOpts = bbox: opts?.bbox
            if opts.silent
                resetOpts.silent = true
            if opts?.bbox
                resetOpts.noRefit = true
            if @selectedUnits.isSet()
                @units.reset [@selectedUnits.first()], resetOpts
            else
                @units.reset [], resetOpts

        highlightUnit: (unit) ->
            @units.trigger 'unit:highlight', unit

        clearFilters: ->
            @units.clearFilters()

        clearSelectedUnit: ->
            @route.clear()
            @selectedUnits.each (u) -> u.set 'selected', false
            @_setSelectedUnits()
            @clearUnits all: false, bbox: false
            sm.resolveImmediately()

        selectEvent: (event) ->
            @_clearRadius()
            unit = event.getUnit()
            select = =>
                event.set 'unit', unit
                if unit?
                    @setUnit unit
                @selectedEvents.reset [event]
            if unit?
                unit.fetch
                    success: select
            else
                select()

        clearSelectedPosition: ->
            @selectedDivision.clear()
            @selectedPosition.clear()
            sm.resolveImmediately()

        resetPosition: (position) ->
            unless position?
                position = @selectedPosition.value()
                unless position?
                    position = new models.CoordinatePosition
                        isDetected: true
            position.clear()
            @listenToOnce p13n, 'position', (position) =>
                @selectPosition position
            p13n.requestLocation position

        clearSelectedEvent: ->
            @_clearRadius()
            @selectedEvents.set []
        removeUnit: (unit) ->
            @units.remove unit
            if unit == @selectedUnits.first()
                @clearSelectedUnit()
        removeUnits: (units) ->
            @units.remove units,
                silent: true
            @units.trigger 'batch-remove',
                removed: units

        _clearRadius: ->
            pos = @selectedPosition.value()
            if pos?
                hasFilter = pos.get 'radiusFilter'
                if hasFilter?
                    pos.set 'radiusFilter', null
                    @units.reset []

        _reFetchAllServiceUnits: ->
            if @services.length > 0
                @units.reset []
                @services.each (s) => @_fetchServiceUnits(s)


        removeService: (serviceId) ->
            service = @services.get serviceId
            @services.remove service
            unless service.get('units')?
                return
            otherServices = @services.filter (s) => s != service
            unitsToRemove = service.get('units').reject (unit) =>
                @selectedUnits.get(unit)? or
                _(otherServices).find (s) => s.get('units').get(unit)?
            @removeUnits unitsToRemove
            if @services.size() == 0
                if @selectedPosition.isSet()
                    @selectPosition @selectedPosition.value()
                    @selectedPosition.trigger 'change:value', @selectedPosition, @selectedPosition.value()
            sm.resolveImmediately()


        clearSearchResults: () ->
            @searchResults.query = null
            if not @searchResults.isEmpty()
                @_resetSearchResults()
            sm.resolveImmediately()

        closeSearch: ->
            if @isStateEmpty() then @home()
            sm.resolveImmediately()

        composeFeedback: (unit) ->
            app.getRegion('feedbackFormContainer').show new FeedbackFormView model: @pendingFeedback, unit: unit
            $('#feedback-form-container').on 'shown.bs.modal', ->
                $(@).children().attr('tabindex', -1).focus()
            $('#feedback-form-container').modal('show')

        closeFeedback: ->
            @_resetPendingFeedback()
            _.defer => app.getRegion('feedbackFormContainer').reset()

        showServiceMapDescription: ->
            app.getRegion('feedbackFormContainer').show new disclaimers.ServiceMapDisclaimersView()
            $('#feedback-form-container').modal('show')

        home: ->
            @reset()

    app = new Marionette.Application()

    appModels =
        services: new Models.ServiceList()
        selectedServices: new Models.ServiceList()
        units: new Models.UnitList null, setComparator: true
        selectedUnits: new Models.UnitList()
        selectedEvents: new Models.EventList()
        searchResults: new Models.SearchList [], pageSize: appSettings.page_size
        searchState: new Models.WrappedModel()
        route: new transit.Route()
        routingParameters: new Models.RoutingParameters()
        selectedPosition: new Models.WrappedModel()
        selectedDivision: new Models.WrappedModel()
        divisions: new models.AdministrativeDivisionList
        pendingFeedback: new Models.FeedbackMessage()

    cachedMapView = null
    makeMapView = (mapOpts) ->
        unless cachedMapView
            opts =
                units: appModels.units
                services: appModels.selectedServices
                selectedUnits: appModels.selectedUnits
                searchResults: appModels.searchResults
                selectedPosition: appModels.selectedPosition
                selectedDivision: appModels.selectedDivision
                route: appModels.route
                divisions: appModels.divisions
            cachedMapView = new MapView opts, mapOpts
            window.mapView = cachedMapView
            map = cachedMapView.map
            pos = appModels.routingParameters.pendingPosition
            pos.on 'request', (ev) => cachedMapView.requestLocation pos
            app.getRegion('map').show cachedMapView
            f = -> landingPage.clear()
            cachedMapView.map.addOneTimeEventListener
                'zoomstart': f
                'mousedown': f
            app.commands.execute 'setMapProxy', cachedMapView.getProxy()
        cachedMapView

    setSiteTitle = (routeTitle) ->
        # Sets the page title. Should be called when the view that is
        # considered the main view changes.
        title = "#{i18n.t('general.site_title')}"
        if routeTitle
            title = "#{p13n.getTranslatedAttr(routeTitle)} | " + title
        $('head title').text title

    class AppRouter extends BaseRouter
        initialize: (options) ->
            super options

            @appModels = options.models
            refreshServices = =>
                ids = @appModels.selectedServices.pluck('id').join ','
                if ids.length
                    "unit?service=#{ids}"
                else
                    if @appModels.selectedPosition.isSet()
                        @fragmentFunctions.selectPosition()
                    else
                        ""
            blank = => ""

            @fragmentFunctions =
                selectUnit: =>
                    id = @appModels.selectedUnits.first().id
                    "unit/#{id}"
                search: (params) =>
                    query = params[0]
                    "search?q=#{query}"
                selectPosition: =>
                    slug = @appModels.selectedPosition.value().slugifyAddress()
                    "address/#{slug}"
                addService: refreshServices
                removeService: refreshServices
                clearSelectedPosition: blank
                clearSelectedUnit: blank
                clearSearchResults: blank
                closeSearch: blank
                home: blank

        _getFragment: (commandString, parameters) ->
            @fragmentFunctions[commandString]?(parameters)

        navigateByCommand: (commandString, parameters) ->
            fragment = @_getFragment commandString, parameters
            if fragment?
                @navigate fragment
                p13n.trigger 'url'

        onPostRouteExecute: ->
            if isFrontPage() and not p13n.get('skip_tour') and not p13n.get('hide_tour')
                tour.startTour()

    app.addRegions
        navigation: '#navigation-region'
        personalisation: '#personalisation'
        exporting: '#exporting'
        languageSelector: '#language-selector'
        serviceCart: '#service-cart'
        landingLogo: '#landing-logo'
        logo: '#persistent-logo'
        map: '#app-container'
        tourStart: '#feature-tour-start'
        feedbackFormContainer: '#feedback-form-container'
        disclaimerContainer: '#disclaimers'

    app.addInitializer (opts) ->

        window.debugAppModels = appModels
        appModels.services.fetch
            data:
                level: 0

        appControl = new AppControl appModels
        router = new AppRouter models: appModels, controller: appControl, makeMapView: makeMapView
        appControl.router = router

        COMMANDS = [
            "addService",
            "removeService",

            "selectUnit",
            "highlightUnit",
            "clearSelectedUnit",

            "selectPosition",
            "clearSelectedPosition",
            "resetPosition"

            "selectEvent",
            "clearSelectedEvent",

            "toggleDivision",

            "clearFilters",

            "setUnits",
            "setUnit",
            "addUnitsWithinBoundingBoxes"

            "search",
            "clearSearchResults",
            "closeSearch",

            "setRadiusFilter"
            "home"

            "composeFeedback",
            "closeFeedback",

            "hideTour",
            "showServiceMapDescription",

            "setMapProxy"
        ]
        reportError = (position, command) ->
            e = appControl._verifyInvariants()
            if e
                message = "Invariant failed #{position} command #{command}: #{e.message}"
                LOG appModels
                e.message = message
                throw e

        commandInterceptor = (comm, parameters) ->
            appControl[comm].apply(appControl, parameters)?.done? =>
                unless parameters[0]?.navigate == false
                    router.navigateByCommand comm, parameters

        makeInterceptor = (comm) ->
            if DEBUG_STATE
                ->
                    LOG "COMMAND #{comm} CALLED"
                    commandInterceptor comm, arguments
                    LOG appModels
            else if VERIFY_INVARIANTS
                ->
                    LOG "COMMAND #{comm} CALLED"
                    reportError "before", comm
                    commandInterceptor comm, arguments
                    reportError "after", comm
            else
                ->
                    commandInterceptor comm, arguments

        for comm in COMMANDS
            @commands.setHandler comm, makeInterceptor(comm)

        navigation = new NavigationLayout
            serviceTreeCollection: appModels.services
            selectedServices: appModels.selectedServices
            searchResults: appModels.searchResults
            selectedUnits: appModels.selectedUnits
            selectedEvents: appModels.selectedEvents
            searchState: appModels.searchState
            route: appModels.route
            units: appModels.units
            routingParameters: appModels.routingParameters
            selectedPosition: appModels.selectedPosition

        @getRegion('navigation').show navigation
        @getRegion('landingLogo').show new titleViews.LandingTitleView
        @getRegion('logo').show new titleViews.TitleView

        personalisation = new PersonalisationView
        @getRegion('personalisation').show personalisation

        exportingView = new ExportingView()
        @getRegion('exporting').show exportingView

        languageSelector = new LanguageSelectorView
            p13n: p13n
        @getRegion('languageSelector').show languageSelector

        serviceCart = new ServiceCartView
            collection: appModels.selectedServices
        @getRegion('serviceCart').show serviceCart

        # The colors are dependent on the currently selected services.
        @colorMatcher = new ColorMatcher appModels.selectedServices

        f = -> landingPage.clear()
        $('body').one "keydown", f
        $('body').one "click", f

        Backbone.history.start
            pushState: true
            root: appSettings.url_prefix

        # Prevent empty anchors from appending a '#' to the URL bar but
        # still allow external links to work.
        $('body').on 'click', 'a', (ev) ->
            target = $(ev.currentTarget)
            if not target.hasClass('external-link') and not target.hasClass('force')
                ev.preventDefault()

        @listenTo app.vent, 'site-title:change', setSiteTitle

        showButton = =>
            tourButtonView = new TourStartButton()
            app.getRegion('tourStart').show tourButtonView
            @listenToOnce tourButtonView, 'close', => app.getRegion('tourStart').reset()
        if p13n.get('skip_tour')
            showButton()
        @listenTo p13n, 'tour-skipped', =>
            showButton()

        app.getRegion('disclaimerContainer').show new disclaimers.ServiceMapDisclaimersOverlayView

    app.addInitializer widgets.initializer

    window.app = app

    # We wait for p13n/i18next to finish loading before firing up the UI
    $.when(p13n.deferred).done ->
        $('html').attr 'lang', p13n.getLanguage()
        app.start()
        if isFrontPage()
            if p13n.get('first_visit')
                $('body').addClass 'landing'
        $('#app-container').attr 'class', p13n.get('map_background_layer')
        p13n.setVisited()
        uservoice.init(p13n.getLanguage())

define ->
    mixOf: (base, mixins...) ->
        class Mixed extends base
            for mixin in mixins by -1 # earlier mixins override later ones
                for name, method of mixin::
                    Mixed::[name] = method
            Mixed

    resolveImmediately: ->
        $.Deferred().resolve().promise()

    withDeferred: (callback) ->
        deferred = $.Deferred()
        callback deferred
        deferred.promise()

    pad: (number) ->
        str = "" + number
        pad = "00000"
        pad.substring(0, pad.length - str.length) + str


define ->

    class ColorMatcher
        @serviceColors:
            # Housing and environment
            50000: [77,139,0]

            # Administration and economy
            50001: [192,79,220]

            # Culture and leisure
            50002: [252,173,0]

            # Maps, information services and communication
            50003: [154,0,0]

            # Teaching and education
            26412: [0,81,142]

            # Family and social services
            27918: [67,48,64]

            # Child daycare and pre-school education
            27718: [60,210,0]

            # Health care
            25000: [142,139,255]

            # Public safety
            26190: [240,66,0]

            # The following are not root services
            # in the simplified service tree
            # Legal protection and democracy
            #26244: [192,79,220]
            # Planning, real estate and construction
            #25142: [40,40,40]
            # Tourism and events
            #25954: [252,172,0]
            # Entrepreneurship, work and taxation
            #26098: [192,79,220]
            # Sports and physical exercise
            #28128: [252,173,0]

        constructor: (@selectedServices) ->
        @rgb: (r, g, b) ->
            return "rgb(#{r}, #{g}, #{b})"
        @rgba: (r, g, b, a) ->
            return "rgba(#{r}, #{g}, #{b}, #{a})"
        serviceColor: (service) ->
            @serviceRootIdColor service.get('root')
        serviceRootIdColor: (id) ->
            [r, g, b] = @constructor.serviceColors[id]
            @constructor.rgb(r, g, b)
        unitColor: (unit) ->
            roots = unit.get('root_services')
            if @selectedServices?
                rootService = _.find roots, (rid) =>
                    @selectedServices.find (s) ->
                        s.get('root') == rid
            unless rootService?
                rootService = roots[0]
            [r, g, b] = @constructor.serviceColors[rootService]
            @constructor.rgb(r, g, b)

    return ColorMatcher

define [
    'jquery',
    'backbone.marionette',
    'app/base',
    'app/models'
],
(
    $,
    Marionette,
    sm,
    Models
) ->

    PAGE_SIZE = appSettings.page_size

    class BaseControl extends Marionette.Controller
        initialize: (appModels) ->
            # Units currently on the map
            @units = appModels.units
            # Services in the cart
            @services = appModels.selectedServices
            # Selected units (always of length one)
            @selectedUnits = appModels.selectedUnits
            @selectedPosition = appModels.selectedPosition
            @searchResults = appModels.searchResults
            @divisions = appModels.divisions
            @selectedDivision = appModels.selectedDivision

        setMapProxy: (@mapProxy) ->

        setUnits: (units, filter) ->
            @services.set []
            @_setSelectedUnits()
            @units.reset units.toArray()
            if filter?
                @units.setFilter filter, true
            else
                @units.clearFilters()
            # Current cluster based map logic
            # requires batch reset signal.

        setUnit: (unit) ->
            @services.set []
            @units.reset [unit]

        getUnit: (id) ->
            return @units.get id

        _setSelectedUnits: (units, options) ->
            @selectedUnits.each (u) -> u.set 'selected', false
            if units?
                _(units).each (u) -> u.set 'selected', true
                @selectedUnits.reset units, options
            else
                if @selectedUnits.length
                    @selectedUnits.reset [], options

        selectUnit: (unit, opts) ->
            @selectedDivision.clear()
            @_setSelectedUnits? [unit], silent: true
            if opts?.replace
                @units.reset [unit]
                @units.clearFilters()
            else if not @units.contains unit
                @units.add unit
                @units.trigger 'reset', @units
            hasObject = (unit, key) ->
                o = unit.get(key)
                o? and typeof o == 'object'
            requiredObjects = ['department', 'municipality', 'services']
            unless _(requiredObjects).find((x)->!hasObject(unit, x))
                @selectedUnits.trigger 'reset', @selectedUnits
                sm.resolveImmediately()
            else
                unit.fetch
                    data: include: 'department,municipality,services'
                    success: => @selectedUnits.trigger 'reset', @selectedUnits

        addUnitsWithinBoundingBoxes: (bboxStrings, level) ->
            if level == 'none'
                return
            unless level?
                level = 'customer_service'
            bboxCount = bboxStrings.length
            if bboxCount > 4
                null
                # TODO: handle case.
            if @selectedPosition.value()?.get('radiusFilter')?
                return
            @units.clearFilters()
            getBbox = (bboxStrings) =>
                # Fetch bboxes sequentially
                if bboxStrings.length == 0
                    @units.setFilter 'bbox', true
                    @units.trigger 'finished',
                        keepViewport: true
                    return
                bboxString = _.first bboxStrings
                unitList = new models.UnitList null, forcedPriority: false
                opts = success: (coll, resp, options) =>
                    if unitList.length
                        @units.add unitList.toArray()
                    unless unitList.fetchNext(opts)
                        unitList.trigger 'finished',
                            keepViewport: true
                unitList.pageSize = PAGE_SIZE
                unitList.setFilter 'bbox', bboxString
                layer = p13n.get 'map_background_layer'
                unitList.setFilter 'bbox_srid', if layer in ['servicemap', 'accessible_map'] then 3067 else 3879
                unitList.setFilter 'only', 'name,location,root_services'
                if level?
                    unitList.setFilter 'level', level

                @listenTo unitList, 'finished', =>
                    getBbox _.rest(bboxStrings)
                unitList.fetch(opts)
            getBbox(bboxStrings)

        _clearRadius: ->
        clearSearchResults: ->
        clearUnits: ->
        reset: ->

        toggleDivision: (division) =>
            @_clearRadius()
            old = @selectedDivision.value()
            if old? then old.set 'selected', false
            if division == old
                @selectedDivision.clear()
            else
                @selectedDivision.wrap division
                division.set 'selected', true

        renderUnitById: (id) ->
            deferred = $.Deferred()
            unit = new Models.Unit id: id
            unit.fetch
                data:
                    include: 'department,municipality,services'
                success: =>
                    @setUnit unit
                    @selectUnit unit
                    deferred.resolve unit
            deferred.promise()

        selectPosition: (position) ->
            @clearSearchResults?()
            @_setSelectedUnits?()
            previous = @selectedPosition.value()
            if previous?.get('radiusFilter')?
                @units.reset []
                @units.clearFilters()
            if position == previous
                @selectedPosition.trigger 'change:value', @selectedPosition
            else
                @selectedPosition.wrap position
            sm.resolveImmediately()

        setRadiusFilter: (radius) ->
            @services.reset [], skip_navigate: true
            @units.reset []
            @units.clearFilters()
            @units.overrideComparatorKeys = [
                'distance_precalculated',
                'alphabetic',
                'alphabetic_reverse']
            @units.setComparator 'distance_precalculated'
            if @selectedPosition.isEmpty()
                return
            pos = @selectedPosition.value()
            pos.set 'radiusFilter', radius

            unitList = new models.UnitList [], pageSize: PAGE_SIZE
                .setFilter 'only', 'name,location,root_services'
                .setFilter 'include', 'services,accessibility_properties'
                .setFilter 'lat', pos.get('location').coordinates[1]
                .setFilter 'lon', pos.get('location').coordinates[0]
                .setFilter 'distance', radius
            opts =
                success: =>
                    @units.add unitList.toArray(), merge: true
                    @units.setFilter 'distance', radius
                    unless unitList.fetchNext opts
                        @units.trigger 'finished', refit: true
            unitList.fetch opts

        _addService: (service) ->
            @_clearRadius()
            @_setSelectedUnits()
            @services.add service
            if @services.length == 1
                # Remove possible units
                # that had been added through
                # other means than service
                # selection.
                @units.reset []
                @units.clearFilters()
                @units.setDefaultComparator()
                @clearSearchResults()

            if service.has 'ancestors'
                ancestor = @services.find (s) ->
                    s.id in service.get 'ancestors'
                if ancestor?
                    @removeService ancestor
            @_fetchServiceUnits service

        _fetchServiceUnits: (service) ->
            unitList = new models.UnitList [], pageSize: PAGE_SIZE, setComparator: true
                .setFilter('service', service.id)
                .setFilter('only', 'name,location,root_services')
                .setFilter('include', 'services,accessibility_properties')

            municipality = p13n.get 'city'
            if municipality
                unitList.setFilter 'municipality', municipality

            opts =
                # todo: re-enable
                #spinnerTarget: spinnerTarget
                success: =>
                    @units.add unitList.toArray(), merge: true
                    service.get('units').add unitList.toArray()
                    unless unitList.fetchNext opts
                        @units.overrideComparatorKeys = ['alphabetic', 'alphabetic_reverse', 'distance']
                        @units.setDefaultComparator()
                        @units.trigger 'finished', refit: true
                        service.get('units').trigger 'finished'

            unitList.fetch opts

        addService: (service) ->
            if service.has('ancestors')
                @_addService service
            else
                sm.withDeferred (deferred) =>
                    service.fetch
                        data: include: 'ancestors'
                        success: =>
                            @_addService(service).done =>
                                deferred.resolve()
        _search: (query) ->
            @_clearRadius()
            @selectedPosition.clear()
            @clearUnits all: true

            sm.withDeferred (deferred) =>
                if @searchResults.query == query
                    @searchResults.trigger 'ready'
                    deferred.resolve()
                    return

                if 'search' in _(@units.filters).keys()
                    @units.reset []

                unless @searchResults.isEmpty()
                    @searchResults.reset []
                opts =
                    success: =>
                        if _paq?
                            _paq.push ['trackSiteSearch', query, false, @searchResults.models.length]
                        @units.add @searchResults.filter (r) ->
                            r.get('object_type') == 'unit'
                        @units.setFilter 'search', true
                        unless @searchResults.fetchNext opts
                            @searchResults.trigger 'ready'
                            @units.trigger 'finished'
                            @services.set []
                            deferred.resolve()
                opts = @searchResults.search query, opts

        search: (query) ->
            unless query?
                query = @searchResults.query
            if query? and query.length > 0
                @_search query
            else
                sm.resolveImmediately()

        renderUnitsByServices: (serviceIdString) ->
            serviceIds = serviceIdString.split ','
            deferreds = _.map serviceIds, (id) =>
                @addService new models.Service id: id
            return $.when deferreds...

        _fetchDivisions: (divisionIds, callback) ->
            @divisions
                .setFilter 'ocd_id', divisionIds.join(',')
                .setFilter 'geometry', true
                .fetch success: callback

        _getLevel: (context, defaultLevel='none') ->
            context?.query?.level or defaultLevel

        _renderDivisions: (ocdIds, context) ->
            level = @_getLevel context, defaultLevel='none'
            sm.withDeferred (deferred) =>
                @_fetchDivisions ocdIds, =>
                    if level == 'none'
                        deferred.resolve()
                        return
                    if level != 'all'
                        @units.setFilter 'level', context.query.level
                    @units
                        .setFilter 'division', ocdIds.join(',')
                        .setFilter 'only', ['root_services', 'location', 'name'].join(',')
                    opts = success: =>
                        unless @units.fetchNext opts
                            @units.trigger 'finished'
                            deferred.resolve()
                    @units.fetch opts
                    @units

        renderDivision: (municipality, divisionId, context) ->
            @_renderDivisions ["#{municipality}/#{divisionId}"], context
        renderMultipleDivisions: (_path, context) ->
            if context.query.ocdId.length > 0
                @_renderDivisions context.query.ocdId, context

        renderAddress: (municipality, street, numberPart, context) ->
            level = @_getLevel context, defaultLevel='none'
            sm.withDeferred (deferred) =>
                SEPARATOR = /-/g
                slug = "#{municipality}/#{street}/#{numberPart}"
                positionList = models.PositionList.fromSlug municipality, street, numberPart
                @listenTo positionList, 'sync', (p) =>
                    try
                        if p.length == 0
                            throw new Error 'Address slug not found', slug
                        else if p.length == 1
                            position = p.pop()
                        else if p.length > 1
                            exactMatch = p.filter (pos) ->
                                numberParts = numberPart.split SEPARATOR
                                letter = pos.get 'letter'
                                number_end = pos.get 'number_end'
                                if numberParts.length == 1
                                    return letter == null and number_end == null
                                letterMatch = -> letter and letter.toLowerCase() == numberParts[1].toLowerCase()
                                numberEndMatch = -> number_end and number_end == numberParts[1]
                                return letterMatch() or numberEndMatch()
                            if exactMatch.length != 1
                                throw new Error 'Too many address matches'
                        @selectPosition position

                    catch err

                        addressInfo =
                            address: slug

                        Raven.captureException err, {extra: addressInfo}

                    deferred.resolve
                        afterMapInit: =>
                            if level != 'none'
                                @_showAllUnits level

        _showAllUnits: (level) ->
            transformedBounds = @mapProxy.getTransformedBounds()
            bboxes = []
            for bbox in transformedBounds
                bboxes.push "#{bbox[0][0]},#{bbox[0][1]},#{bbox[1][0]},#{bbox[1][1]}"
            @addUnitsWithinBoundingBoxes bboxes, level

        renderHome: (path, context) ->
            unless (not path? or
                path == '' or
                (path instanceof Array and path.length = 0))
                    context = path
            level = @_getLevel context, defaultLevel='none'
            @reset()
            sm.withDeferred (d) =>
                d.resolve afterMapInit: =>
                    if level != 'none'
                        @_showAllUnits level

        renderSearch: (path, opts) ->
            unless opts.query?.q?
                return
            @search opts.query.q

        _matchResourceUrl: (path) ->
            match = path.match /^([0-9]+)/
            if match?
                match[0]

        renderUnit: (path, opts) ->
            id = @_matchResourceUrl path
            if id?
                def = $.Deferred()
                @renderUnitById(id).done (unit) =>
                    def.resolve
                        afterMapInit: =>
                            @selectUnit unit
                return def.promise()
            query = opts.query
            if query?.service
                @renderUnitsByServices opts.query.service

define [
    'moment'
], (
    moment
) ->

    isMultiDayEvent = ([start, end]) ->
        end? and not start.isSame end, 'day'
    isMultiYearEvent = ([start, end]) ->
        end? and not start.isSame end, 'year'
    isMultiMonthEvent = ([start, end]) ->
        end? and not start.isSame end, 'month'

    getLanguage = ->
        moment.locale()

    # TODO move to locale
    clockWord =
        'fi': 'klo',
        'sv': 'kl.',
        'en-gb': 'at'

    dateFormat = (specs, includeMonth=true, includeYear=false) ->
        format = []
        add = (x) -> format.push x
        if specs.includeWeekday
            add specs.format.weekday
        if true
            add specs.format.dayOfMonth
        if includeMonth
            add specs.format.month
        if includeYear
            add specs.format.year
        format

    humanize = (m) ->
        day = m.calendar()
        # todo: Swedish?
        day = day.replace /( (klo|at))* \d{1,2}[:.]\d{1,2}$/, ''
        day

    formatEventDatetime = (start, end, specs) ->
        results = {}
        format = dateFormat specs,
            includeMonth = specs.includeStartTime or specs.includeFirstMonth,
            includeYear = specs.includeFirstYear

        if specs.humanize
            startDate = humanize start
        else
            startDate = start.format format.join(' ')

        startTime = start.format specs.format.time
        if isMultiDayEvent [start, end]
            format = dateFormat(specs, includeMonth=true, includeYear=specs.includeLastYear)
            if not specs.includeLastYear and specs.includeStartTime
                startDate += ' ' + startTime
            endDate = end.format format.join(' ')
            if not specs.includeLastYear and specs.includeEndTime
                endDate += ' ' + end.format specs.format.time
        else
            if specs.includeStartTime
                results.startTime = startTime
            if specs.includeEndTime
                results.endTime = end.format specs.format.time
        sod = moment().startOf 'day'
        diff = start.diff sod, 'days', true
        if specs.humanizeNotice and (diff < 2) and (diff > -1)
            # Add an extra notice for "yesterday" and "tomorrow"
            # in addition to the explicit datetime
            results.notice = humanize start
        if results.startTime
            results.time = "#{clockWord[getLanguage()]} #{results.startTime}"
            delete results.startTime
        if results.endTime
            results.time += "&nbsp;#{results.endTime}"
            delete results.endTime
        results.date = [startDate, endDate]
        results

    formatSpecs = (language, space) ->
        weekday =
            if space == 'large'
                'dddd'
            else
                if getLanguage() == 'en-gb' then 'ddd'
                else 'dd'
        month =
            if space == 'large'
                if getLanguage() == 'fi' then 'MMMM[ta]'
                else 'MMMM'
            else
                if getLanguage() == 'fi' then 'Mo'
                else if getLanguage() == 'sv' then 'M[.]'
                else if getLanguage() == 'en-gb' then 'MMM'
                else 'M'
        dayOfMonth =
            if getLanguage() == 'sv' then 'D[.]'
            else if  getLanguage() == 'en-gb' then 'D'
            else 'Do'

        time: 'LT'
        year: 'YYYY'
        weekday: weekday
        month: month
        dayOfMonth: dayOfMonth

    humanizeSingleDatetime = (datetime) ->
        humanizeEventDatetime(datetime, null, 'small')

    humanizeEventDatetime = (start, end, space) ->
        # space is 'large' or 'small'
        hasStartTime = start.length > 11
        hasEndTime = hasStartTime and (end?.length > 11)

        start = moment start
        if end?
            end = moment end
        now = moment()

        ev = [start, end]
        if isMultiDayEvent ev and not hasStartTime
            hasEndTime = false

        specs = {}
        specs.includeFirstYear =
            isMultiYearEvent ev
        specs.includeLastYear =
            (not now.isSame(end, 'year')) or isMultiYearEvent ev
        specs.includeFirstMonth =
            isMultiMonthEvent ev
        if space == 'large' and isMultiDayEvent ev
            specs.includeWeekday = true
        specs.includeStartTime =
            hasStartTime and ((space == 'large' and hasEndTime) or not isMultiDayEvent ev)
        specs.includeEndTime =
            hasEndTime and space == 'large'

        unless isMultiDayEvent ev
            specs.includeFirstMonth = true
            sod = now.startOf 'day'
            diff = start.diff sod, 'days', true
            _humanize = diff > -7 and diff <= 7
            if space == 'large'
                specs.humanizeNotice = _humanize
            else
                specs.humanize = _humanize
            unless specs.humanize
                specs.includeWeekday = true

        specs.format = formatSpecs getLanguage(), space
        result = formatEventDatetime start, end, specs
        result

    humanizeEventDatetime: humanizeEventDatetime,
    humanizeSingleDatetime: humanizeSingleDatetime

    # Test moments
    # a = moment('2014-07-15T12:00:00')
    # b = moment('2014-07-15T14:00:00')
    # c = moment('2014-07-16T10:00:00')
    # d = moment('2014-07-15T23:59:59')
    # e = moment('2014-07-16T00:00:00')
    # f = moment('2015-07-16T00:00:00')
    # g = moment('2014-08-15T00:00:00')
    # h = moment()
    # i = moment().add 2, 'hours'
    # j = moment().add 2, 'days'
    # k = moment().add 1, 'year'

define [
    'backbone'
], (
    Backbone
) ->

    debugVariables = [
        'units',
        'services',
        'selectedUnits',
        'selectedEvents',
        'searchResults',
        'searchState'
    ]
    debugEvents = [
        'all'
    ]
    log = (x) -> console.log x

    # Class whose name stands out in console output.
    class STATEFUL_EVENT

    class EventDebugger
        constructor: (@appControl) ->
            _.extend @, Backbone.Events
            @addListeners()

        addListeners: ->
            interceptor = (variableName) ->
                (eventName, target, rest...) ->
                    data = new STATEFUL_EVENT
                    data.variable = variableName
                    data.event = eventName
                    data.target = target?.toJSON?() or target
                    for param, i in rest
                        data["param_#{i+1}"] = param
                    log data
            for variableName in debugVariables
                for eventSpec in debugEvents
                    @listenTo @appControl[variableName], eventSpec,
                        interceptor(variableName)

    exports =
        EventDebugger: EventDebugger
        log: log

define ->

    class CanvasDrawer
        referenceLength: 4500
        strokePath: (c, callback) ->
            c.beginPath()
            callback(c)
            c.stroke()
            c.closePath()
        dim: (part) ->
            @ratio * @defaults[part]

    class Stem extends CanvasDrawer
        constructor: (@size, @rotation) ->
            @ratio = @size / @referenceLength
        defaults:
            width: 250
            base: 370
            top: 2670
            control: 1030
        startingPoint: ->
            [@size/2, @size]
        berryCenter: (rotation) ->
            rotation = Math.PI * rotation / 180
            x = 0.8 * Math.cos(rotation) * @dim('top') + (@size / 2)
            y = - Math.sin(rotation) * @dim('top') + @size - @dim('base')
            [x, y]
        setup: (c) ->
            c.lineJoin = 'round'
            c.strokeStyle = '#333'
            c.lineCap = 'round'
            c.lineWidth = @dim('width')
        draw: (c) ->
            @setup(c)
            c.fillStyle = '#000'
            point = @startingPoint()
            @strokePath c, (c) =>
                c.moveTo(point...)
                point[1] -= @dim('base')
                c.lineTo(point...)
                controlPoint = point
                controlPoint[1] -= @dim('control')
                point = @berryCenter(@rotation)
                c.quadraticCurveTo controlPoint..., point...
            point

    class Berry extends CanvasDrawer
        constructor: (@size, @point, @color) ->
            @ratio = @size / @referenceLength
        draw: (c) ->
            c.beginPath()
            c.fillStyle = @color
            c.arc @point..., @defaults.radius * @ratio, 0, 2 * Math.PI
            c.fill()
            unless getIeVersion() and getIeVersion() < 9
                c.strokeStyle = 'rgba(0,0,0,1.0)'
                oldComposite = c.globalCompositeOperation
                c.globalCompositeOperation = "destination-out"
                c.lineWidth = 1.5
                c.stroke()
                c.globalCompositeOperation = oldComposite
            c.closePath()
            c.beginPath()
            c.arc @point..., @defaults.radius * @ratio - 1, 0, 2 * Math.PI
            c.strokeStyle = '#fcf7f5'
            c.lineWidth = 1
            c.stroke()
            c.closePath()
        defaults:
            radius: 1000
            stroke: 125

    class Plant extends CanvasDrawer
        constructor: (@size, @color, id,
                      @rotation = 70 + (id % 40),
                      @translation = [0, -3]) ->
            @stem = new Stem(@size, @rotation)
        draw: (@context) ->
            @context.save()
            @context.translate(@translation...)
            berryPoint = @stem.draw(@context)
            @berry = new Berry(@size, berryPoint, @color)
            @berry.draw(@context)
            @context.restore()

    drawSimpleBerry = (c, x, y, radius, color) ->
        c.fillStyle = color
        c.beginPath()
        c.arc x, y, radius, 0, 2 * Math.PI
        c.fill()

    class PointCluster extends CanvasDrawer
        constructor: (@size, @colors, @positions, @radius) ->
        draw: (c) =>
            _.each @positions, (pos) =>
                drawSimpleBerry c, pos..., @radius, "#000"

    class PointPlant extends CanvasDrawer
        constructor: (@size, @color, @radius) ->
            true
        draw: (c) =>
            drawSimpleBerry c, 10, 10, @radius, "#f00"

    exports =
        Plant: Plant
        PointCluster: PointCluster
        PointPlant: PointPlant
    return exports

config =
    baseUrl: appSettings.static_path + 'vendor'
    paths:
        app: '../js'
    shim:
        bootstrap:
            deps: ['jquery']
        backbone:
            deps: ['underscore', 'jquery']
            exports: 'Backbone'
        'leaflet.markercluster':
            deps: ['leaflet']
        'iexhr':
            deps: ['jquery']
    config:
        'app/p13n': localStorageEnabled: false

requirejs.config config

PAGE_SIZE = 1000

# TODO: move to common file??
window.getIeVersion = ->
    isInternetExplorer = ->
        window.navigator.appName is "Microsoft Internet Explorer"

    if not isInternetExplorer()
        return false

    matches = new RegExp(" MSIE ([0-9]+)\\.([0-9])").exec window.navigator.userAgent
    return parseInt matches[1]

requirejs [
    'app/models',
    'app/p13n',
    'app/color',
    'app/map-base-view'
    'app/map',
    'app/views/embedded-title',
    'backbone',
    'backbone.marionette',
    'jquery',
    'iexhr',
    'i18next',
    'URI',
    'bootstrap',
    'app/router',
    'app/control',
    'app/embedded-views',
    'app/widgets'
],
(
    models,
    p13n,
    ColorMatcher,
    BaseMapView,
    map,
    TitleView,
    Backbone,
    Marionette,
    $,
    iexhr,
    i18n,
    URI,
    Bootstrap,
    Router,
    BaseControl,
    TitleBarView,
    widgets
) ->

    app = new Backbone.Marionette.Application()
    window.app = app

    fullUrl = ->
        currentUri = URI window.location.href
        currentUri.segment(0, "").toString()

    class EmbeddedMapView extends BaseMapView
        mapOptions:
            dragging: true
            touchZoom: true
            scrollWheelZoom: false
            doubleClickZoom: true
            boxZoom: false
        postInitialize: ->
            super()
            zoom = L.control.zoom
                position: 'bottomright'
                zoomInText: "<span class=\"icon-icon-zoom-in\"></span>"
                zoomOutText: "<span class=\"icon-icon-zoom-out\"></span>"
            logo = new widgets.ControlWrapper(new TitleView(href: fullUrl()), position: 'bottomleft', autoZIndex: false)
            zoom.addTo @map
            logo.addTo @map
            @allMarkers.on 'click', (l) =>
                root = URI(window.location.href).host()
                if l.layer?.unit?
                    window.open "http://#{root}/unit/" + l.layer.unit.get('id')
                else
                    window.open fullUrl()
            @allMarkers.on 'clusterclick', =>
                window.open fullUrl()

        clusterPopup: (event) ->
            cluster = event.layer
            childCount = cluster.getChildCount()
            popup = @createPopup()
            html = """
                <div class='servicemap-prompt'>
                    #{i18n.t 'embed.click_prompt_move'}
                </div>
            """
            popup.setContent html
            popup.setLatLng cluster.getBounds().getCenter()
            popup
        createPopup: (unit) ->
            popup = L.popup offset: L.point(0, 30), closeButton: false
            if unit?
                htmlContent = """
                    <div class='unit-name'>#{unit.getText 'name'}</div>
                    <div class='servicemap-prompt'>#{i18n.t 'embed.click_prompt'}</div>
                """
                popup.setContent htmlContent
            popup
        getFeatureGroup: ->
            L.markerClusterGroup
                showCoverageOnHover: false
                maxClusterRadius: (zoom) =>
                    return if (zoom >= map.MapUtils.getZoomlevelToShowAllMarkers()) then 4 else 30
                iconCreateFunction: (cluster) =>
                    @createClusterIcon cluster
                zoomToBoundsOnClick: false
        handlePosition: (positionObject) ->
            accuracy = location.accuracy
            latLng = map.MapUtils.latLngFromGeojson positionObject
            marker = map.MapUtils.createPositionMarker latLng, accuracy, positionObject.origin(), clickable: true
            marker.position = positionObject
            popup = L.popup offset: L.point(0, 40), closeButton: false
            name = positionObject.humanAddress()
            popup.setContent "<div class='unit-name'>#{name}</div>"
            marker.bindPopup popup
            marker.addTo @map
            @map.adapt()
            marker.openPopup()
            marker.on 'click', => window.open fullUrl()

    appState =
        # TODO handle pagination
        divisions: new models.AdministrativeDivisionList
        units: new models.UnitList null, pageSize: 500
        selectedUnits: new models.UnitList()
        selectedPosition: new models.WrappedModel()
        selectedDivision: new models.WrappedModel()
        selectedServices: new models.ServiceList()
        searchResults: new models.SearchList [], pageSize: appSettings.page_size

    appState.services = appState.selectedServices
    window.appState = appState

    app.addInitializer (opts) ->
        # The colors are dependent on the currently selected services.
        @colorMatcher = new ColorMatcher
        control = new BaseControl appState
        router = new Router
            controller: control
            makeMapView: (mapOptions) =>
                mapView = new EmbeddedMapView appState, mapOptions, true
                app.getRegion('map').show mapView
                control.setMapProxy mapView.getProxy()

        baseRoot = "#{appSettings.url_prefix}embed"
        root = baseRoot + '/'
        if !(window.history and history.pushState)
          rootRegexp = new RegExp baseRoot + '\/?'
          url = window.location.href
          url = url.replace rootRegexp, '/'
          currentUri = URI url
          currentUri
          router.routeEmbedded currentUri
        else
            Backbone.history.start
                pushState: true, root: root

        @commands.setHandler 'addUnitsWithinBoundingBoxes', (bboxes) =>
            control.addUnitsWithinBoundingBoxes(bboxes)

    app.addRegions
        navigation: '#navigation-region'
        map: '#app-container'

    # We wait for p13n/i18next to finish loading before firing up the UI
    $.when(p13n.deferred).done ->
        app.start()
        $appContainer = $('#app-container')
        $appContainer.attr 'class', p13n.get('map_background_layer')
        $appContainer.addClass 'embed'


define [
    'app/models',
    'app/spinner',
    'app/embedded-views',
    'backbone.marionette',
    'jquery'
], (
    models,
    Spinner,
    TitleBarView
    Marionette,
    $
) ->

    PAGE_SIZE = 1000
    delayTime = 1000
    spinner = new Spinner
        container: document.body
    #TODO enable title bar and loading spinner
    class Router extends Marionette.AppRouter
        execute: (callback, args) ->
            _.delay @indicateLoading, delayTime
            model = callback.apply(@, args)
            @listenTo model, 'sync', @removeLoadingIndicator
            @listenTo model, 'finished', @removeLoadingIndicator

        _parseParameters: (params) ->
            parsedParams = {}
            _(params.split '&').each (query) =>
                [k, v] = query.split('=', 2)
                if v.match /,/
                    v = v.split(',')
                else
                    v = [v]
                parsedParams[k] = v
            parsedParams

        # renderUnitsWithFilter: (params) ->
        #     @listenToOnce @appState.units, 'finished', =>
        #         @drawUnits @appState.units
        #     units =  @appState.units
        #     params = @_parseParameters params
        #     key = 'division'
        #     divIds = params.divisions
            if _(params).has 'titlebar' # TODO enable
                app.getRegion('navigation').show new TitleBarView @appState.divisions
            # @_fetchDivisions divIds
            # units

        indicateLoading: ->
            spinner.start()

        removeLoadingIndicator: ->
            spinner?.stop()

    Router

define [
    'app/views/base',
    'backbone'
], (
    baseviews,
    Backbone
) ->

    class EmbeddedMap extends Backbone.View
        # Todo: re-enable functionality
        initialize: (options)->
            @mapView = options.mapView
            @listenTo app.vent, 'unit:render-one', @renderUnit
            @listenTo app.vent, 'units:render-with-filter', @renderUnitsWithFilter
            @listenTo app.vent, 'units:render-category', @renderUnitsByCategory

        renderUnitsByCategory: (isSelected) ->
            publicCategories = [100, 101, 102, 103, 104]
            privateCategories = [105]

            onlyCategories = (categoriesArray) ->
                (model) -> _.contains categoriesArray, model.get('provider_type')

            publicUnits = @unitList.filter onlyCategories publicCategories
            privateUnits = @unitList.filter onlyCategories privateCategories
            unitsInCategory = []

            _.extend unitsInCategory, publicUnits if not isSelected.public
            _.extend unitsInCategory, privateUnits if not isSelected.private

            @mapView.drawUnits(new models.UnitList unitsInCategory)

        fetchAdministrativeDivisions: (params, callback)->
            divisions = new models.AdministrativeDivisionList()
            divisions.fetch
                data: ocd_id: params
                success: callback

        findUniqueAdministrativeDivisions: (collection) ->
            byName = (divisionModel) -> divisionModel.toJSON().name
            divisionNames = collection.chain().map(byName).compact().unique().value()
            divisionNamesPartials = {}
            if divisionNames.length > 1
                divisionNamesPartials.start = _.initial(divisionNames).join(', ')
                divisionNamesPartials.end = _.last divisionNames
            else divisionNamesPartials.start = divisionNames[0]

            app.vent.trigger('administration-divisions-fetched', divisionNamesPartials)

    class TitleBarView extends baseviews.SMItemView
        template: 'embedded-title-bar'
        className: 'panel panel-default'
        events:
            'click a': 'preventDefault'
            'click .show-button': 'toggleShow'
            'click .panel-heading': 'collapseCategoryMenu'

        initialize: (@model) ->
            @listenTo @model, 'sync', @render

        divisionNames: (divisions) =>
            divisions.pluck 'name'

        serializeData: ->
            divisions: @divisionNames @model
        show: ->
            @delegateEvents
            @$el.removeClass 'hide'

        hide: ->
            @undelegateEvents()
            @$el.addClass 'hide'

        preventDefault: (ev) ->
            ev.preventDefault()

        toggleShow: (ev)->
            publicToggle = @$ '.public'
            privateToggle = @$ '.private'

            target = $(ev.target)
            target.toggleClass 'selected'

            isSelected =
                public: publicToggle.hasClass 'selected'
                private: privateToggle.hasClass 'selected'

            app.vent.trigger 'units:render-category', isSelected

        collapseCategoryMenu: ->
            $('.panel-heading').toggleClass 'open'
            #$('.collapse').collapse 'toggle'

    return TitleBarView

define [
    'app/base',
    'app/p13n',
    'app/settings',
    'app/jade',
    'app/models',
    'typeahead.bundle',
    'backbone'
],
(
    sm,
    p13n,
    settings,
    jade,
    models,
    _typeahead,
    Backbone
) ->

    monkeyPatchTypeahead = ($element) =>
        typeahead = $element.data 'ttTypeahead'
        proto = Object.getPrototypeOf typeahead
        originalSelect = proto._select
        proto._select = (datum) ->
            @input.setQuery datum.value
            @input.setInputValue datum.value, true
            @_setLanguageDirection()
            @eventBus.trigger 'selected', datum.raw, datum.datasetName
            # REMOVED CODE WHICH CLOSES THE DROPDOWN
        proto.closeCompletely = ->
            @close()
            _.defer _.bind(@dropdown.empty, @dropdown)

    GeocoderSourceBackend: class GeocoderSourceBackend
        constructor: (@options) ->
            _.extend @, Backbone.Events
            @street = undefined
            geocoderStreetEngine = @_createGeocoderStreetEngine p13n.getLanguage()
            @geocoderStreetSource = geocoderStreetEngine.ttAdapter()
        setOptions: (@options) ->
            @options.$inputEl.on 'typeahead:selected', _.bind(@typeaheadSelected, @)
            @options.$inputEl.on 'typeahead:autocompleted', _.bind(@typeaheadSelected, @)
            monkeyPatchTypeahead @options.$inputEl

        _createGeocoderStreetEngine: (lang) ->
            e = new Bloodhound
                name: 'street_suggestions'
                remote:
                    url: appSettings.service_map_backend + "/street/?page_size=4"
                    replace: (url, query) =>
                        url += "&input=#{query}"
                        url += "&language=#{if lang != 'sv' then 'fi' else lang}"
                        url
                    ajax: settings.applyAjaxDefaults {}
                    filter: (parsedResponse) =>
                        results = new models.StreetList parsedResponse.results
                        if results.length == 1
                            @setStreet results.first()
                        results.toArray()
                    rateLimitWait: 50
                datumTokenizer: (datum) ->
                    Bloodhound.tokenizers.whitespace datum.name[lang]
                queryTokenizer: (s) =>
                    res = [s]
            e.initialize()
            return e

        typeaheadSelected: (ev, data) ->
            objectType = data.object_type
            if objectType == 'address'
                if data instanceof models.Position
                    @options.$inputEl.typeahead 'close'
                    @options.selectionCallback ev, data
                else
                    @setStreet(data).done =>
                        @options.$inputEl.val (@options.$inputEl.val() + ' ')
                        @options.$inputEl.trigger 'input'
            else
                @setStreet null

        streetSelected: ->
            unless @street?
                return
            _.defer =>
                streetName = p13n.getTranslatedAttr @street.name
                @options.$inputEl.typeahead('val', '')
                @options.$inputEl.typeahead('val', streetName + ' ')
                @options.$inputEl.trigger 'input'

        setStreet: (street) =>
            sm.withDeferred (deferred) =>
                unless street?
                    @street = undefined
                    deferred.resolve()
                    return
                if street.get('id') == @street?.get('id')
                    deferred.resolve()
                    return
                @street = street
                @street.translatedName = (
                    @street.get('name')[p13n.getLanguage()] or @street.get('name').fi
                ).toLowerCase()
                @street.addresses = new models.AddressList [], pageSize: 200
                @street.addresses.comparator = (x) =>
                    parseInt x.get('number')
                @street.addressesFetched = false
                @street.addresses.fetch
                    data:
                        street: @street.get('id')
                    success: =>
                        @street?.addressesFetched = true
                        deferred.resolve()

        addressSource: (query, callback) =>
            re = new RegExp "^\\s*#{@street.translatedName}(\\s+\\d.*)?", 'i'
            matches = query.match re
            if matches?
                [q, numberPart] = matches
                # TODO: automatically make this search on focus
                unless numberPart?
                    numberPart = ''
                numberPart = numberPart.replace(/\s+/g, '').replace /[^0-9]+/g, ''
                done = =>
                    unless @street?
                        callback []
                        return
                    if @street.addresses.length == 1
                        callback @street.addresses.toArray()
                        return
                    filtered = @street.addresses
                        .filter (a) =>
                            a.humanNumber().indexOf(numberPart) == 0
                    results = filtered.slice(0, 2)
                    last = _(filtered).last()
                    unless last in results
                        if last?
                            results.push last
                    callback results
                if @street.addressesFetched
                    done()
                else
                    @listenToOnce @street.addresses, 'sync', =>
                        done()

        getSource: =>
            (query, cb) =>
                if @street? and @street.translatedName.length <= query.length
                    @addressSource query, cb
                else
                    @geocoderStreetSource query, cb

        getDatasetOptions: =>
            name: 'address'
            displayKey: (c) ->
                c.humanAddress()
            source: @getSource()
            templates:
                suggestion: (c) =>
                    if c instanceof models.Position
                        c.set 'street', @street
                    c.address = c.humanAddress()
                    c.object_type = 'address'
                    jade.template 'typeahead-suggestion', c


define [
    'underscore',
    'jquery',
    'i18next',
    'app/p13n',
    'app/dateformat'
], (
    _,
    $,
    i18n,
    p13n,
    dateformat
) ->

    # Make sure jade runtime is loaded
    if typeof jade != 'object'
        throw new Error "Jade not loaded before app"

    setHelper = (data, name, helper) ->
        if name of data
            return
        data[name] = helper

    class Jade
        getTemplate: (name) ->
            key = "views/templates/#{name}"
            if key not of JST
                throw new Error "template '#{name}' not loaded"
            templateFunc = JST[key]
            return templateFunc

        tAttr: (attr) ->
            return p13n.getTranslatedAttr attr
        tAttrHasLang: (attr) ->
            if not attr
                return false
            return p13n.getLanguage() of attr
        phoneI18n: (num) ->
            if num.indexOf '0' == 0
                # FIXME: make configurable
                num = '+358' + num.substring 1
            num = num.replace /\s/g, ''
            num = num.replace /-/g, ''
            return num
        staticPath: (path) ->
            # Strip leading slash
            if path.indexOf('/') == 0
                path = path.substring 1
            return appSettings.static_path + path
        humanDateRange: (startTime, endTime) ->
            formatted = dateformat.humanizeEventDatetime(
                startTime, endTime, 'small', hasEndTime=false
            )
            return formatted.date
        humanDistance: (meters) ->
            return if meters == Number.MAX_VALUE
                "?"
            else if meters < 1000
                "#{Math.ceil meters }m"
            else
                val = Math.ceil(meters/100).toString()
                [a, b] = [val.slice(0, -1), val.slice(-1)]
                if b != "0"
                    "#{a}.#{b}km"
                else
                    "#{a}km"
        humanShortcomings: (count) ->
            return if count == Number.MAX_VALUE
                i18n.t 'accessibility.no_data'
            else if count == 0
                i18n.t 'accessibility.no_shortcomings'
            else
                i18n.t 'accessibility.shortcoming_count', count: count
        humanDate: (datetime) ->
            res = dateformat.humanizeSingleDatetime datetime
        uppercaseFirst: (val) ->
            val.charAt(0).toUpperCase() + val.slice 1

        mixinHelpers: (data) ->
            setHelper data, 't', i18n.t
            setHelper data, 'tAttr', @tAttr
            setHelper data, 'tAttrHasLang', @tAttrHasLang
            setHelper data, 'phoneI18n', @phoneI18n
            setHelper data, 'staticPath', @staticPath
            setHelper data, 'humanDateRange', @humanDateRange
            setHelper data, 'humanDate', @humanDate
            setHelper data, 'humanDistance', @humanDistance
            setHelper data, 'uppercaseFirst', @uppercaseFirst
            setHelper data, 'humanShortcomings', @humanShortcomings
            setHelper data, 'pad', (s) => " #{s} "
            data

        template: (name, locals) ->
            if locals?
                if typeof locals != 'object'
                    throw new Error "template must get an object argument"
            else
                locals = {}
            func = @getTemplate name
            data = _.clone locals
            @mixinHelpers data
            templateStr = func data
            return $.trim templateStr

    return new Jade

define ->

    clearLandingPage = ->
        # The transitions triggered by removing the class landing from body are defined
        # in the file landing-page.less.
        # When key animations have ended a 'landing-page-cleared' event is triggered.
        if $('body').hasClass('landing')
            $('body').removeClass('landing')
            $('#navigation-region').one('transitionend webkitTransitionEnd otransitionend oTransitionEnd MSTransitionEnd', (event) ->
                app.vent.trigger('landing-page-cleared')
                $(@).off('transitionend webkitTransitionEnd oTransitionEnd MSTransitnd')
                )
    return {
        clear: clearLandingPage
    }

define [
    'backbone',
    'backbone.marionette',
    'i18next',
    'leaflet',
    'leaflet.markercluster',
    'leaflet.snogylop',
    'app/map',
    'app/widgets',
    'app/jade',
    'app/map-state-model'
], (
    Backbone,
    Marionette,
    i18n,
    leaflet,
    markercluster,
    leaflet_snogylop,
    map,
    widgets,
    jade,
    MapStateModel,
) ->

    # TODO: remove duplicates
    MARKER_POINT_VARIANT = false
    DEFAULT_CENTER =
        helsinki: [60.171944, 24.941389]
        espoo: [60.19792, 24.708885]
        vantaa: [60.309045, 25.004675]
        kauniainen: [60.21174, 24.729595]
    ICON_SIZE = 40
    if getIeVersion() and getIeVersion() < 9
        ICON_SIZE *= .8

    class MapBaseView extends Backbone.Marionette.View
        initialize: (@opts, @mapOpts, @embedded) ->
            @markers = {}
            @units = @opts.units
            @selectedUnits = @opts.selectedUnits
            @selectedPosition = @opts.selectedPosition
            @divisions = @opts.divisions
            @listenTo @units, 'reset', @drawUnits
            @listenTo @units, 'finished', (options) =>
                # Triggered when all of the
                # pages of units have been fetched.
                @drawUnits @units, options
                if @selectedUnits.isSet()
                    @highlightSelectedUnit @selectedUnits.first()

        getProxy: ->
            fn = => map.MapUtils.overlappingBoundingBoxes @map
            getTransformedBounds: fn

        mapOptions: {}

        render: ->
            @$el.attr 'id', 'map'

        getMapStateModel: ->
            new MapStateModel @opts, @embedded

        onShow: ->
            # The map is created only after the element is added
            # to the DOM to work around Leaflet init issues.
            mapStyle = p13n.get 'map_background_layer'
            options =
                style: mapStyle
                language: p13n.getLanguage()
            @map = map.MapMaker.createMap @$el.get(0), options, @mapOptions, @getMapStateModel()
            @map.on 'click', _.bind(@onMapClicked, @)
            @allMarkers = @getFeatureGroup()
            @allMarkers.addTo @map
            @divisionLayer = L.featureGroup()
            @divisionLayer.addTo @map
            @postInitialize()

        onMapClicked: (ev) -> # override

        calculateInitialOptions: ->
            if @selectedPosition.isSet()
                zoom: map.MapUtils.getZoomlevelToShowAllMarkers()
                center: map.MapUtils.latLngFromGeojson @selectedPosition.value()
            else if @selectedUnits.isSet()
                zoom: @getMaxAutoZoom()
                center: map.MapUtils.latLngFromGeojson @selectedUnits.first()
            else if @divisions.isSet()
                boundaries = @divisions.map (d) =>
                    new L.GeoJSON d.get('boundary')
                iteratee = (memo, value) => memo.extend value.getBounds()
                bounds = _.reduce boundaries, iteratee, L.latLngBounds([])
                bounds: bounds
            else
                city = p13n.get 'city'
                unless city?
                    city = 'helsinki'
                center = DEFAULT_CENTER[city]
                # Default state without selections
                zoom: if (p13n.get('map_background_layer') == 'servicemap') then 10 else 5
                center: center

        postInitialize: ->
            @_addMouseoverListeners @allMarkers
            @popups = L.layerGroup()
            @popups.addTo @map
            @setInitialView()
            @drawInitialState()

        fitBbox: (bbox) =>
            sw = L.latLng(bbox.slice(0,2))
            ne = L.latLng(bbox.slice(2,4))
            bounds = L.latLngBounds(sw, ne)
            @map.fitBounds bounds

        getMaxAutoZoom: ->
            layer = p13n.get('map_background_layer')
            if layer == 'guidemap'
                7
            else if layer == 'ortographic'
                9
            else
                12


        setInitialView: ->
            if @mapOpts?.bbox?
                @fitBbox @mapOpts.bbox
            else
                opts = @calculateInitialOptions()
                if opts.bounds?
                    @map.fitBounds opts.bounds
                else
                    @map.setView opts.center, opts.zoom

        drawInitialState: =>
            if @selectedPosition.isSet()
                @handlePosition @selectedPosition.value(),
                    center: false,
                    skipRefit: true,
                    initial: true
            else if @selectedUnits.isSet()
                @drawUnits @units, noRefit: true
            else
                if @units.isSet()
                    @drawUnits @units
                if @divisions.isSet()
                    @divisionLayer.clearLayers()
                    @drawDivisions @divisions

        drawUnits: (units, options) ->
            @allMarkers.clearLayers()
            if units.filters?.bbox?
                if @_skipBboxDrawing
                    return
            unitsWithLocation = units.filter (unit) => unit.get('location')?
            markers = unitsWithLocation.map (unit) => @createMarker(unit, options?.marker)
            latLngs = _(markers).map (m) => m.getLatLng()
            unless options?.keepViewport
                @preAdapt?()
                @map.adaptToLatLngs latLngs
            @allMarkers.addLayers markers

        _combineMultiPolygons: (multiPolygons) ->
            multiPolygons.map (mp) => mp.coordinates[0]

        drawDivisionGeometry: (geojson) ->
            mp = L.GeoJSON.geometryToLayer geojson,
                null, null,
                invert: true
                color: '#ff8400'
                weight: 3
                strokeOpacity: 1
                fillColor: '#000'
                fillOpacity: 0.2
            @map.adapt()
            mp.addTo @divisionLayer

        drawDivisions: (divisions) ->
            geojson =
                coordinates: @_combineMultiPolygons divisions.pluck('boundary')
                type: 'MultiPolygon'
            @drawDivisionGeometry geojson

        drawDivision: (division) ->
            unless division?
                return
            @drawDivisionGeometry division.get('boundary')

        highlightUnselectedUnit: (unit) ->
            # Transiently highlight the unit which is being moused
            # over in search results or otherwise temporarily in focus.
            marker = unit.marker
            popup = marker?.popup
            if popup?.selected
                return
            @_clearOtherPopups popup, clearSelected: true
            if popup?
                $(marker.popup._wrapper).removeClass 'selected'
                popup.setLatLng marker?.getLatLng()
                @popups.addLayer popup

        clusterPopup: (event) ->
            cluster = event.layer
            # Maximum number of displayed names per cluster.
            COUNT_LIMIT = 3
            childCount = cluster.getChildCount()
            names = _.map cluster.getAllChildMarkers(), (marker) ->
                    p13n.getTranslatedAttr marker.unit.get('name')
                .sort()
            data = {}
            overflowCount = childCount - COUNT_LIMIT
            if overflowCount > 1
                names = names[0...COUNT_LIMIT]
                data.overflow_message = i18n.t 'general.more_units',
                    count: overflowCount
            data.names = names
            popuphtml = jade.getTemplate('popup_cluster') data
            popup = @createPopup()
            popup.setLatLng cluster.getBounds().getCenter()
            popup.setContent popuphtml
            cluster.popup = popup
            @map.on 'zoomstart', =>
                @popups.removeLayer popup
            popup

        _addMouseoverListeners: (markerClusterGroup)->
            @bindDelayedPopup markerClusterGroup, null,
                showEvent: 'clustermouseover'
                hideEvent: 'clustermouseout'
                popupCreateFunction: _.bind @clusterPopup, @
            markerClusterGroup.on 'spiderfied', (e) =>
                icon = $(e.target._spiderfied?._icon)
                icon?.fadeTo('fast', 0)

            @_lastOpenedClusterIcon = null
            markerClusterGroup.on 'spiderfied', (e) =>
                # Work around css hover forced opacity showing the
                # clicked cluster which should be hidden.
                if @_lastOpenedClusterIcon
                    L.DomUtil.removeClass @_lastOpenedClusterIcon, 'hidden'
                icon = e.target._spiderfied._icon
                L.DomUtil.addClass icon, 'hidden'
                @_lastOpenedClusterIcon = icon

        getZoomlevelToShowAllMarkers: ->
            layer = p13n.get('map_background_layer')
            if layer == 'guidemap'
                return 8
            else if layer == 'ortographic'
                return 8
            else
                return 14

        getServices: ->
            null

        createClusterIcon: (cluster) ->
            count = cluster.getChildCount()
            serviceIds = {}
            serviceId = null
            markers = cluster.getAllChildMarkers()
            services = @getServices()
            _.each markers, (marker) =>
                unless marker.unit?
                    return
                if marker.popup?
                    cluster.on 'remove', (event) =>
                        @popups.removeLayer marker.popup
                if not services or services.isEmpty()
                    root = marker.unit.get('root_services')[0]
                else
                    service = services.find (s) =>
                        s.get('root') in marker.unit.get('root_services')
                    root = service?.get('root') or 50000
                serviceIds[root] = true
            cluster.on 'remove', (event) =>
                if cluster.popup?
                    @popups.removeLayer cluster.popup
            colors = _(serviceIds).map (val, id) =>
                app.colorMatcher.serviceRootIdColor id

            if MARKER_POINT_VARIANT
                ctor = widgets.PointCanvasClusterIcon
            else
                ctor = widgets.CanvasClusterIcon
            iconOpts = {}
            if _(markers).find((m) => m?.unit?.collection?.hasReducedPriority())?
                iconOpts.reducedProminence = true
            new ctor count, ICON_SIZE, colors, null,
                iconOpts

        getFeatureGroup: ->
            L.markerClusterGroup
                showCoverageOnHover: false
                maxClusterRadius: (zoom) =>
                    return if (zoom >= map.MapUtils.getZoomlevelToShowAllMarkers()) then 4 else 30
                iconCreateFunction: (cluster) =>
                    @createClusterIcon cluster
                zoomToBoundsOnClick: true

        createMarker: (unit, markerOptions) ->
            id = unit.get 'id'
            if id of @markers
                marker = @markers[id]
                marker.unit = unit
                unit.marker = marker
                return marker

            icon = @createIcon unit, @selectedServices
            marker = widgets.createMarker map.MapUtils.latLngFromGeojson(unit),
                reducedProminence: unit.collection?.hasReducedPriority()
                icon: icon
                zIndexOffset: 100
            marker.unit = unit
            unit.marker = marker
            if @selectMarker?
                @listenTo marker, 'click', @selectMarker

            marker.on 'remove', (event) =>
                marker = event.target
                if marker.popup?
                    @popups.removeLayer marker.popup

            popup = @createPopup unit
            popup.setLatLng marker.getLatLng()
            @bindDelayedPopup marker, popup

            @markers[id] = marker

        _clearOtherPopups: (popup, opts) ->
            @popups.eachLayer (layer) =>
                if layer == popup
                    return
                if opts?.clearSelected or not layer.selected
                    @popups.removeLayer layer

        bindDelayedPopup: (marker, popup, opts) ->
            showEvent = opts?.showEvent or 'mouseover'
            hideEvent = opts?.hideEvent or 'mouseout'
            delay = opts?.delay or 600
            if marker and popup
                marker.popup = popup
                popup.marker = marker

            prevent = false
            createdPopup = null

            popupOn = (event) =>
                unless prevent
                    if opts?.popupCreateFunction?
                        _popup = opts.popupCreateFunction(event)
                        createdPopup = _popup
                    else
                        _popup = popup
                    @_clearOtherPopups _popup, clearSelected: false
                    @popups.addLayer _popup
                prevent = false

            popupOff = (event) =>
                if opts?.popupCreateFunction
                    _popup = createdPopup
                else
                    _popup = popup
                if _popup?
                    if @selectedUnits? and _popup.marker?.unit == @selectedUnits.first()
                        prevent = true
                    else
                        @popups.removeLayer _popup
                _.delay (=> prevent = false), delay

            marker.on hideEvent, popupOff
            marker.on showEvent, _.debounce(popupOn, delay)

        createPopup: (unit, opts, offset) ->
            popup = @createPopupWidget opts, offset
            if unit?
                htmlContent = "<div class='unit-name'>#{unit.getText 'name'}</div>"
                popup.setContent htmlContent
            popup
        createPopupWidget: (opts, offset) ->
            defaults =
                closeButton: false
                autoPan: false
                zoomAnimation: false
                className: 'unit'
                maxWidth: 500
                minWidth: 150
            if opts?
                opts = _.defaults opts, defaults
            else
                opts = defaults
            if offset? then opts.offset = offset
            new widgets.LeftAlignedPopup opts

        createIcon: (unit, services) ->
            color = app.colorMatcher.unitColor(unit) or 'rgb(255, 255, 255)'
            if MARKER_POINT_VARIANT
                ctor = widgets.PointCanvasIcon
            else
                ctor = widgets.PlantCanvasIcon
            iconOptions = {}
            if unit.collection?.hasReducedPriority()
                iconOptions.reducedProminence = true
            icon = new ctor ICON_SIZE, color, unit.id, iconOptions

    return MapBaseView

define \
[
    'leaflet',
    'backbone',
    'app/map'
], (
    L,
    Backbone,
    MapUtils: MapUtils
) ->

    VIEWPOINTS =
        # meters to show everything within in every direction
        singleUnitImmediateVicinity: 200
        singleObjectEmbedded: 400

    _latitudeDeltaFromRadius = (radiusMeters) ->
        (radiusMeters / 40075017) * 360

    _longitudeDeltaFromRadius = (radiusMeters, latitude) ->
        _latitudeDeltaFromRadius(radiusMeters) / Math.cos(L.LatLng.DEG_TO_RAD * latitude)

    boundsFromRadius = (radiusMeters, latLng) ->
        delta = L.latLng _latitudeDeltaFromRadius(radiusMeters),
            _longitudeDeltaFromRadius(radiusMeters, latLng.lat)
        min = L.latLng latLng.lat - delta.lat, latLng.lng - delta.lng
        max = L.latLng latLng.lat + delta.lat, latLng.lng + delta.lng
        L.latLngBounds [min, max]

    class MapStateModel extends Backbone.Model
        # Models map center, bounds and zoom in a unified way.
        initialize: (@opts, @embedded) ->
            @userHasModifiedView = false
            @wasAutomatic = false
            @zoom = null
            @bounds = null
            @center = null

            @listenTo @opts.selectedPosition, 'change:value', @onSelectPosition

        setMap: (@map) ->
            @map.mapState = @
            @map.on 'moveend', _.bind(@onMoveEnd, @)

        onSelectPosition: (position) =>
            if position.isSet() then @setUserModified()

        onMoveEnd: ->
            unless @wasAutomatic
                @setUserModified()
            @wasAutomatic = false

        setUserModified: ->
            @userHasModifiedView = true

        adaptToLayer: (layer) ->
            @adaptToBounds layer.getBounds()

        adaptToBounds: (bounds) ->
            mapBounds = @map.getBounds()
            # Don't pan just to center the view if the bounds are already
            # contained, unless the map can be zoomed in.
            if bounds? and (@map.getZoom() == @map.getBoundsZoom(bounds) and mapBounds.contains bounds)
                return

            if @opts.route?.has 'plan'
                # Transit plan fitting is the simplest case, handle it and return.
                if bounds?
                    @map.fitBounds bounds,
                        paddingTopLeft: [20,0]
                        paddingBottomRight: [20,20]
                return

            viewOptions =
                center: null
                zoom: null
                bounds: null
            zoom = Math.max MapUtils.getZoomlevelToShowAllMarkers(), @map.getZoom()
            EMBED_RADIUS = VIEWPOINTS['singleObjectEmbedded']
            if @opts.selectedUnits.isSet()
                if @embedded == true
                    viewOptions.zoom = null
                    viewOptions.bounds = boundsFromRadius EMBED_RADIUS,
                        MapUtils.latLngFromGeojson(@opts.selectedUnits.first())
                else
                    viewOptions.center = MapUtils.latLngFromGeojson @opts.selectedUnits.first()
                    viewOptions.zoom = zoom
            else if @opts.selectedPosition.isSet()
                if @embedded == true
                    viewOptions.zoom = null
                    viewOptions.bounds = boundsFromRadius EMBED_RADIUS,
                        MapUtils.latLngFromGeojson(@opts.selectedPosition.value())
                else
                    viewOptions.center = MapUtils.latLngFromGeojson @opts.selectedPosition.value()
                    radiusFilter = @opts.selectedPosition.value().get 'radiusFilter'
                    if radiusFilter?
                        viewOptions.zoom = null
                        viewOptions.bounds = bounds
                    else
                        viewOptions.zoom = zoom

            if @opts.selectedDivision.isSet()
                viewOptions = @_widenToDivision @opts.selectedDivision.value(), viewOptions
            if @opts.services.size() or @opts.searchResults.size() and @opts.selectedUnits.isEmpty()
                if bounds?
                    unless @opts.selectedPosition.isEmpty() and mapBounds.contains bounds
                        if @embedded == true
                            @map.fitBounds bounds
                            return
                        else
                            # Only zoom in, unless current map bounds is empty of units.
                            unitsInsideMap = @_objectsInsideBounds mapBounds, @opts.units
                            unless @opts.selectedPosition.isEmpty() and unitsInsideMap
                                viewOptions = @_widenViewMinimally @opts.units, viewOptions

            @setMapView viewOptions

        setMapView: (viewOptions) ->
            unless viewOptions?
                return
            bounds = viewOptions.bounds
            if bounds
                # Don't pan just to center the view if the bounds are already
                # contained, unless the map can be zoomed in.
                if (@map.getZoom() == @map.getBoundsZoom(bounds) and
                    @map.getBounds().contains bounds) then return
                @map.fitBounds viewOptions.bounds,
                    paddingTopLeft: [20, 0]
                    paddingBottomRight: [20, 20]
            else if viewOptions.center and viewOptions.zoom
                @map.setView viewOptions.center, viewOptions.zoom

        centerLatLng: (latLng, opts) ->
            zoom = @map.getZoom()
            if @opts.selectedPosition.isSet()
                zoom = MapUtils.getZoomlevelToShowAllMarkers()
            else if @opts.selectedUnits.isSet()
                zoom = MapUtils.getZoomlevelToShowAllMarkers()
            @map.setView latLng, zoom

        adaptToLatLngs: (latLngs) ->
            if latLngs.length == 0
                return
            @adaptToBounds L.latLngBounds latLngs

        _objectsInsideBounds: (bounds, objects) ->
            objects.find (object) ->
                latLng = MapUtils.latLngFromGeojson (object)
                if latLng?
                    return bounds.contains latLng
                false

        _widenToDivision: (division, viewOptions) ->
            mapBounds = @map.getBounds()
            viewOptions.center = null
            viewOptions.zoom = null
            bounds = L.latLngBounds L.GeoJSON.geometryToLayer(division.get('boundary'), null, null, {}).getBounds()
            if mapBounds.contains bounds
                viewOptions = null
            else
                viewOptions.bounds = bounds
            viewOptions

        _widenViewMinimally: (units, viewOptions) ->
            UNIT_COUNT = 2
            mapBounds = @map.getBounds()
            center = viewOptions.center or @map.getCenter()
            sortedUnits =
                units.chain()
                .filter (unit) => unit.has 'location'
                # TODO: profile?
                .sortBy (unit) => center.distanceTo MapUtils.latLngFromGeojson(unit)
                .value()

            topLatLngs = []
            unitsFound = {}
            if @opts.services.size()
                _.each @opts.services.pluck('id'), (id) =>
                    unitsFound[id] = UNIT_COUNT

                # We want to have at least UNIT_COUNT visible units
                # per service.
                for unit in sortedUnits
                    if _.isEmpty unitsFound
                        break
                    service = unit.collection.filters?.service
                    if service?
                        countLeft = unitsFound[service]
                        if countLeft?
                            unitsFound[service] -= 1
                            if unitsFound[service] == 0
                                delete unitsFound[service]
                        topLatLngs.push MapUtils.latLngFromGeojson(unit)
            # All of the search results have to be visible.
            else if @opts.searchResults.isSet()
                topLatLngs = _(sortedUnits).map (unit) =>
                    MapUtils.latLngFromGeojson(unit)
            if sortedUnits?.length
                viewOptions.bounds =
                    L.latLngBounds topLatLngs
                    .extend center
                viewOptions.center = null
                viewOptions.zoom = null

            viewOptions


        zoomIn: ->
            @wasAutomatic = true
            @map.setZoom @map.getZoom() + 1

define [
    'leaflet',
    'backbone',
    'backbone.marionette',
    'leaflet.markercluster',
    'leaflet.activearea',
    'i18next',
    'app/widgets',
    'app/models',
    'app/p13n',
    'app/jade',
    'app/map-base-view',
    'app/transit-map',
    'app/map',
    'app/base',
    'app/map-state-model',
    'app/views/exporting',
    'app/views/location-refresh-button'
], (
    leaflet,
    Backbone,
    Marionette,
    markercluster,
    leaflet_activearea,
    i18n,
    widgets,
    models,
    p13n,
    jade,
    MapBaseView,
    TransitMapMixin,
    map,
    mixOf: mixOf
    MapStateModel,
    ExportingView,
    LocationRefreshButtonView
) ->

    ICON_SIZE = 40
    if getIeVersion() and getIeVersion() < 9
        ICON_SIZE *= .8
    MARKER_POINT_VARIANT = false
    DEFAULT_CENTER = [60.171944, 24.941389] # todo: depends on city

    class MapView extends mixOf MapBaseView, TransitMapMixin
        tagName: 'div'
        initialize: (@opts, @mapOpts) ->
            super @opts, @mapOpts
            @selectedServices = @opts.services
            @searchResults = @opts.searchResults
            #@listenTo @units, 'add', @drawUnits
            # @selectedPosition = @opts.selectedPosition
            @selectedDivision = @opts.selectedDivision
            @userPositionMarkers =
                accuracy: null
                position: null
                clicked: null

            @listenTo @selectedServices, 'add', (service, collection) =>
                if collection.size() == 1
                    @markers = {}
            @listenTo @selectedServices, 'remove', (model, collection) =>
                if collection.size() == 0
                    @markers = {}

            @listenTo @selectedDivision, 'change:value', (model) =>
                @divisionLayer.clearLayers()
                @drawDivision model.value()

            @listenTo @units, 'unit:highlight', @highlightUnselectedUnit
            @listenTo @units, 'batch-remove', @removeUnits
            @listenTo @units, 'remove', @removeUnit
            @listenTo @selectedUnits, 'reset', @handleSelectedUnit
            @listenTo p13n, 'position', @handlePosition

            if @selectedPosition.isSet()
                @listenTo @selectedPosition.value(), 'change:radiusFilter', @radiusFilterChanged
            @listenTo @selectedPosition, 'change:value', (wrapper, value) =>
                previous = wrapper.previous 'value'
                if previous?
                    @stopListening previous
                if value?
                    @listenTo value, 'change:radiusFilter', @radiusFilterChanged
                @handlePosition value, center: true

            MapView.setMapActiveAreaMaxHeight
                maximize:
                    @selectedPosition.isEmpty() and @selectedUnits.isEmpty()

            @initializeTransitMap
                route: @opts.route
                selectedUnits: @selectedUnits
                selectedPosition: @selectedPosition

            #$(window).resize => _.defer(_.bind(@recenter, @))

        onMapClicked: (ev) ->
            unless @hasClickedPosition? then @hasClickedPosition = false
            if @hasClickedPosition
                @infoPopups.clearLayers()
                @map.removeLayer @userPositionMarkers['clicked']
                @hasClickedPosition = false
            else
                if @pendingPosition?
                    position = @pendingPosition
                else
                    position = new models.CoordinatePosition
                        isDetected: false
                position.set 'location',
                    coordinates: [ev.latlng.lng, ev.latlng.lat]
                    accuracy: 0
                    type: 'Point'
                if @pendingPosition?
                    @pendingPosition = null
                    $('#map').css 'cursor', 'auto'
                else
                    position.set 'name', null
                    @hasClickedPosition = true
                @handlePosition position, initial: true

        requestLocation: (position) ->
            $('#map').css 'cursor', 'crosshair'
            @pendingPosition = position

        radiusFilterChanged: (position, radius) ->
            @divisionLayer.clearLayers()
            unless radius?
                return
            latLng = L.GeoJSON.geometryToLayer(position.get('location'))
            poly = new widgets.CirclePolygon latLng.getLatLng(), radius, {invert: true, stroke: false}
            poly.circle.options.fill = false
            poly.addTo @divisionLayer
            poly.circle.addTo @divisionLayer

        handleSelectedUnit: (units, options) ->
            if units.isEmpty()
                # The previously selected unit might have been a bbox unit.
                @_removeBboxMarkers @map.getZoom(), map.MapUtils.getZoomlevelToShowAllMarkers()
                MapView.setMapActiveAreaMaxHeight maximize: true
                return
            unit = units.first()
            latLng = unit.marker?.getLatLng()
            if latLng?
                @map.adaptToLatLngs [latLng]
            unless unit.hasBboxFilter()
                @_removeBboxMarkers()
                @_skipBboxDrawing = false
            _.defer => @highlightSelectedUnit unit

        handlePosition: (positionObject, opts) ->
            # TODO: clean up this method
            unless positionObject?
                for key in ['clicked', 'address']
                    layer = @userPositionMarkers[key]
                    if layer then @map.removeLayer layer

            isSelected = positionObject == @selectedPosition.value()

            key = positionObject?.origin()
            if key != 'detected'
                @infoPopups.clearLayers()

            prev = @userPositionMarkers[key]
            if prev then @map.removeLayer prev

            if (key == 'address') and @userPositionMarkers.clicked?
                @map.removeLayer @userPositionMarkers.clicked
            if (key == 'clicked') and isSelected and @userPositionMarkers.address?
                @map.removeLayer @userPositionMarkers.address

            location = positionObject?.get 'location'
            unless location then return

            accuracy = location.accuracy
            accuracyMarker = L.circle latLng, accuracy, weight: 0

            latLng = map.MapUtils.latLngFromGeojson positionObject
            marker = map.MapUtils.createPositionMarker latLng, accuracy, positionObject.origin()
            marker.position = positionObject
            marker.on 'click', => app.commands.execute 'selectPosition', positionObject
            if isSelected or opts?.center
                @map.refitAndAddMarker marker
            else
                marker.addTo @map

            @userPositionMarkers[key] = marker

            if isSelected
                @infoPopups.clearLayers()

            popup = @createPositionPopup positionObject, marker

            if not positionObject?.isDetectedLocation() or
                @selectedUnits.isEmpty() and (
                    @selectedPosition.isEmpty() or
                    @selectedPosition.value() == positionObject)
                pop = => @infoPopups.addLayer popup
                unless positionObject.get 'preventPopup'
                    if isSelected or (opts?.initial and not positionObject.get('preventPopup'))
                        pop()
                        if isSelected
                            $(popup._wrapper).addClass 'selected'

            positionObject.popup = popup

        width: ->
            @$el.width()
        height: ->
            @$el.height()

        removeUnits: (options) ->
            @allMarkers.clearLayers()
            @drawUnits @units
            unless @selectedUnits.isEmpty()
                @highlightSelectedUnit @selectedUnits.first()
            if @units.isEmpty()
                @showAllUnitsAtHighZoom()

        removeUnit: (unit, units, options) ->
            if unit.marker?
                @allMarkers.removeLayer unit.marker
                delete unit.marker

        getServices: ->
            @selectedServices

        createPositionPopup: (positionObject, marker) ->
            latLng = map.MapUtils.latLngFromGeojson(positionObject)
            address = positionObject.humanAddress()
            unless address
                address = i18n.t 'map.retrieving_address'
            if positionObject == @selectedPosition.value()
                popupContents =
                    (ctx) =>
                        "<div class=\"unit-name\">#{ctx.name}</div>"
                offsetY = switch positionObject.origin()
                    when 'detected' then 10
                    when 'address' then 10
                    else 38
                popup = @createPopup(null, null, L.point(0, offsetY))
                    .setContent popupContents
                        name: address
                    .setLatLng latLng
            else
                popupContents =
                    (ctx) =>
                        ctx.detected = positionObject?.isDetectedLocation()
                        $popupEl = $ jade.template 'position-popup', ctx
                        $popupEl.on 'click', (e) =>
                            unless positionObject == @selectedPosition.value()
                                e.stopPropagation()
                                @listenTo positionObject, 'reverse-geocode', =>
                                    app.commands.execute 'selectPosition', positionObject
                                marker.closePopup()
                                @infoPopups.clearLayers()
                                @map.removeLayer positionObject.popup
                                if positionObject.isReverseGeocoded()
                                    positionObject.trigger 'reverse-geocode'

                        $popupEl[0]
                offsetY = switch positionObject.origin()
                    when 'detected' then -53
                    when 'clicked' then -15
                    when 'address' then -50
                offset = L.point 0, offsetY
                popupOpts =
                    closeButton: false
                    className: 'position'
                    autoPan: false
                    offset: offset
                    autoPanPaddingTopLeft: L.point 30, 80
                    autoPanPaddingBottomRight: L.point 30, 80
                popup = L.popup(popupOpts)
                    .setLatLng latLng
                    .setContent popupContents
                        name: address

            positionObject.reverseGeocode?().done =>
                popup.setContent popupContents
                    name: positionObject.humanAddress()
            popup

        highlightSelectedUnit: (unit) ->
            # Prominently highlight the marker whose details are being
            # examined by the user.
            unless unit?
                return
            marker = unit.marker
            popup = marker?.popup
            unless popup
                return
            popup.selected = true
            @_clearOtherPopups popup, clearSelected: true
            unless @popups.hasLayer popup
                popup.setLatLng marker.getLatLng()
                @popups.addLayer popup
            @listenToOnce unit, 'change:selected', (unit) =>
                $(marker?._icon).removeClass 'selected'
                $(marker?.popup._wrapper).removeClass 'selected'
                @popups.removeLayer marker?.popup
            $(marker?._icon).addClass 'selected'
            $(marker?.popup._wrapper).addClass 'selected'

        selectMarker: (event) ->
            marker = event.target
            unit = marker.unit
            app.commands.execute 'selectUnit', unit

        drawUnit: (unit, units, options) ->
            location = unit.get 'location'
            if location?
                marker = @createMarker unit
                @allMarkers.addLayer marker

        getCenteredView: ->
            if @selectedPosition.isSet()
                center: map.MapUtils.latLngFromGeojson @selectedPosition.value()
                zoom: map.MapUtils.getZoomlevelToShowAllMarkers()
            else if @selectedUnits.isSet()
                center: map.MapUtils.latLngFromGeojson @selectedUnits.first()
                zoom: Math.max @getMaxAutoZoom(), @map.getZoom()
            else
                null

        resetMap: ->
            # With different projections the base layers cannot
            # be changed on a live map.
            window.location.reload true

        handleP13nChange: (path, newVal) ->
            if path[0] != 'map_background_layer'
                return

            oldLayer = @map._baseLayer
            oldCrs = @map.crs

            mapStyle = p13n.get 'map_background_layer'
            {layer: newLayer, crs: newCrs} = map.MapMaker.makeBackgroundLayer style: mapStyle

            if newCrs.code != oldCrs.code
                @resetMap()
                return

            @map.addLayer newLayer
            @map.removeLayer oldLayer
            @map._baseLayer = newLayer

        addMapActiveArea: ->
            @map.setActiveArea 'active-area'
            MapView.setMapActiveAreaMaxHeight
                maximize: @selectedUnits.isEmpty() and @selectedPosition.isEmpty()

        initializeMap: ->
            @setInitialView()
            window.debugMap = map
            @listenTo p13n, 'change', @handleP13nChange
            # The line below is for debugging without clusters.
            # @allMarkers = L.featureGroup()
            @popups = L.layerGroup()
            @infoPopups = L.layerGroup()

            #L.control.scale(imperial: false).addTo(@map);

            L.control.zoom(
                position: 'bottomright'
                zoomInText: "<span class=\"icon-icon-zoom-in\"></span><span class=\"sr-only\">#{i18n.t('assistive.zoom_in')}</span>"
                zoomOutText: "<span class=\"icon-icon-zoom-out\"></span><span class=\"sr-only\">#{i18n.t('assistive.zoom_out')}</span>").addTo @map

            new widgets.ControlWrapper(new LocationRefreshButtonView(), position: 'bottomright').addTo @map
            new widgets.ControlWrapper(new ExportingView(), position: 'bottomright').addTo @map

            @popups.addTo @map
            @infoPopups.addTo @map

            @debugGrid = L.layerGroup().addTo(@map)
            @debugCircles = {}

            @_addMapMoveListeners()

            # If the user has allowed location requests before,
            # try to get the initial location now.
            if p13n.getLocationRequested()
                p13n.requestLocation()

            @previousZoomlevel = @map.getZoom()
            @drawInitialState()

        _removeBboxMarkers: (zoom, zoomLimit) ->
            unless @markers?
                return
            if @markers.length == 0
                return
            if zoom? and zoomLimit?
                if zoom >= zoomLimit
                    return
            @_skipBboxDrawing = true
            if @selectedServices.isSet()
                return
            toRemove = _.filter @markers, (m) =>
                unit = m?.unit
                ret = unit?.collection?.hasReducedPriority() and not unit?.get 'selected'
            app.commands.execute 'clearFilters'
            @allMarkers.removeLayers toRemove
            @_clearOtherPopups null, null

        _addMapMoveListeners: ->
            zoomLimit = map.MapUtils.getZoomlevelToShowAllMarkers()
            @map.on 'zoomanim', (data) =>
                @_skipBboxDrawing = false
                @_removeBboxMarkers data.zoom, zoomLimit
            @map.on 'zoomend', =>
                @_removeBboxMarkers @map.getZoom(), zoomLimit
            @map.on 'moveend', =>
                # TODO: cleaner way to prevent firing from refit
                if @skipMoveend
                    @skipMoveend = false
                    return
                @showAllUnitsAtHighZoom()

        postInitialize: ->
            @addMapActiveArea()
            @initializeMap()
            @_addMouseoverListeners @allMarkers

        @mapActiveAreaMaxHeight: =>
            screenWidth = $(window).innerWidth()
            screenHeight = $(window).innerHeight()
            Math.min(screenWidth * 0.4, screenHeight * 0.3)

        preAdapt: =>
            MapView.setMapActiveAreaMaxHeight()

        @setMapActiveAreaMaxHeight: (options) =>
            # Sets the height of the map shown in views that have a slice of
            # map visible on mobile.
            defaults = maximize: false
            options = options or {}
            _.extend defaults, options
            options = defaults
            if $(window).innerWidth() <= appSettings.mobile_ui_breakpoint
                height = MapView.mapActiveAreaMaxHeight()
                $activeArea = $ '.active-area'
                if options.maximize
                    $activeArea.css 'height', 'auto'
                    $activeArea.css 'bottom', 0
                else
                    $activeArea.css 'height', height
                    $activeArea.css 'bottom', 'auto'
            else
                $('.active-area').css 'height', 'auto'
                $('.active-area').css 'bottom', 0

        recenter: ->
            view = @getCenteredView()
            unless view?
                return
            @map.setView view.center, view.zoom, pan: duration: 0.5

        refitBounds: ->
            @skipMoveend = true
            @map.fitBounds @allMarkers.getBounds(),
                maxZoom: @getMaxAutoZoom()
                animate: true

        fitItinerary: (layer) ->
            @map.fitBounds layer.getBounds(),
                paddingTopLeft: [20,20]
                paddingBottomRight: [20,20]

        showAllUnitsAtHighZoom: ->
            if $(window).innerWidth() <= appSettings.mobile_ui_breakpoint
                return
            if @map.getZoom() >= map.MapUtils.getZoomlevelToShowAllMarkers()
                if @selectedUnits.isSet() and not @selectedUnits.first().collection?.filters?.bbox?
                    return
                if @selectedServices.isSet()
                    return
                if @searchResults.isSet()
                    return
                transformedBounds = map.MapUtils.overlappingBoundingBoxes @map
                bboxes = []
                for bbox in transformedBounds
                    bboxes.push "#{bbox[0][0]},#{bbox[0][1]},#{bbox[1][0]},#{bbox[1][1]}"
                if @mapOpts.level?
                    level = @mapOpts.level
                    delete @mapOpts.level
                app.commands.execute 'addUnitsWithinBoundingBoxes', bboxes, level
    MapView

define [
    'leaflet',
    'proj4leaflet',
    'underscore',
    'app/base',
], (
    leaflet,
    p4j,
    _,
    sm
) ->

    RETINA_MODE = window.devicePixelRatio > 1

    getMaxBounds = (layer) ->
        L.latLngBounds L.latLng(59.5, 24.2), L.latLng(60.5, 25.5)

    wmtsPath = (style, language) ->
        stylePath =
            if style == 'accessible_map'
                if language == 'sv'
                    "osm-sm-visual-sv/etrs_tm35fin"
                else
                    "osm-sm-visual/etrs_tm35fin"
            else if RETINA_MODE
                if language == 'sv'
                    "osm-sm-sv-hq/etrs_tm35fin_hq"
                else
                    "osm-sm-hq/etrs_tm35fin_hq"
            else
                if language == 'sv'
                    "osm-sm-sv/etrs_tm35fin"
                else
                    "osm-sm/etrs_tm35fin"
        path = [
            "http://geoserver.hel.fi/mapproxy/wmts",
            stylePath,
            "{z}/{x}/{y}.png"
        ]
        path.join '/'

    makeLayer =
        tm35:
            crs: ->
                crsName = 'EPSG:3067'
                projDef = '+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
                bounds = L.bounds L.point(-548576, 6291456), L.point(1548576, 8388608)
                originNw = [bounds.min.x, bounds.max.y]
                crsOpts =
                    resolutions: [8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125]
                    bounds: bounds
                    transformation: new L.Transformation 1, -originNw[0], -1, originNw[1]
                new L.Proj.CRS crsName, projDef, crsOpts

            layer: (opts) ->
                L.tileLayer wmtsPath(opts.style, opts.language),
                    maxZoom: 15
                    minZoom: 6
                    continuousWorld: true
                    tms: false

        gk25:
            crs: ->
                crsName = 'EPSG:3879'
                projDef = '+proj=tmerc +lat_0=0 +lon_0=25 +k=1 +x_0=25500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'

                bounds = [25440000, 6630000, 25571072, 6761072]
                new L.Proj.CRS.TMS crsName, projDef, bounds,
                    resolutions: [256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125, 0.0625, 0.03125]

            layer: (opts) ->
                geoserverUrl = (layerName, layerFmt) ->
                    "http://geoserver.hel.fi/geoserver/gwc/service/tms/1.0.0/#{layerName}@ETRS-GK25@#{layerFmt}/{z}/{x}/{y}.#{layerFmt}"
                if opts.style == 'ortographic'
                    new L.Proj.TileLayer.TMS geoserverUrl("hel:orto2013", "jpg"), opts.crs,
                        maxZoom: 10
                        minZoom: 2
                        continuousWorld: true
                        tms: false
                else
                    guideMapUrl = geoserverUrl("hel:Karttasarja", "gif")
                    guideMapOptions =
                        maxZoom: 12
                        minZoom: 2
                        continuousWorld: true
                        tms: false
                    (new L.Proj.TileLayer.TMS guideMapUrl, opts.crs, guideMapOptions).setOpacity 0.8

    SMap = L.Map.extend
        refitAndAddLayer: (layer) ->
            @mapState.adaptToLayer layer
            @addLayer layer
        refitAndAddMarker: (marker) ->
            @mapState.adaptToLatLngs [marker.getLatLng()]
            @addLayer marker
        adaptToLatLngs: (latLngs) ->
            @mapState.adaptToLatLngs latLngs
        adapt: ->
            @mapState.adaptToBounds null

    class MapMaker
        @makeBackgroundLayer: (options) ->
            coordinateSystem = switch options.style
                when 'guidemap' then 'gk25'
                when 'ortographic' then 'gk25'
                else 'tm35'
            layerMaker = makeLayer[coordinateSystem]
            crs = layerMaker.crs()
            options.crs = crs
            tileLayer = layerMaker.layer options
            tileLayer.on 'tileload', (e) =>
                e.tile.setAttribute 'alt', ''
            layer: tileLayer
            crs: crs
        @createMap: (domElement, options, mapOptions, mapState) ->
            {layer: layer, crs: crs} = MapMaker.makeBackgroundLayer options
            defaultMapOptions =
                crs: crs
                continuusWorld: true
                worldCopyJump: false
                zoomControl: false
                closePopupOnClick: false
                maxBounds: getMaxBounds options.style
                layers: [layer]
            _.extend defaultMapOptions, mapOptions
            map = new SMap domElement, defaultMapOptions
            mapState?.setMap map
            map.crs = crs
            map._baseLayer = layer
            map

    class MapUtils
        @createPositionMarker: (latLng, accuracy, type, opts) ->
            Z_INDEX = -1000
            switch type
                when 'detected'
                    opts =
                        icon: L.divIcon
                            iconSize: L.point 40, 40
                            iconAnchor: L.point 20, 39
                            className: 'servicemap-div-icon'
                            html: '<span class="icon-icon-you-are-here"></span'
                        zIndexOffset: Z_INDEX
                    marker = L.marker latLng, opts
                when 'clicked'
                    marker = L.circleMarker latLng,
                        color: '#666'
                        weight: 2
                        opacity: 1
                        fill: false
                        clickable: if opts?.clickable? then opts.clickable else false
                        zIndexOffset: Z_INDEX
                    marker.setRadius 6
                when 'address'
                    opts =
                        zIndexOffset: Z_INDEX
                        icon: L.divIcon
                            iconSize: L.point 40, 40
                            iconAnchor: L.point 20, 39
                            className: 'servicemap-div-icon'
                            html: '<span class="icon-icon-address"></span'
                    marker = L.marker latLng, opts
            return marker

        @overlappingBoundingBoxes: (map) ->
            crs = map.crs
            if map._originalGetBounds?
                latLngBounds = map._originalGetBounds()
            else
                latLngBounds = map.getBounds()
            METER_GRID = 1000
            DEBUG_GRID = false
            ne = crs.project latLngBounds.getNorthEast()
            sw = crs.project latLngBounds.getSouthWest()
            min = x: ne.x, y: sw.y
            max = y: ne.y, x: sw.x

            snapToGrid = (coord) ->
                parseInt(coord / METER_GRID) * METER_GRID
            coordinates = {}
            for dim in ['x', 'y']
                coordinates[dim] = coordinates[dim] or {}
                for value in [min[dim] .. max[dim]]
                    coordinates[dim][parseInt(snapToGrid(value))] = true

            pairs = _.flatten(
                [parseInt(x), parseInt(y)] for x in _.keys(coordinates.x) for y in _.keys(coordinates.y),
                true)

            bboxes = _.map pairs, ([x, y]) -> [[x, y], [x + METER_GRID, y + METER_GRID]]
            if DEBUG_GRID
                @debugGrid.clearLayers()
                for bbox in bboxes
                    sw = crs.projection.unproject(L.point(bbox[0]...))
                    ne = crs.projection.unproject(L.point(bbox[1]...))
                    sws = [sw.lat, sw.lng].join()
                    nes = [ne.lat, ne.lng].join()
                    unless @debugCircles[sws]
                        @debugGrid.addLayer L.circle(sw, 10)
                        @debugCircles[sws] = true
                    unless @debugCircles[nes]
                        @debugGrid.addLayer L.circle(ne, 10)
                        @debugCircles[nes] = true
                    # rect = L.rectangle([sw, ne])
                    # @debugGrid.addLayer rect
            bboxes

        @latLngFromGeojson: (object) ->
            L.latLng object?.get('location')?.coordinates?.slice(0).reverse()

        @getZoomlevelToShowAllMarkers: ->
            layer = p13n.get('map_background_layer')
            if layer == 'guidemap'
                return 8
            else if layer == 'ortographic'
                return 8
            else
                return 14

    makeDistanceComparator = (p13n) =>
        createFrom = (position) =>
            (obj) =>
                [a, b] = [MapUtils.latLngFromGeojson(position), MapUtils.latLngFromGeojson(obj)]
                result = a.distanceTo b
                result
        position = p13n.getLastPosition()
        if position?
            createFrom position

    MapMaker: MapMaker
    MapUtils: MapUtils
    makeDistanceComparator: makeDistanceComparator

define [
    'moment',
    'underscore',
    'raven',
    'backbone',
    'i18next',
    'app/base',
    'app/settings',
    'app/spinner',
    'app/alphabet',
    'app/accessibility'
], (
    moment,
    _,
    Raven,
    Backbone,
    i18n,
    {mixOf: mixOf, pad: pad, withDeferred: withDeferred}
    settings,
    SMSpinner,
    alphabet,
    accessibility
) ->

    BACKEND_BASE = appSettings.service_map_backend
    LINKEDEVENTS_BASE = appSettings.linkedevents_backend
    OPEN311_BASE = appSettings.open311_backend
    OPEN311_WRITE_BASE = appSettings.open311_write_backend + '/'

    # TODO: remove and handle in geocoder
    MUNICIPALITIES =
        49: 'espoo'
        91: 'helsinki'
        92: 'vantaa'
        235: 'kauniainen'
    MUNICIPALITY_IDS = _.invert MUNICIPALITIES

    Backbone.ajax = (request) ->
        request = settings.applyAjaxDefaults request
        return Backbone.$.ajax.call Backbone.$, request

    class FilterableCollection extends Backbone.Collection
        initialize: (options) ->
            @filters = {}
        setFilter: (key, val) ->
            if not val
                if key of @filters
                    delete @filters[key]
            else
                @filters[key] = val
            @
        clearFilters: ->
            @filters = {}
        fetch: (options) ->
            data = _.clone @filters
            if options.data?
                data = _.extend data, options.data
            options.data = data
            super options

    class RESTFrameworkCollection extends FilterableCollection
        parse: (resp, options) ->
            # Transform Django REST Framework response into PageableCollection
            # compatible structure.
            @fetchState =
                count: resp.count
                next: resp.next
                previous: resp.previous
            super resp.results, options

    class WrappedModel extends Backbone.Model
        initialize: (model) ->
            super()
            @wrap model
        wrap: (model) ->
            @set 'value', model or null
        value: ->
            @get 'value'
        isEmpty: ->
            return not @has 'value'
        isSet: ->
            return not @isEmpty()

    class GeoModel
        getLatLng: ->
            if @latLng?
                @latLng
            coords = @get('location')?.coordinates
            if coords?
                @latLng = L.GeoJSON.coordsToLatLng coords
            else
                null

        getDistanceToLastPosition: ->
            position = p13n.getLastPosition()
            if position?
                latLng = @getLatLng()
                if latLng?
                    position.getLatLng().distanceTo latLng
                else
                    Number.MAX_VALUE

    class SMModel extends Backbone.Model
        # FIXME/THINKME: Should we take care of translation only in
        # the view level? Probably.
        getText: (attr) ->
            val = @get attr
            if attr in @translatedAttrs
                return p13n.getTranslatedAttr val
            return val
        toJSON: (options) ->
            data = super()
            if not @translatedAttrs
                return data
            for attr in @translatedAttrs
                if attr not of data
                    continue
                data[attr] = p13n.getTranslatedAttr data[attr]
            return data

        url: ->
            ret = super
            if ret.substr -1 != '/'
                ret = ret + '/'
            return ret

        urlRoot: ->
            return "#{BACKEND_BASE}/#{@resourceName}/"

    class SMCollection extends RESTFrameworkCollection
        initialize: (models, options) ->
            @filters = {}
            @currentPage = 1
            if options?
                @pageSize = options.pageSize || 25
                if options.setComparator
                    @setDefaultComparator()
            super options

        url: ->
            obj = new @model
            return "#{BACKEND_BASE}/#{obj.resourceName}/"

        isSet: ->
            return not @isEmpty()

        setFilter: (key, val) ->
            if not val
                if key of @filters
                    delete @filters[key]
            else
                @filters[key] = val
            return @

        clearFilters: ->
            @filters = {}

        fetchNext: (options) ->
            if @fetchState? and not @fetchState.next
                return false

            @currentPage++
            defaults = {reset: false, remove: false}
            if options?
                options = _.extend options, defaults
            else
                options = defaults
            @fetch options

        fetch: (options) ->
            if options?
                options = _.clone options
            else
                options = {}

            unless options.data?
                options.data = {}
            options.data.page = @currentPage
            options.data.page_size = @pageSize

            if options.spinnerOptions?.container
                spinner = new SMSpinner(options.spinnerOptions)
                spinner.start()

                success = options.success
                error = options.error

                options.success = (collection, response, options) ->
                    spinner.stop()
                    success?(collection, response, options)

                options.error = (collection, response, options) ->
                    spinner.stop()
                    error?(collection, response, options)

            delete options.spinnerOptions

            super options

        fetchFields: (start, end, fields) ->
            # Fetches more model details for a specified range
            # in the collection.
            if not fields
                return $.Deferred().resolve().promise()
            filtered = _(@slice(start, end)).filter (m) =>
                for field in fields
                    if m.get(field) == undefined
                        return true
                return false
            idsToFetch = _.pluck filtered, 'id'
            unless idsToFetch.length
                return $.Deferred().resolve().promise()
            @fetch
                remove: false
                data:
                    page_size: idsToFetch.length
                    id: idsToFetch.join ','
                    include: fields.join ','

        getComparatorKeys: -> ['default', 'alphabetic', 'alphabetic_reverse']
        getComparator: (key, direction) =>
            switch key
                when 'alphabetic'
                    alphabet.makeComparator direction
                when 'alphabetic_reverse'
                    alphabet.makeComparator -1
                when 'distance'
                    (x) => x.getDistanceToLastPosition()
                when 'distance_precalculated'
                    (x) => x.get 'distance'
                when 'default'
                    (x) => -x.get 'score'
                when 'accessibility'
                    (x) => x.getShortcomingCount()
                else
                    null
        comparatorWrapper: (fn) =>
            unless fn
                return fn
            if fn.length == 2
                (a, b) =>
                    fn a.getComparisonKey(), b.getComparisonKey()
            else
                fn

        setDefaultComparator: ->
            @setComparator @getComparatorKeys()[0]
        setComparator: (key, direction) ->
            index = @getComparatorKeys().indexOf(key)
            if index != -1
                @currentComparator = index
                @currentComparatorKey = key
                @comparator = @comparatorWrapper @getComparator(key, direction)
        cycleComparator: ->
            unless @currentComparator?
                @currentComparator = 0
            @currentComparator += 1
            @currentComparator %= @getComparatorKeys().length
            @reSort @getComparatorKeys()[@currentComparator]
        reSort: (key, direction) ->
            @setComparator key, direction
            if @comparator?
                @sort()
            key
        getComparatorKey: ->
            @currentComparatorKey

        hasReducedPriority: ->
            false

    class Unit extends mixOf SMModel, GeoModel
        resourceName: 'unit'
        translatedAttrs: ['name', 'description', 'street_address']

        initialize: (options) ->
            super options
            @eventList = new EventList()
            @feedbackList = new FeedbackList()

        getEvents: (filters, options) ->
            if not filters?
                filters = {}
            if 'start' not of filters
                filters.start = 'today'
            if 'sort' not of filters
                filters.sort = 'start_time'
            filters.location = "tprek:#{@get 'id'}"
            @eventList.filters = filters
            if not options?
                options =
                    reset: true
            else if not options.reset
                options.reset = true
            @eventList.fetch options

        getFeedback: (options) ->
            @feedbackList.setFilter 'service_object_id', @id
            #@feedbackList.setFilter 'updated_after', '2015-05-20'
            options = options or {}
            _.extend options, reset: true
            @feedbackList.fetch options

        isDetectedLocation: ->
            false
        isPending: ->
            false

        otpSerializeLocation: (opts) ->
            if opts.forceCoordinates
                coords = @get('location').coordinates
                "#{coords[1]},#{coords[0]}"
            else
                "poi:tprek:#{@get 'id'}"

        getSpecifierText: ->
            specifierText = ''
            unless @get('services')?
                return specifierText
            level = null
            for service in @get 'services'
                if not level or service.level < level
                    specifierText = service.name[p13n.getLanguage()]
                    level = service.level
            return specifierText

        getComparisonKey: ->
            p13n.getTranslatedAttr @get('name')

        toJSON: (options) ->
            data = super()
            openingHours = _.filter @get('connections'), (c) ->
                c.section == 'opening_hours' and p13n.getLanguage() of c.name
            lang = p13n.getLanguage()
            if openingHours.length > 0
                data.opening_hours = _(openingHours)
                    .chain()
                    .sortBy 'type'
                    .map (hours) =>
                        content: hours.name[lang]
                        url: hours.www_url?[lang]
                    .value()

            highlights = _.filter @get('connections'), (c) ->
                c.section == 'miscellaneous' and p13n.getLanguage() of c.name
            data.highlights = _.sortBy highlights, (c) -> c.type

            links = _.filter @get('connections'), (c) ->
                c.section == 'links' and p13n.getLanguage() of c.name
            data.links = _.sortBy links, (c) -> c.type
            data

        hasBboxFilter: ->
            @collection?.filters?.bbox?

        hasAccessibilityData: ->
            # TODO: re-enable these services when data ready
            fn = (x)-> x.id in [33467, 33399]
            blacklistHits = _(@get('services')).filter(fn).length
            @get('accessibility_properties')?.length and blacklistHits == 0

        getTranslatedShortcomings: ->
            profiles = p13n.getAccessibilityProfileIds()
            {status: status, results: shortcomings} = accessibility.getTranslatedShortcomings profiles, @

        getShortcomingCount: ->
            unless @hasAccessibilityData()
                return Number.MAX_VALUE
            shortcomings = @getTranslatedShortcomings()
            @shortcomingCount = 0
            for __, group of shortcomings.results
                @shortcomingCount += _.values(group).length
            @shortcomingCount

    class UnitList extends SMCollection
        model: Unit
        comparator: null
        initialize: (models, opts) ->
            super models, opts
            @forcedPriority = opts?.forcedPriority
        getComparatorKeys: ->
            keys = []
            if p13n.hasAccessibilityIssues() then keys.push 'accessibility'
            if @overrideComparatorKeys?
                return _(@overrideComparatorKeys).union keys
            _(keys).union ['default', 'distance', 'alphabetic', 'alphabetic_reverse']
        hasReducedPriority: ->
            ret = if @forcedPriority
                false
            else
                @filters?.bbox?
            return ret

    class Department extends SMModel
        resourceName: 'department'
        translatedAttrs: ['name']

    class DepartmentList extends SMCollection
        model: Department

    class Organization extends SMModel
        resourceName: 'organization'
        translatedAttrs: ['name']

    class OrganizationList extends SMCollection
        model: Organization

    class AdministrativeDivision extends SMModel
        resourceName: 'administrative_division'
        translatedAttrs: ['name']
        getEmergencyCareUnit: ->
            if @get('type') == 'emergency_care_district'
                switch @get('ocd_id')
                    when 'ocd-division/country:fi/kunta:helsinki/päivystysalue:haartmanin_päivystysalue'
                        return 11828 # Haartman
                    when 'ocd-division/country:fi/kunta:helsinki/päivystysalue:marian_päivystysalue'
                        return 4060 # Malmi
                    # The next ID anticipates a probable change in the division name
                    when 'ocd-division/country:fi/kunta:helsinki/päivystysalue:malmin_päivystysalue'
                        return 4060 # Malmi
            null
    class AdministrativeDivisionList extends SMCollection
        model: AdministrativeDivision

    class AdministrativeDivisionType extends SMModel
        resourceName: 'administrative_division_type'

    class AdministrativeDivisionTypeList extends SMCollection
        model: AdministrativeDivision

    class Service extends SMModel
        resourceName: 'service'
        translatedAttrs: ['name']
        initialize: ->
            @set 'units', new models.UnitList null, setComparator: true
            units = @get 'units'
            units.overrideComparatorKeys = ['alphabetic', 'alphabetic_reverse', 'distance']
            units.setDefaultComparator()
        getSpecifierText: ->
            specifierText = ''
            unless @get('ancestors')?
                return specifierText
            for ancestor, index in @get 'ancestors'
                if index > 0
                    specifierText += ' • '
                specifierText += ancestor.name[p13n.getLanguage()]
            return specifierText
        getComparisonKey: ->
            p13n.getTranslatedAttr @get('name')

    class Street extends SMModel
        resourceName: 'street'
        humanAddress: ->
            name = p13n.getTranslatedAttr @get('name')
            "#{name}, #{@getMunicipalityName()}"
        getMunicipalityName: ->
            i18n.t "municipality.#{@get('municipality')}"

    class StreetList extends SMCollection
        model: Street

    class Position extends mixOf SMModel, GeoModel
        resourceName: 'address'
        origin: -> 'clicked'
        isPending: ->
            false
        urlRoot: ->
            "#{BACKEND_BASE}/#{@resourceName}"
        parse: (response, options) ->
            data = super response, options
            street = data.street
            if street
                data.street = new Street street
            data
        isDetectedLocation: ->
            false
        isReverseGeocoded: ->
            @get('street')?
        getSpecifierText: ->
            @getMunicipalityName()
        slugifyAddress: ->
            SEPARATOR = '-'
            municipality = @get('street').get('municipality')

            slug = []
            add = (x) -> slug.push x

            street = @get('street').get('name').fi.toLowerCase().replace(/\ /g, SEPARATOR)
            add @get('number')

            numberEnd = @get 'number_end'
            letter = @get 'letter'
            if numberEnd then add "#{SEPARATOR}#{numberEnd}"
            if letter then slug[slug.length-1] += SEPARATOR + letter
            @slug = "#{municipality}/#{street}/#{slug.join(SEPARATOR)}"
            @slug
        humanAddress: (opts)->
            street = @get 'street'
            result = []
            if street?
                result.push p13n.getTranslatedAttr(street.get('name'))
                result.push @humanNumber()
                if not opts?.exclude?.municipality and street.get('municipality')
                    last = result.pop()
                    last += ','
                    result.push last
                    result.push @getMunicipalityName()
                result.join(' ')
            else
                null
        getMunicipalityName: ->
            @get('street').getMunicipalityName()
        getComparisonKey: (model) ->
            street = @get 'street'
            result = []
            if street?
                result.push i18n.t("municipality.#{street.get('municipality')}")
                [number, letter] = [@get('number'), @get('letter')]
                result.push pad(number)
                result.push letter
            result.join ''

        _humanNumber: ->
            result = []
            if @get 'number'
                result.push @get 'number'
            if @get 'number_end'
                result.push '-'
                result.push @get 'number_end'
            if @get 'letter'
                result.push @get 'letter'
            result
        humanNumber: ->
            @_humanNumber().join ''
        otpSerializeLocation: (opts) ->
            coords = @get('location').coordinates
            "#{coords[1]},#{coords[0]}"

    class AddressList extends SMCollection
        model: Position

    class CoordinatePosition extends Position
        origin: ->
            if @isDetectedLocation()
                'detected'
            else
                super()
        initialize: (attrs) ->
            @isDetected = if attrs?.isDetected? then attrs.isDetected else false
        isDetectedLocation: ->
            @isDetected
        reverseGeocode: ->
            withDeferred (deferred) =>
                unless @get('street')?
                    posList = models.PositionList.fromPosition @
                    @listenTo posList, 'sync', =>
                        bestMatch = posList.first()
                        if bestMatch.get('distance') > 500
                            bestMatch.set 'name', i18n.t 'map.unknown_address'
                        @set bestMatch.toJSON()
                        deferred.resolve()
                        @trigger 'reverse-geocode'
        isPending: ->
            !@get('location')?

    class AddressPosition extends Position
        origin: -> 'address'
        initialize: (data) ->
            unless data?
                return
            super
            @set 'location',
                coordinates: data.location.coordinates
                type: 'Point'
        isDetectedLocation: ->
            false

    class PositionList extends SMCollection
        resourceName: 'address'
        @fromPosition: (position) ->
            instance = new PositionList()
            name = position.get('street')?.get('name')
            location = position.get 'location'
            instance.model = Position
            if location and not name
                instance.fetch data:
                    lat: location.coordinates[1]
                    lon: location.coordinates[0]
            else if name and not location
                opts = data:
                    municipality: position.get('street').get('municipality')
                    number: position.get('number')
                    street: name
                instance.fetch opts
            instance

        @fromSlug: (municipality, streetName, numberPart) ->
            SEPARATOR = /-/g
            numberParts = numberPart.split SEPARATOR
            number = numberParts[0]
            number = numberPart.replace /-.*$/, ''
            street = new Street ({
                name: streetName.replace(SEPARATOR, ' '),
                municipality: municipality})
            @fromPosition new Position
                street: street
                number: number
        getComparatorKeys: -> ['alphabetic']
        # parse: (resp, options) ->
        #     super resp.results, options
        url: ->
            "#{BACKEND_BASE}/#{@resourceName}/"

    class RoutingParameters extends Backbone.Model
        initialize: (attributes)->
            @set 'endpoints', attributes?.endpoints.slice(0) or [null, null]
            @set 'origin_index', attributes?.origin_index or 0
            @set 'time_mode', attributes?.time_mode or 'depart'
            @pendingPosition = new CoordinatePosition isDetected: false, preventPopup: true
            @listenTo @, 'change:time_mode', -> @triggerComplete()

        swapEndpoints: (opts)->
            @set 'origin_index', @_getDestinationIndex()
            unless opts?.silent
                @trigger 'change'
                @triggerComplete()
        setOrigin: (object, opts) ->
            index = @get 'origin_index'
            @get('endpoints')[index] = object
            @trigger 'change'
            unless opts?.silent
                @triggerComplete()
        setDestination: (object) ->
            @get('endpoints')[@_getDestinationIndex()] = object
            @trigger 'change'
            @triggerComplete()
        getDestination: ->
            @get('endpoints')[@_getDestinationIndex()]
        getOrigin: ->
            @get('endpoints')[@_getOriginIndex()]
        getEndpointName: (object) ->
            if not object?
                return ''
            else if object.isDetectedLocation()
                if object.isPending()
                    return i18n.t('transit.location_pending')
                else
                    return i18n.t('transit.current_location')
            else if object instanceof CoordinatePosition
                return i18n.t('transit.user_picked_location')
            else if object instanceof Unit
                return object.getText('name')
            else if object instanceof Position
                return object.humanAddress()
        getEndpointLocking: (object) ->
            return object instanceof models.Unit
        isComplete: ->
            for endpoint in @get 'endpoints'
                unless endpoint? then return false
                if endpoint instanceof Position
                    if endpoint.isPending()
                        return false
            true
        ensureUnitDestination: ->
            if @getOrigin() instanceof Unit
                @swapEndpoints
                    silent: true
        triggerComplete: ->
            if @isComplete()
                @trigger 'complete'
        setTime: (time, opts) ->
            datetime = @getDatetime()
            mt = moment(time)
            m = moment(datetime)
            m.hours mt.hours()
            m.minutes mt.minutes()
            datetime = m.toDate()
            @set 'time', datetime, opts
            @triggerComplete()
        setDate: (date, opts) ->
            datetime = @getDatetime()
            md = moment(date)
            datetime.setDate md.date()
            datetime.setMonth md.month()
            datetime.setYear md.year()
            @set 'time', datetime, opts
            @triggerComplete()
        setTimeAndDate: (date) ->
            @setTime(date)
            @setDate(date)
        setDefaultDatetime: ->
            @set 'time', @getDefaultDatetime()
            @triggerComplete()
        clearTime: ->
            @set 'time', null
        getDefaultDatetime: (currentDatetime) ->
            time = moment new Date()
            mode = @get 'time_mode'
            if mode == 'depart'
                return time.toDate()
            time.add 60, 'minutes'
            minutes = time.minutes()
            # Round upwards to nearest 10 min
            time.minutes (minutes - minutes % 10 + 10)
            time.toDate()
        getDatetime: ->
            time = @get('time')
            unless time?
                time = @getDefaultDatetime()
            time

        isTimeSet: ->
            @get('time')?
        setTimeMode: (timeMode) ->
            @set 'time_mode', timeMode
            @triggerComplete()

        _getOriginIndex: ->
            @get 'origin_index'
        _getDestinationIndex: ->
            (@_getOriginIndex() + 1) % 2

    class Language extends Backbone.Model

    class LanguageList extends Backbone.Collection
        model: Language

    class ServiceList extends SMCollection
        model: Service
        initialize: ->
            super
            @chosenService = null
        expand: (id, spinnerOptions = {}) ->
            if not id
                @chosenService = null
                @fetch
                    data:
                        level: 0
                    spinnerOptions: spinnerOptions
                    success: =>
                        @trigger 'finished'
            else
                @chosenService = new Service(id: id)
                @chosenService.fetch
                    success: =>
                        @fetch
                            data:
                                parent: id
                            spinnerOptions: spinnerOptions
                            success: =>
                                @trigger 'finished'

    class SearchList extends SMCollection
        model: (attrs, options) ->
                typeToModel =
                    service: Service
                    unit: Unit
                    address: Position

                type = attrs.object_type
                if type of typeToModel
                    return new typeToModel[type](attrs, options)
                else
                    Raven.captureException(
                        new Error("Unknown search result type '#{type}', #{attrs.object_type}")
                    )
                    return new Backbone.Model(attrs, options)

        search: (query, options) ->
            @currentPage = 1
            @query = query
            opts = _.extend {}, options
            opts.data =
                q: query
                language: p13n.getLanguage()
                only: 'unit.name,service.name,unit.location,unit.root_services'
                include: 'unit.accessibility_properties,service.ancestors,unit.services'
            city = p13n.get('city')
            if city
                opts.data.municipality = city
            @fetch opts
            opts

        url: ->
            return "#{BACKEND_BASE}/search/"

    class LinkedEventsModel extends SMModel
        urlRoot: ->
            return "#{LINKEDEVENTS_BASE}/#{@resourceName}/"

    class LinkedEventsCollection extends SMCollection
        url: ->
            obj = new @model
            return "#{LINKEDEVENTS_BASE}/#{obj.resourceName}/"

        parse: (resp, options) ->
            @fetchState =
                count: resp.meta.count
                next: resp.meta.next
                previous: resp.meta.previous
            RESTFrameworkCollection.__super__.parse.call @, resp.data, options


    class Event extends LinkedEventsModel
        resourceName: 'event'
        translatedAttrs: ['name', 'info_url', 'description', 'short_description',
                           'location_extra_info']
        toJSON: (options) ->
            data = super()
            data.links = _.filter @get('external_links'), (link) ->
                link.language == p13n.getLanguage()
            data

        getUnit: () ->
            unitId = @get('location')['@id'].match(/^.*tprek%3A(\d+)/)
            unless unitId?
                return null
            return new models.Unit id: unitId[1]


    class EventList extends LinkedEventsCollection
        model: Event

    class Open311Model extends SMModel
        sync: (method, model, options) ->
            _.defaults options, emulateJSON: true, data: extensions: true
            super method, model, options
        resourceNamePlural: ->
            "#{@resourceName}s"
        urlRoot: ->
            return "#{OPEN311_BASE}/#{@resourceNamePlural()}"

    class FeedbackItem extends Open311Model
        resourceName: 'request'
        url: ->
            return "#{@urlRoot()}/#{@id}.json"
        parse: (resp, options) ->
            if resp.length == 1
                return super resp[0], options
            super resp, options

    class FeedbackItemType extends Open311Model
        # incoming feedback

    class FeedbackList extends FilterableCollection
        fetch: (options) ->
            options = options or {}
            _.defaults options,
                emulateJSON: true,
                data: extensions: true
            super options
        model: FeedbackItem
        url: ->
            obj = new @model
            return "#{OPEN311_BASE}/#{obj.resourceNamePlural()}.json"

    class FeedbackMessage extends SMModel
        # outgoing feedback
        # TODO: combine the two?
        initialize: ->
            @set 'can_be_published', true
            @set 'service_request_type', 'OTHER'
            @set 'description', ''

        _serviceCodeFromPersonalisation: (type) ->
            switch type
                when 'hearing_aid' then 128
                when 'visually_impaired' then 126
                when 'wheelchair' then 121
                when 'reduced_mobility' then 123
                when 'rollator' then 124
                when 'stroller' then 125
                else 11
        validate: (attrs, options) ->
            if attrs.description == ''
                description: 'description_required'
            else if attrs.description.trim().length < 10
                @set 'description', attrs.description
                description: 'description_length'
        serialize: ->
            json = _.pick @toJSON(), 'title', 'first_name', 'description',
                'email', 'service_request_type', 'can_be_published'
            viewpoints = @get 'accessibility_viewpoints'
            if viewpoints?.length
                service_code = @_serviceCodeFromPersonalisation viewpoints[0]
            else
                if @get 'accessibility_enabled'
                    service_code = 11
                else
                    service_code = 1363
            json.service_code = service_code
            json.service_object_id = @get('unit').get 'id'
            json.service_object_type = 'http://www.hel.fi/servicemap/v2'
            json
        sync: (method, model, options) ->
            json = @serialize()
            unless @validationError
                if method == 'create'
                    $.post @urlRoot(), @serialize(), => @trigger 'sent'
        urlRoot: -> OPEN311_WRITE_BASE

    exports =
        Unit: Unit
        Service: Service
        UnitList: UnitList
        Department: Department
        DepartmentList: DepartmentList
        Organization: Organization
        OrganizationList: OrganizationList
        ServiceList: ServiceList
        AdministrativeDivision: AdministrativeDivision
        AdministrativeDivisionList: AdministrativeDivisionList
        AdministrativeDivisionType: AdministrativeDivisionType
        AdministrativeDivisionTypeList: AdministrativeDivisionTypeList
        SearchList: SearchList
        Language: Language
        LanguageList: LanguageList
        Event: Event
        WrappedModel: WrappedModel
        EventList: EventList
        RoutingParameters: RoutingParameters
        Position: Position
        CoordinatePosition: CoordinatePosition
        AddressPosition: AddressPosition
        PositionList: PositionList
        AddressList: AddressList
        FeedbackItem: FeedbackItem
        FeedbackList: FeedbackList
        FeedbackMessage: FeedbackMessage
        Street: Street
        StreetList: StreetList

    # Expose models to browser console to aid in debugging
    window.models = exports

    return exports

# Personalization support code

SUPPORTED_LANGUAGES = ['fi', 'en', 'sv']

makeMomentLang = (lang) ->
    if lang == 'en'
        return 'en-gb'
    return lang

momentDeps = ("moment/#{makeMomentLang(lang)}" for lang in SUPPORTED_LANGUAGES)

p13nDeps = [
    'module',
    'app/models',
    'underscore',
    'backbone',
    'i18next',
    'moment'].concat momentDeps

define p13nDeps, (
    module,
    models,
    _,
    Backbone,
    i18n,
    moment
) ->

    LOCALSTORAGE_KEY = 'servicemap_p13n'
    CURRENT_VERSION = 1
    LANGUAGE_NAMES =
        fi: 'suomi'
        sv: 'svenska'
        en: 'English'
    FALLBACK_LANGUAGES = ['en', 'fi']

    ACCESSIBILITY_GROUPS = {
        senses: ['hearing_aid', 'visually_impaired', 'colour_blind'],
        mobility: ['wheelchair', 'reduced_mobility', 'rollator', 'stroller'],
    }

    ALLOWED_VALUES =
        accessibility:
            mobility: [null, 'wheelchair', 'reduced_mobility', 'rollator', 'stroller']
        transport: ['by_foot', 'bicycle', 'public_transport', 'car']
        transport_detailed_choices:
            public: ['bus', 'tram', 'metro', 'train', 'ferry']
            bicycle: ['bicycle_parked', 'bicycle_with']
        language: SUPPORTED_LANGUAGES
        map_background_layer: ['servicemap', 'ortographic', 'guidemap', 'accessible_map']
        city: [null, 'helsinki', 'espoo', 'vantaa', 'kauniainen']

    PROFILE_IDS =
        'wheelchair': 1
        'reduced_mobility': 2
        'rollator': 3
        'stroller': 4
        'visually_impaired': 5
        'hearing_aid': 6

    # When adding a new personalization attribute, you must fill in a
    # sensible default.
    DEFAULTS =
        language: appSettings.default_language
        first_visit: true
        skip_tour: false
        hide_tour: false
        location_requested: false
        map_background_layer: 'servicemap'
        accessibility:
            hearing_aid: false
            visually_impaired: false
            colour_blind: false
            mobility: null
        city: null
        transport:
            by_foot: false
            bicycle: false
            public_transport: true
            car: false
        transport_detailed_choices:
            public:
                bus: true
                tram: true
                metro: true
                train: true
                ferry: true
            bicycle:
                bicycle_parked: true
                bicycle_with: false

    deepExtend = (target, source, allowedValues) ->
        for prop of target
            if prop not of source
                continue
            sourceIsObject = !!source[prop] and typeof source[prop] == 'object'
            targetIsObject = !!target[prop] and typeof target[prop] == 'object'
            if targetIsObject != sourceIsObject
                console.error "Value mismatch for #{prop}: #{typeof source[prop]} vs. #{typeof target[prop]}"
                continue

            if targetIsObject
                deepExtend target[prop], source[prop], allowedValues[prop] or {}
                continue
            if prop of allowedValues
                if target[prop] not in allowedValues[prop]
                    console.error "Invalid value for #{prop}: #{target[prop]}"
                    continue
            target[prop] = source[prop]

    class ServiceMapPersonalization
        constructor: ->
            _.extend @, Backbone.Events

            @attributes = _.clone DEFAULTS
            # FIXME: Autodetect language? Browser capabilities?
            if module.config().localStorageEnabled == false
                @localStorageEnabled = false
            else
                @localStorageEnabled = @testLocalStorageEnabled()
            @_fetch()

            @deferred = i18n.init
                lng: @getLanguage()
                resGetPath: appSettings.static_path + 'locales/__lng__.json'
                fallbackLng: FALLBACK_LANGUAGES

            #TODO: This should be moved to a more appropriate place (and made nicer)
            i18n.addPostProcessor "fixFinnishStreetNames", (value, key, options) ->
                REPLACEMENTS = "_allatiivi_": [
                    [/katu$/, "kadulle"],
                    [/polku$/, "polulle"],
                    [/ranta$/, "rannalle"],
                    [/ramppia$/, "rampille"],
                    [/$/, "lle"]
                ],
                "_partitiivi_": [
                    [/tie$/, "tietä"],
                    [/Kehä I/, "Kehä I:tä"]
                    [/Kehä III/, "Kehä III:a"]
                    [/ä$/, "ää"],
                    [/$/, "a"]
                ]
                for grammaticalCase, rules of REPLACEMENTS
                    if value.indexOf(grammaticalCase) > -1
                        for replacement in rules
                            if options.street.match(replacement[0])
                                options.street = options.street.replace(replacement[0], replacement[1]);
                                return value.replace(grammaticalCase, options.street)

            moment.locale makeMomentLang(@getLanguage())
            # debugging: make i18n available from JS console
            window.i18nDebug = i18n

        testLocalStorageEnabled: () =>
            val = '_test'
            try
                localStorage.setItem val, val
                localStorage.removeItem val
                return true
            catch e
                return false

        _handleLocation: (pos, positionObject) =>
            if pos.coords.accuracy > 10000
                @trigger 'position_error'
                return
            unless positionObject?
                positionObject = new models.CoordinatePosition isDetected: true
            cb = =>
                coords = pos['coords']
                positionObject.set 'location',
                    coordinates: [coords.longitude, coords.latitude]
                positionObject.set 'accuracy', pos.coords.accuracy
                @lastPosition = positionObject
                @trigger 'position', positionObject
                if not @get 'location_requested'
                    @set 'location_requested', true
            if appSettings.user_location_delayed
                setTimeout cb, 3000
            else
                cb()

        _handleLocationError: (error) =>
            @trigger 'position_error'
            @set 'location_requested', false

        setVisited: ->
            @_setValue ['first_visit'], false

        getLastPosition: ->
            return @lastPosition

        getLocationRequested: ->
            return @get 'location_requested'

        _setValue: (path, val) ->
            pathStr = path.join '.'
            vars = @attributes
            allowed = ALLOWED_VALUES
            dirs = path.slice 0
            propName = dirs.pop()
            for name in dirs
                if name not of vars
                    throw new Error "Attempting to set invalid variable name: #{pathStr}"
                vars = vars[name]
                if not allowed
                    continue
                if name not of allowed
                    allowed = null
                    continue
                allowed = allowed[name]

            if allowed and propName of allowed
                if val not in allowed[propName]
                    throw new Error "Invalid value for #{pathStr}: #{val}"
            else if typeof val != 'boolean'
                throw new Error "Invalid value for #{pathStr}: #{val} (should be boolean)"

            oldVal = vars[propName]
            if oldVal == val
                return
            vars[propName] = val

            # save changes
            @_save()
            # notify listeners
            @trigger 'change', path, val
            if path[0] == 'accessibility'
                @trigger 'accessibility-change'
            val

        toggleMobility: (val) ->
            oldVal = @getAccessibilityMode 'mobility'
            if val == oldVal
                @_setValue ['accessibility', 'mobility'], null
            else
                @_setValue ['accessibility', 'mobility'], val
        toggleAccessibilityMode: (modeName) ->
            oldVal = @getAccessibilityMode modeName
            @_setValue ['accessibility', modeName], !oldVal
        setAccessibilityMode: (modeName, val) ->
            @_setValue ['accessibility', modeName], val
        getAccessibilityMode: (modeName) ->
            accVars = @get 'accessibility'
            if not modeName of accVars
                throw new Error "Attempting to get invalid accessibility mode: #{modeName}"
            return accVars[modeName]
        toggleCity: (val) ->
            oldVal = @get 'city'
            if val == oldVal
                val = null
            @_setValue ['city'], val

        getAllAccessibilityProfileIds: ->
            rawIds = _.invert PROFILE_IDS
            ids = {}
            for rid, name of rawIds
                suffixes = switch
                    when _.contains(["1", "2", "3"], rid) then ['A', 'B', 'C']
                    when _.contains(["4", "6"], rid) then ['A']
                    when "5" == rid then ['A', 'B']
                for s in suffixes
                    ids[rid + s] = name
            ids

        getAccessibilityProfileIds: (filterTransit) ->
            # filterTransit: if true, only return profiles which
            # affect transit routing.
            ids = {}
            accVars = @get 'accessibility'
            transport = @get 'transport'
            mobility = accVars['mobility']
            key = PROFILE_IDS[mobility]
            if key
                if key in [1, 2, 3, 5]
                    key += if transport.car then 'B' else 'A'
                else
                    key += 'A'
                ids[key] = mobility
            disabilities = ['visually_impaired']
            unless filterTransit
                disabilities.push 'hearing_aid'
            for disability in disabilities
                val = @getAccessibilityMode disability
                if val
                    key = PROFILE_IDS[disability]
                    if disability == 'visually_impaired'
                        key += if transport.car then 'B' else 'A'
                    else
                        key += 'A'
                    ids[key] = disability
            ids

        hasAccessibilityIssues: ->
            ids = @getAccessibilityProfileIds()
            _.size(ids) > 0

        setTransport: (modeName, val) ->
            modes = @get 'transport'
            if val
                if modeName == 'by_foot'
                    for m of modes
                        modes[m] = false
                else if modeName in ['car', 'bicycle']
                    for m of modes
                        if m == 'public_transport'
                            continue
                        modes[m] = false
                else if modeName == 'public_transport'
                    modes.by_foot = false
            else
                otherActive = false
                for m of modes
                    if m == modeName
                        continue
                    if modes[m]
                        otherActive = true
                        break
                if not otherActive
                    return

            @_setValue ['transport', modeName], val

        getTransport: (modeName) ->
            modes = @get 'transport'
            if not modeName of modes
                throw new Error "Attempting to get invalid transport mode: #{modeName}"
            return modes[modeName]

        toggleTransport: (modeName) ->
            oldVal = @getTransport modeName
            @setTransport modeName, !oldVal

        toggleTransportDetails: (group, modeName) ->
            oldVal = @get('transport_detailed_choices')[group][modeName]
            if !oldVal
                if modeName == 'bicycle_parked'
                    @get('transport_detailed_choices')[group].bicycle_with = false
                if modeName == 'bicycle_with'
                    @get('transport_detailed_choices')[group].bicycle_parked = false
            @_setValue ['transport_detailed_choices', group, modeName], !oldVal

        requestLocation: (positionModel) ->
            if appSettings.user_location_override
                override = appSettings.user_location_override
                coords =
                    latitude: override[0]
                    longitude: override[1]
                    accuracy: 10
                @_handleLocation coords: coords
                return

            if 'geolocation' not of navigator
                return
            posOpts =
                enableHighAccuracy: false
                timeout: 30000
            navigator.geolocation.getCurrentPosition ((pos) => @_handleLocation(pos, positionModel)),
                @_handleLocationError, posOpts

        set: (attr, val) ->
            if not attr of @attributes
                throw new Error "attempting to set invalid attribute: #{attr}"
            @attributes[attr] = val
            @trigger 'change', attr, val
            @_save()

        get: (attr) ->
            if not attr of @attributes
                return undefined
            return @attributes[attr]

        _verifyValidState: ->
            transportModesCount = _.filter(@get('transport'), _.identity).length
            if transportModesCount == 0
                @setTransport 'public_transport', true

        _fetch: ->
            if not @localStorageEnabled
                return

            str = localStorage.getItem LOCALSTORAGE_KEY
            if not str
                return

            storedAttrs = JSON.parse str
            deepExtend @attributes, storedAttrs, ALLOWED_VALUES
            @_verifyValidState()

        _save: ->
            if not @localStorageEnabled
                return

            data = _.extend @attributes, version: CURRENT_VERSION
            str = JSON.stringify data
            localStorage.setItem LOCALSTORAGE_KEY, str

        getProfileElement: (name) ->
            icon: "icon-icon-#{name.replace '_', '-'}"
            text: i18n.t("personalisation.#{name}")

        getProfileElements: (profiles) ->
            _.map(profiles, @getProfileElement)

        getLanguage: ->
            return appSettings.default_language

        getTranslatedAttr: (attr) ->
            if not attr
                return attr

            if not attr instanceof Object
                console.error "translated attribute didn't get a translation object", attr
                return attr

            # Try primary choice first, fallback to whatever's available.
            languages = [@getLanguage()].concat SUPPORTED_LANGUAGES
            for lang in languages
                if lang of attr
                    return attr[lang]

            console.error "no supported languages found", attr
            return null

        getSupportedLanguages: ->
            _.map SUPPORTED_LANGUAGES, (l) ->
                code: l
                name: LANGUAGE_NAMES[l]

        getHumanizedDate: (time) ->
            m = moment time
            now = moment()
            sod = now.startOf 'day'
            diff = m.diff sod, 'days', true
            if diff < -6 or diff >= 7
                humanize = false
            else
                humanize = true
            if humanize
                s = m.calendar()
                s = s.replace /( (klo|at))* \d{1,2}[:.]\d{1,2}$/, ''
            else
                if now.year() != m.year()
                    format = 'L'
                else
                    format = switch @getLanguage()
                        when 'fi' then 'Do MMMM[ta]'
                        when 'en' then 'D MMMM'
                        when 'sv' then 'D MMMM'
                s = m.format format
            return s

        setMapBackgroundLayer: (layerName) ->
            @_setValue ['map_background_layer'], layerName

        getMapBackgroundLayers: ->
            a =_(ALLOWED_VALUES.map_background_layer)
                .chain()
                .union ['accessible_map']
                .map (layerName) =>
                    name: layerName,
                    selected: @get('map_background_layer') == layerName
                .value()

    # Make it a globally accessible variable for convenience
    window.p13n = new ServiceMapPersonalization
    return window.p13n

define ['backbone.marionette', 'URI'], (Marionette, URI) ->

    class BaseRouter extends Backbone.Marionette.AppRouter
        initialize: (options) ->
            super options
            @controller = options.controller
            @makeMapView = options.makeMapView
            @appRoute /^\/?([^\/]*)$/, 'renderHome'
            @appRoute /^unit\/?([^\/]*)$/, 'renderUnit'
            @appRoute /^division\/?(.*?)$/, 'renderDivision'
            @appRoute /^address\/(.*?)$/, 'renderAddress'
            @appRoute /^search(\?[^\/]*)$/, 'renderSearch'
            @appRoute /^division(\?.*?)$/, 'renderMultipleDivisions'

        onPostRouteExecute: ->

        executeRoute: (callback, args, context) ->
            callback?.apply(@, args)?.done (opts) =>
                mapOpts = {}
                if context.query?
                    mapOpts.bbox = context.query.bbox
                    mapOpts.level = context.query.level
                @makeMapView mapOpts
                opts?.afterMapInit?()
                @onPostRouteExecute()

        processQuery: (q) ->
            if q.bbox? and q.bbox.match /([0-9]+\.?[0-9+],)+[0-9]+\.?[0-9+]/
                q.bbox = q.bbox.split ','
            if q.ocd_id? and q.ocd_id.match /([^,]+,)*[^,]+/
                q.ocdId = q.ocd_id.split ','
                delete q.ocd_id
            return q

        execute: (callback, args) ->
            # The map view must only be initialized once
            # the state encoded in the route URL has been
            # reconstructed. The state affects the map
            # centering, zoom, etc.o
            context = {}
            lastArg = args[args.length - 1]
            fullUri = new URI window.location.toString()
            unless args.length < 1 or lastArg == null
                newArgs = URI(lastArg).segment()
            else
                newArgs = []
            if fullUri.query()
                context.query = @processQuery fullUri.search(true)
                if context.query.map?
                    p13n.setMapBackgroundLayer context.query.map
                if context.query.city?
                    p13n.set 'city', context.query.city
                newArgs.push context
            @executeRoute callback, newArgs, context

        routeEmbedded: (uri) ->
            # An alternative implementation of 'static' routing
            # for browsers without pushState when creating
            # an embedded view.
            path = uri.segment()
            resource = path[0]
            callback = if resource == 'division'
                if 'ocd_id' of uri.search(true)
                    'renderMultipleDivisions'
                else
                    'renderDivision'
            else
                switch resource
                    when '' then 'renderHome'
                    when 'unit' then 'renderUnit'
                    when 'search' then 'renderSearch'
                    when 'address' then 'renderAddress'
            uri.segment 0, '' # remove resource from path
            relativeUri = new URI uri.pathname() + uri.search()
            callback = _.bind @controller[callback], @controller
            @execute callback, [relativeUri.toString()]

define [
    'backbone',
    'typeahead.bundle',
    'app/p13n',
    'app/settings'
],
(
    Backbone,
    ta,
    p13n,
    settings
) ->

    lang = p13n.getLanguage()
    servicemapEngine = new Bloodhound
        name: 'suggestions'
        remote:
            url: appSettings.service_map_backend + "/search/?language=#{lang}&page_size=4&input="
            replace: (url, query) =>
                url += query
                city = p13n.get('city')
                if city
                    url += "&municipality=#{city}"
                url
            ajax: settings.applyAjaxDefaults {}
            filter: (parsedResponse) ->
                parsedResponse.results
            rateLimitWait: 50
        datumTokenizer: (datum) -> Bloodhound.tokenizers.whitespace datum.name[lang]
        queryTokenizer: Bloodhound.tokenizers.whitespace
    linkedeventsEngine = new Bloodhound
        name: 'events_suggestions'
        remote:
            url: appSettings.linkedevents_backend + "/search/?language=#{lang}&page_size=4&input=%QUERY"
            ajax: settings.applyAjaxDefaults {}
            filter: (parsedResponse) ->
                parsedResponse.data
            rateLimitWait: 50
        datumTokenizer: (datum) -> Bloodhound.tokenizers.whitespace datum.name[lang]
        queryTokenizer: Bloodhound.tokenizers.whitespace

    servicemapEngine.initialize()
    linkedeventsEngine.initialize()

    linkedeventsEngine: linkedeventsEngine
    servicemapEngine: servicemapEngine

define ->

    ieVersion = getIeVersion()

    applyAjaxDefaults = (settings) ->
        settings.cache = true
        if not ieVersion
            return settings
        if ieVersion >= 10
            return settings

        # JSONP for older IEs
        settings.dataType = 'jsonp'
        settings.data = settings.data || {}
        settings.data.format = 'jsonp'
        return settings

    return {
        applyAjaxDefaults: applyAjaxDefaults
    }

define [
    'underscore',
    'spin'
], (
    _,
    Spinner
) ->

    class SMSpinner

        DEFAULTS =
            lines: 12,                      # The number of lines to draw
            length: 7,                      # The length of each line
            width: 5,                       # The line thickness
            radius: 10,                     # The radius of the inner circle
            rotate: 0,                      # Rotation offset
            corners: 1,                     # Roundness (0..1)
            color: '#000',                  # #rgb or #rrggbb
            direction: 1,                   # 1: clockwise, -1: counterclockwise
            speed: 1,                       # Rounds per second
            trail: 100,                     # Afterglow percentage
            opacity: 1/4,                   # Opacity of the lines
            fps: 20,                        # Frames per second when using setTimeout()
            zIndex: 2e9,                    # Use a high z-index by default
            className: 'spinner',           # CSS class to assign to the element
            top: '50%',                     # center vertically
            left: '50%',                    # center horizontally
            position: 'absolute'            # element position
            hideContainerContent: false   # if true, hides all child elements inside spinner container

        constructor: (options) ->
            @options = _.extend(DEFAULTS, options)
            @container = @options.container
            @finished = false

        start: ->
            if @finished then return
            if @container
                if @options.hideContainerContent
                    $(@container).children().css('visibility', 'hidden')

                @spinner = new Spinner(@options).spin(@container)

        stop: ->
            @finished = true
            if @container and @spinner
                @spinner.stop()
                if @options.hideContainerContent
                    $(@container).children().css('visibility', 'visible')

    return SMSpinner

define [
    'bootstrap-tour',
    'i18next',
    'app/jade',
    'app/models',
], (
    _bst, # imports Tour
    {t: t},
    jade,
    models
) ->

    # TODO: vary by municipality
    unit = new models.Unit id:8215
    STEPS = [
        {
            orphan: true
        },
        {
            element: '#navigation-header'
            placement: 'bottom'
            backdrop: true
        },
        {
            element: '#search-region'
            placement: 'right'
            backdrop: true
            onShow: (tour) ->
                $container = $('#search-region')
                $input = $container.find('input')
                $input.typeahead('val', '')
                # TODO: translate example query
                $input.typeahead('val', 'terve')
                $input.val 'terve'
                $input.click()
            onHide: ->
                $container = $('#search-region')
                $input = $container.find('input')
                $input.typeahead('val', '')
        },
        {
            element: '#browse-region'
            placement: 'right'
            backdrop: true
            onShow: (tour) ->
                $container = $('#browse-region')
                _.defer =>
                    $container.click()
        },
        {
            element: '.service-hover-color-50003'
            placement: 'right'
            backdrop: true
        },
        {
            element: '.leaflet-marker-icon'
            placement: 'bottom'
            backdrop: false
            onShow: (tour) ->
                unit.fetch
                    data: include: 'root_services,department,municipality,services'
                    success: -> app.commands.execute 'selectUnit', unit
        },
        {
            element: '.route-section'
            placement: 'right'
            backdrop: true
            onNext: ->
                app.commands.execute 'clearSelectedUnit'
        },
        {
            element: '#personalisation'
            placement: 'left'
            backdrop: true
        },
        {
            element: '#personalisation'
            placement: 'left'
            backdrop: true,
            onShow: ->
                $('#personalisation .personalisation-button').click()
            onHide: ->
                $('#personalisation .ok-button').click()
        },
        {
            element: '#service-cart'
            placement: 'left'
            backdrop: true
        },
        {
            element: '#language-selector'
            placement: 'left'
            backdrop: true
        },
        {
            element: '#persistent-logo .feedback-prompt'
            placement: 'left'
            backdrop: true
        },
        {
            onShow: (tour) ->
                app.commands.execute 'home'
                # TODO: default zoom
                p13n.set 'skip_tour', true
                $('#app-container').one 'click', =>
                    tour.end()
            onShown: (tour) ->
                $container = $ tour.getStep(tour.getCurrentStep()).container
                $step = $($container).children()
                $step.attr('tabindex', -1).focus()
                $('.tour-success', $container).on 'click', (ev) =>
                    tour.end()
                $container.find('a.service').on 'click', (ev) =>
                    tour.end()
                    app.commands.execute 'addService',
                        new models.Service(id: $(ev.currentTarget).data('service'))
            orphan: true
        },
    ]
    NUM_STEPS = STEPS.length
    getExamples = =>
        [
            {
                key: 'health'
                name: t('tour.examples.health')
                service: 25002
            },
            {
                key: 'beach'
                name: t('tour.examples.beach')
                service: 33467
            },
            {
                key: 'art'
                name: t('tour.examples.art')
                service: 25658
            },
            {
                key: 'glass_recycling'
                name: t('tour.examples.glass_recycling')
                service: 29475
            },
        ]

    startTour: ->
        selected = p13n.getLanguage()
        languages = _.chain p13n.getSupportedLanguages()
            .map (l) => l.code
            .filter (l) => l != selected
            .value()
        tour = new Tour
            template: (i, step) ->
                step.length = NUM_STEPS - 2
                step.languages = languages
                step.first = step.next == 1
                step.last = step.next == -1
                if step.last
                    step.examples = getExamples()
                jade.template 'tour', step
            storage : false
            container: '#tour-region'
            onShown: (tour) ->
                $step = $('#' + @id)
                $step.attr('tabindex', -1).focus()
            onEnd: (tour) ->
                p13n.set 'skip_tour', true
                p13n.trigger 'tour-skipped'
        for step, i in STEPS
            step.title = t("tour.steps.#{i}.title")
            step.content = t("tour.steps.#{i}.content")
            tour.addStep step
        tour.start true

define ->

    # Original structure from:
    # https://github.com/reitti/reittiopas/blob/90a4d5f20bed3868b5fb608ee1a1c7ce77b70ed8/web/js/utils.coffee
    hslColors =
        #walk: '#9ab9c9' # walking; HSL official color is too light #bee4f8
        walk: '#7a7a7a' # changed from standard for legibility
        wait: '#999999' # waiting time at a stop
        1:    '#007ac9' # Helsinki internal bus lines
        2:    '#00985f' # Trams
        3:    '#007ac9' # Espoo internal bus lines
        4:    '#007ac9' # Vantaa internal bus lines
        5:    '#007ac9' # Regional bus lines
        6:    '#ff6319' # Metro
        7:    '#00b9e4' # Ferry
        8:    '#007ac9' # U-lines
        12:   '#64be14' # Commuter trains
        21:   '#007ac9' # Helsinki service lines
        22:   '#007ac9' # Helsinki night buses
        23:   '#007ac9' # Espoo service lines
        24:   '#007ac9' # Vantaa service lines
        25:   '#007ac9' # Region night buses
        36:   '#007ac9' # Kirkkonummi internal bus lines
        38:   '#007ac9' # Undocumented, assumed bus
        39:   '#007ac9' # Kerava internal bus lines

    googleColors =
        WALK: hslColors.walk
        CAR: hslColors.walk
        BICYCLE: hslColors.walk
        WAIT: hslColors.wait
        0: hslColors[2]
        1: hslColors[6]
        2: hslColors[12]
        3: hslColors[5]
        4: hslColors[7]
        109: hslColors[12]

    class TransitMapMixin
        initializeTransitMap: (opts) ->
            @listenTo opts.route, 'change:plan', (route) =>
                if route.has 'plan'
                    @drawItinerary route
                else
                    @clearItinerary()
            if opts.selectedUnits?
                @listenTo opts.selectedUnits, 'reset', @clearItinerary
            if opts.selectedPosition?
                @listenTo opts.selectedPosition, 'change:value', @clearItinerary

        # Renders each leg of the route to the map
        createRouteLayerFromItinerary: (itinerary) ->
            routeLayer = L.featureGroup()
            alertLayer = L.featureGroup()
            legs = itinerary.legs

            sum = (xs) -> _.reduce(xs, ((x, y) -> x+y), 0)
            totalWalkingDistance = sum(leg.distance for leg in legs when leg.distance and not leg.routeType?)
            totalWalkingDuration = sum(leg.duration for leg in legs when leg.distance and not leg.routeType?)

            routeIncludesTransit = _.any(leg.routeType? for leg in legs)

            mins = Math.ceil(itinerary.duration/1000/60)
            walkMins = Math.ceil(totalWalkingDuration/1000/60)
            walkKms = Math.ceil(totalWalkingDistance/100)/10

            for leg in legs
                points = (new L.LatLng(point[0], point[1]) for point in leg.legGeometry.points)
                color = googleColors[leg.routeType ? leg.mode]
                style =
                    color: color
                    stroke: true
                    fill: false
                    opacity: 0.8

                polyline = new L.Polyline points, style

                # Make zooming to the leg via click possible.
                polyline.on 'click', (e) ->
                    @._map.fitBounds(polyline.getBounds())
                    if marker?
                        marker.openPopup()
                polyline.addTo routeLayer

                if leg.alerts
                    style =
                        color: '#ff3333'
                        opacity: 0.2
                        fillOpacity: 0.4
                        weight: 5
                        clickable: true
                    for alert in leg.alerts
                        if alert.geometry
                            alertpoly = new L.geoJson alert.geometry, style: style
                            if alert.alertDescriptionText
                                alertpoly.bindPopup alert.alertDescriptionText.someTranslation, closeButton: false
                            alertpoly.addTo alertLayer

                # Always show route and time information at the leg start position
                if false
                    stop = leg.from
                    lastStop = leg.to
                    point = y: stop.lat, x: stop.lon
                    icon = L.divIcon className: "navigator-div-icon"
                    label = "<span style='font-size: 24px;'><img src='static/images/#{google_icons[leg.routeType ? leg.mode]}' style='vertical-align: sub; height: 24px'/><span>#{leg.route}</span></span>"

                    marker = L.marker(new L.LatLng(point.y, point.x), {icon: icon}).addTo(routeLayer)
                        .bindPopup "<b>Time: #{moment(leg.startTime).format("HH:mm")}&mdash;#{moment(leg.endTime).format("HH:mm")}</b><br /><b>From:</b> #{stop.name or ""}<br /><b>To:</b> #{lastStop.name or ""}"

            route: routeLayer, alerts: alertLayer

        drawItinerary: (route) ->
            if @routeLayer?
                @clearItinerary()
            {route: @routeLayer, alerts: @alertLayer} =
                @createRouteLayerFromItinerary route.getSelectedItinerary()
            @skipMoveend = true
            @map.refitAndAddLayer @routeLayer
            @map.addLayer @alertLayer
            #_.defer => window.mapView.fitItinerary(@routeLayer)

        clearItinerary: ->
            if @routeLayer
                @map.removeLayer @routeLayer
                @map.adapt()
            if @alertLayer
                @map.removeLayer @alertLayer
            @routeLayer = null
            @alertLayer = null

define [
    'backbone',
    'leaflet'
], (
    Backbone,
    L
) ->
    # General functions taken from https://github.com/HSLdevcom/navigator-proto

    modeMap =
        tram: 'TRAM'
        bus: 'BUS'
        metro: 'SUBWAY'
        ferry: 'FERRY'
        train: 'RAIL'

    # Route received from OTP is encoded so it needs to be decoded.
    # translated from https://github.com/ahocevar/openlayers/blob/master/lib/OpenLayers/Format/EncodedPolyline.js
    decodePolyline = (encoded, dims) ->
        # Start from origo
        point = (0 for i in [0...dims])

        # Loop over the encoded input string
        i = 0
        points = while i < encoded.length
            for dim in [0...dims]
                result = 0
                shift = 0
                loop
                    b = encoded.charCodeAt(i++) - 63
                    result |= (b & 0x1f) << shift
                    shift += 5
                    break unless b >= 0x20

                point[dim] += if result & 1 then ~(result >> 1) else result >> 1

            # Keep a copy in the result list
            point.slice(0)

        return points

    # (taken from https://github.com/HSLdevcom/navigator-proto)
    # clean up oddities in routing result data from OTP
    otpCleanup = (data) ->
        for itinerary in data.plan?.itineraries or []
            legs = itinerary.legs
            length = legs.length
            last = length-1

            # if there's time past walking in either end, add that to walking
            # XXX what if it's not walking?
            if not legs[0].routeType and legs[0].startTime != itinerary.startTime
                legs[0].startTime = itinerary.startTime
                legs[0].duration = legs[0].endTime - legs[0].startTime
            if not legs[last].routeType and legs[last].endTime != itinerary.endTime
                legs[last].endTime = itinerary.endTime
                legs[last].duration = legs[last].endTime - legs[last].startTime

            newLegs = []
            time = itinerary.startTime # tracks when next leg should start
            for leg in itinerary.legs
                # Route received from OTP is encoded so it needs to be decoded.
                points = decodePolyline leg.legGeometry.points, 2
                points = ((x * 1e-5 for x in coords) for coords in points)
                leg.legGeometry.points = points

                # if there's unaccounted time before a walking leg
                if leg.startTime - time > 1000 and leg.routeType == null
                    # move non-transport legs to occur before wait time
                    waitTime = leg.startTime-time
                    time = leg.endTime
                    leg.startTime -= waitTime
                    leg.endTime -= waitTime
                    newLegs.push leg
                    # add the waiting time as a separate leg
                    newLegs.push createWaitLeg leg.endTime, waitTime,
                        _.last(leg.legGeometry.points), leg.to.name
                # else if there's unaccounted time before a leg
                else if leg.startTime - time > 1000
                    waitTime = leg.startTime-time
                    time = leg.endTime
                    # add the waiting time as a separate leg
                    newLegs.push createWaitLeg leg.startTime - waitTime,
                        waitTime, leg.legGeometry.points[0], leg.from.name
                    newLegs.push leg
                else
                    newLegs.push leg
                    time = leg.endTime # next leg should start when this ended
            itinerary.legs = newLegs
        return data

    createWaitLeg = (startTime, duration, point, placename) ->
        leg =
            mode: "WAIT"
            routeType: null # non-transport
            route: ""
            duration: duration
            startTime: startTime
            endTime: startTime + duration
            legGeometry: {points: [point]}
            from:
                lat: point[0]
                lon: point[1]
                name: placename
        leg.to = leg.from
        return leg

    class Route extends Backbone.Model
        initialize: ->
            @set 'selected_itinerary', 0
            @set 'plan', null
            @listenTo @, 'change:selected_itinerary', =>
                @trigger 'change:plan', @

        abort: ->
            if not @xhr
                return
            @xhr.abort()
            @xhr = null

        requestPlan: (from, to, opts) ->
            opts = opts or {}

            if @xhr
                @xhr.abort()
                @xhr = null

            modes = ['WALK']
            if opts.bicycle
                modes = ['BICYCLE']
            if opts.car
                if opts.transit
                    modes = ['CAR_PARK', 'WALK']
                else
                    modes = ['CAR']
            if opts.transit
                modes.push 'TRANSIT'
            else
                modes = _.union modes,
                    _(opts.modes).map (m) => modeMap[m]

            data =
                fromPlace: from
                toPlace: to
                mode: modes.join ','
                numItineraries: 3
                showIntermediateStops: 'true'
                locale: p13n.getLanguage()

            if opts.wheelchair
                data.wheelchair = true

            if opts.walkReluctance
                data.walkReluctance = opts.walkReluctance

            if opts.walkBoardCost
                data.walkBoardCost = opts.walkBoardCost

            if opts.walkSpeed
                data.walkSpeed = opts.walkSpeed

            if opts.minTransferTime
                data.minTransferTime = opts.minTransferTime

            if opts.date and opts.time
                data.date = opts.date
                data.time = opts.time

            if opts.arriveBy
                data.arriveBy = true

            args =
                dataType: 'json'
                url: appSettings.otp_backend
                data: data
                success: (data) =>
                    @xhr = null
                    if 'error' of data
                        @trigger 'error'
                        return

                    data = otpCleanup data
                    @set 'selected_itinerary', 0
                    @set 'plan', data.plan
                error: =>
                    @clear()
                    @trigger 'error'

            @xhr = $.ajax args

        getSelectedItinerary: ->
            @get('plan').itineraries[@get 'selected_itinerary']

        clear: ->
            @set 'plan', null

    exports =
        Route: Route

define ->
    # Include the UserVoice JavaScript SDK (only needed once on a page)
    init = (locale) ->
        if locale == 'sv'
            locale = 'sv-SE'
        UserVoice = window.UserVoice or []
        window.UserVoice = UserVoice
        (->
          uv = document.createElement("script")
          uv.type = "text/javascript"
          uv.async = true
          uv.src = "//widget.uservoice.com/f5qbSk7oBie0rWE0W4ig.js"
          s = document.getElementsByTagName("script")[0]
          s.parentNode.insertBefore uv, s
          return
        )()

        # Set colors
        UserVoice.push [
          "set"
          {
            locale: locale
            accent_color: "#1964e6"
            trigger_color: "white"
            post_idea_enabled: false
            smartvote_enabled: false
            screenshot_enabled: false
            trigger_background_color: "rgba(46, 49, 51, 0.6)"
          }
        ]

    # Or, use your own custom trigger:
    #UserVoice.push(['addTrigger', '#id', { mode: 'contact' }]);
    return init: init

define [
    'app/views/base',
], (
    base
) ->

    class AccessibilityPersonalisationView extends base.SMItemView
        className: 'accessibility-personalisation'
        template: 'accessibility-personalisation'
        initialize: (@activeModes) ->
        serializeData: ->
            accessibility_viewpoints: @activeModes

define [
    'underscore',
    'i18next',
    'moment',
    'app/accessibility',
    'app/accessibility-sentences',
    'app/p13n',
    'app/views/base',

], (
    _,
    i18n,
    moment,
    accessibility,
    accessibilitySentences,
    p13n,
    base,
)  ->

    class AccessibilityViewpointView extends base.SMItemView
        template: 'accessibility-viewpoint-summary'

        initialize: (opts) ->
            @filterTransit = opts?.filterTransit or false
            @template = @options.template or @template
        serializeData: ->
            profiles = p13n.getAccessibilityProfileIds @filterTransit
            profile_set: _.keys(profiles).length
            profiles: p13n.getProfileElements profiles


    class AccessibilityDetailsView extends base.SMLayout
        className: 'unit-accessibility-details'
        template: 'unit-accessibility-details'
        regions:
            'viewpointRegion': '.accessibility-viewpoint'
        events:
            'click #accessibility-collapser': 'toggleCollapse'
        toggleCollapse: ->
            @collapsed = !@collapsed
            true # important: bubble the event
        initialize: ->
            @listenTo p13n, 'change', @render
            @listenTo accessibility, 'change', @render
            @collapsed = true
            @accessibilitySentences = {}
            accessibilitySentences.fetch id: @model.id,
                (data) =>
                    @accessibilitySentences = data
                    @render()
        onRender: ->
            if @model.hasAccessibilityData()
                @viewpointRegion.show new AccessibilityViewpointView()

        _calculateSentences: ->
             _.object _.map(
                 @accessibilitySentences.sentences,
                     (sentences, groupId) =>
                         [p13n.getTranslatedAttr(@accessibilitySentences.groups[groupId]),
                          _.map(sentences, (sentence) -> p13n.getTranslatedAttr sentence)])

        serializeData: ->
            hasData = @model.hasAccessibilityData()
            shortcomingsPending = false

            profiles = p13n.getAccessibilityProfileIds()
            if _.keys(profiles).length
                profileSet = true
            else
                profileSet = false
                profiles = p13n.getAllAccessibilityProfileIds()

            if hasData
                {status: status, results: shortcomings} = @model.getTranslatedShortcomings()
                shortcomingsPending = (status == 'pending')
            else
                shortcomings = {}

            shortcomingsCount = 0
            for __, group of shortcomings
                shortcomingsCount += _.values(group).length

            sentenceGroups = []
            details = []
            if 'error' of @accessibilitySentences
                details = null
                sentenceGroups = null
                sentenceError = true
            else
                details = @_calculateSentences()
                sentenceGroups = _.map _.values(@accessibilitySentences.groups), (v) ->
                    p13n.getTranslatedAttr(v)
                sentenceError = false

            collapseClasses = []
            headerClasses = []
            if @collapsed
                headerClasses.push 'collapsed'
            else
                collapseClasses.push 'in'

            shortText = ''
            if _.keys(profiles).length
                if hasData
                    if shortcomingsCount
                        if profileSet
                            headerClasses.push 'has-shortcomings'
                            shortText = i18n.t('accessibility.shortcoming_count', {count: shortcomingsCount})
                    else
                        if shortcomingsPending
                            headerClasses.push 'shortcomings-pending'
                            shortText = i18n.t('accessibility.pending')
                        else if profileSet
                            headerClasses.push 'no-shortcomings'
                            shortText = i18n.t('accessibility.no_shortcomings')
                else
                    groups = @accessibilitySentences.groups
                    unless (groups? and _(groups).keys().length > 0)
                        shortText = i18n.t('accessibility.no_data')

            iconClass = if profileSet
                p13n.getProfileElements(profiles).pop()['icon']
            else
                'icon-icon-wheelchair'

            has_data: hasData
            profile_set: profileSet
            icon_class: iconClass
            shortcomings_pending: shortcomingsPending
            shortcomings_count: shortcomingsCount
            shortcomings: shortcomings
            groups: sentenceGroups
            details: details
            sentence_error: sentenceError
            header_classes: headerClasses.join ' '
            collapse_classes: collapseClasses.join ' '
            short_text: shortText
            feedback: @getDummyFeedback()

        getDummyFeedback: ->
            now = new Date()
            yesterday = new Date(now.setDate(now.getDate() - 1))
            lastMonth = new Date(now.setMonth(now.getMonth() - 1))
            feedback = []
            feedback.push(
                time: moment(yesterday).calendar()
                profile: 'wheelchair user.'
                header: 'The ramp is too steep'
                content: "The ramp is just bad! It's not connected to the entrance stand out clearly. Outside the door there is sufficient room for moving e.g. with a wheelchair. The door opens easily manually."
            )
            feedback.push(
                time: moment(lastMonth).calendar()
                profile: 'rollator user'
                header: 'Not accessible at all and the staff are unhelpful!!!!'
                content: "The ramp is just bad! It's not connected to the entrance stand out clearly. Outside the door there is sufficient room for moving e.g. with a wheelchair. The door opens easily manually."
            )

            feedback

        leaveFeedbackOnAccessibility: (event) ->
            event.preventDefault()
            # TODO: Add here functionality for leaving feedback.


    AccessibilityDetailsView: AccessibilityDetailsView
    AccessibilityViewpointView: AccessibilityViewpointView

define [
    'backbone.marionette',
    'app/jade',
    'app/base'
], (
     Marionette,
     jade,
     mixOf: mixOf
)->


    class SMTemplateMixin
        mixinTemplateHelpers: (data) ->
            jade.mixinHelpers data
            return data
        getTemplate: ->
            return jade.getTemplate @template

    class KeyboardHandlerMixin
        keyboardHandler: (callback, keys) =>
            codes = _(keys).map (key) =>
                switch key
                    when 'enter' then 13
                    when 'space' then 32
            handle = _.bind(callback, @)
            (event) =>
                event.stopPropagation()
                if event.which in codes then handle event

    SMItemView: class SMItemView extends mixOf Marionette.ItemView, SMTemplateMixin, KeyboardHandlerMixin
    SMCollectionView: class SMCollectionView extends mixOf Marionette.CollectionView, SMTemplateMixin, KeyboardHandlerMixin
    SMLayout: class SMLayout extends mixOf Marionette.Layout, SMTemplateMixin, KeyboardHandlerMixin

define [
    'app/views/base',
], (
    base
) ->

    class ToolMenuItem extends base.SMItemView
        className: 'context-menu-item'
        tagName: 'li'
        template: 'context-menu-item'
        initialize: (opts) ->
            super opts
            @$el.on 'click', @model.get('action')

    class ContextMenuCollectionView extends base.SMCollectionView
        className: 'context-menu'
        tagName: 'ul'
        itemView: ToolMenuItem

    class ContextMenuView extends base.SMLayout
        className: 'context-menu-wrapper'
        template: 'context-menu-wrapper'
        initialize: (@opts) ->
        regions:
            contents: '.contents'
        onRender: ->
            @contents.show new ContextMenuCollectionView @opts

    ContextMenuView

define [
    'app/p13n',
    'app/jade',
    'app/views/base',
    'URI'
], (
    p13n,
    jade,
    base,
    URI
)  ->

    class TitleView extends base.SMItemView
        initialize: ({href: @href}) ->
        className:
            'title-control'
        render: =>
            @el.innerHTML = jade.template 'embedded-title', lang: p13n.getLanguage(), href: @href
            @el

define [
    'app/dateformat',
    'app/views/base',
], (
    dateformat,
    base,
) ->

    class EventDetailsView extends base.SMLayout
        id: 'event-view-container'
        className: 'navigation-element'
        template: 'event'
        events:
            'click .back-button': 'goBack'
            'click .sp-name a': 'goBack'
        type: 'event'

        initialize: (options) ->
            @embedded = options.embedded
            @servicePoint = @model.get('unit')

        serializeData: ->
            data = @model.toJSON()
            data.embedded_mode = @embedded
            startTime = @model.get 'start_time'
            endTime = @model.get 'end_time'
            data.datetime = dateformat.humanizeEventDatetime(
                startTime, endTime, 'large')
            if @servicePoint?
                data.sp_name = @servicePoint.get 'name'
                data.sp_url = @servicePoint.get 'www_url'
                data.sp_phone = @servicePoint.get 'phone'
            else
                data.sp_name = @model.get('location_extra_info')
                data.prevent_back = true
            data

        goBack: (event) ->
            event.preventDefault()
            app.commands.execute 'clearSelectedEvent'
            app.commands.execute 'selectUnit', @servicePoint

define ['underscore', 'URI', 'backbone', 'app/views/base', 'app/views/context-menu', 'app/p13n', 'i18next'], (_, URI, Backbone, base, ContextMenu, p13n, i18n) ->

    class ExportingView extends base.SMLayout
        template: 'exporting'
        regions:
            exportingContext: '#exporting-context'
        events:
            'click': 'openMenu'
        openMenu: (ev) ->
            ev.preventDefault()
            ev.stopPropagation()
            if @exportingContext.currentView?
                @exportingContext.reset()
                return
            models = [
                new Backbone.Model
                    name: i18n.t 'tools.embed_action'
                    action: _.bind @exportEmbed, @
            ]
            menu = new ContextMenu collection: new Backbone.Collection models
            @exportingContext.show menu
            $(document).one 'click', (ev) =>
                @exportingContext.reset()
        exportEmbed: (ev) ->
            url = URI window.location.href
            directory = url.directory()
            directory = '/embedder' + directory
            url.directory directory
            url.port ''
            query = url.search true
            query.bbox = @getMapBoundsBbox()
            city = p13n.get 'city'
            if city?
                query.city = city
            background = p13n.get('map_background_layer')
            if background not in ['servicemap', 'guidemap']
                query.map = background
            query.ratio = parseInt(100 * window.innerHeight / window.innerWidth)
            url.search query
            window.location.href = url.toString()
        getMapBoundsBbox: ->
            # TODO: don't break architecture thusly
            __you_shouldnt_access_me_like_this = window.mapView.map
            wrongBbox = __you_shouldnt_access_me_like_this._originalGetBounds().toBBoxString().split ','
            rightBbox = _.map [1,0,3,2], (i) -> wrongBbox[i].slice(0,8)
            rightBbox.join ','
        render: ->
            super()
            @el

define [
    'app/views/base',
    'app/tour'
],
(
    base,
    tour,
) ->

    class TourStartButton extends base.SMItemView
        className: 'feature-tour-start'
        template: 'feature-tour-start'
        events:
            'click .close-button' : 'hideTour'
            'click .prompt-button' : 'showTour'
        hideTour: (ev) ->
            p13n.set 'hide_tour', true
            @trigger 'close'
            ev.stopPropagation()
        showTour: (ev) ->
            tour.startTour()
            @trigger 'close'

define [
    'app/views/base',
], (
    base,
) ->

    class FeedbackConfirmationView extends base.SMItemView
        template: 'feedback-confirmation'
        className: 'content modal-dialog'
        events:
            'click .ok-button': '_close'
        initialize: (@unit) ->
        serializeData: ->
            unit: @unit.toJSON()
        _close: ->
            app.commands.execute 'closeFeedback'

define [
    'underscore',
    'app/views/base',
    'app/views/accessibility-personalisation',
    'i18next',
], (
    _,
    base,
    AccessibilityPersonalisationView,
    t: t,
) ->

    class FeedbackFormView extends base.SMLayout
        template: 'feedback-form'
        className: 'content modal-dialog'
        regions:
            accessibility: '#accessibility-section'
        events:
            'submit': '_submit'
            'change input[type=checkbox]': '_onCheckboxChanged'
            'change input[type=radio]': '_onRadioButtonChanged'
            'click .personalisations li': '_onPersonalisationClick'
            'blur input[type=text]': '_onFormInputBlur'
            'blur input[type=email]': '_onFormInputBlur'
            'blur textarea': '_onFormInputBlur'

        initialize: (
            unit: @unit
            model: @model
        ) ->
        onRender: ->
            @_adaptInputWidths @$el, 'input[type=text]'
            @accessibility.show new AccessibilityPersonalisationView(@model.get('accessibility_viewpoints') or [])

        serializeData: ->
            keys = [
                'title', 'first_name', 'description',
                'email', 'accessibility_viewpoints',
                'can_be_published', 'service_request_type'
            ]
            value = (key) => @model.get(key) or ''
            values = _.object keys, _(keys).map(value)
            values.accessibility_enabled = @model.get('accessibility_enabled') or false
            values.email_enabled = @model.get('email_enabled') or false
            values.unit = @unit.toJSON()
            values

        _adaptInputWidths: ($el, selector) ->
            _.defer =>
                $el.find(selector).each ->
                    pos = $(@).position().left
                    width = 440
                    width -= pos
                    $(@).css 'width', "#{width}px"
                $el.find('textarea').each -> $(@).css 'width', "460px"

        _submit: (ev) ->
            ev.preventDefault()
            @model.set 'unit', @unit
            @model.save()

        _onCheckboxChanged: (ev) ->
            target = ev.currentTarget
            checked = target.checked
            $hiddenSection = $(target).closest('.form-section').find('.hidden-section')
            if checked
                $hiddenSection.removeClass 'hidden'
                @_adaptInputWidths $hiddenSection, 'input[type=email]'
            else
                $hiddenSection.addClass 'hidden'
            @_setModelField @_getModelFieldId($(target)), checked

        _onRadioButtonChanged: (ev) ->
            $target = $(ev.currentTarget)
            name = $target.attr 'name'
            value = $target.val()
            @model.set @_getModelFieldId($target, attrName='name'), value

        _onFormInputBlur: (ev) ->
            $target = $ ev.currentTarget
            contents = $target.val()
            id = @_getModelFieldId $target
            success = @_setModelField id, contents
            $container = $target.closest('.form-section').find('.validation-error')
            if success
                $container.addClass 'hidden'
            else
                error = @model.validationError
                $container.html t("feedback.form.validation.#{error[id]}")
                $container.removeClass 'hidden'

        _getModelFieldId: ($target, attrName='id') ->
            try
                $target.attr(attrName).replace /open311-/, ''
            catch TypeError
                null

        _setModelField: (id, val) ->
            @model.set id, val, validate: true

        _onPersonalisationClick: (ev) ->
            $target = $(ev.currentTarget)
            type = $target.data 'type'
            $target.closest('#accessibility-section').find('li').removeClass 'selected'
            $target.addClass 'selected'
            @model.set 'accessibility_viewpoints', [type]

define [
    'underscore',
    'app/models',
    'app/views/base',
], (
    _,
    models,
    base
) ->

    class LanguageSelectorView extends base.SMItemView
        template: 'language-selector'
        # events:
        #     'click .language': 'selectLanguage'
        languageSubdomain:
            fi: 'palvelukartta'
            sv: 'servicekarta'
            en: 'servicemap'
        initialize: (opts) ->
            @p13n = opts.p13n
            @languages = @p13n.getSupportedLanguages()
            @refreshCollection()
            @listenTo p13n, 'url', =>
                @render()
        selectLanguage: (ev) ->
            l = $(ev.currentTarget).data('language')
            window.location.reload()
        _replaceUrl: (withWhat) ->
            href = window.location.href
            if href.match /^http[s]?:\/\/[^.]+\.hel\..*/
                return href.replace /\/\/[^.]+./, "//#{withWhat}."
            else
                return href
        serializeData: ->
            data = super()
            for i, val of data.items
                val.link = @_replaceUrl @languageSubdomain[val.code]
            data
        refreshCollection: ->
            selected = @p13n.getLanguage()
            languageModels = _.map @languages, (l) ->
                new models.Language
                    code: l.code
                    name: l.name
                    selected: l.code == selected
            @collection = new models.LanguageList _.filter languageModels, (l) -> !l.get('selected')

define ['app/views/base'], (base) ->

    class LocationRefreshButtonView extends base.SMLayout
        template: 'location-refresh-button'
        events:
            'click': 'resetPosition'
        resetPosition: (ev) ->
            ev.stopPropagation()
            ev.preventDefault()
            app.commands.execute 'resetPosition'
        render: ->
            super()
            @el

define [
    'app/views/base',
    'app/views/event-details',
    'app/views/service-tree',
    'app/views/position-details',
    'app/views/unit-details',
    'app/views/search-input',
    'app/views/search-results',
    'app/views/sidebar-region',
    'app/map-view'
], (
    base,
    EventDetailsView,
    ServiceTreeView,
    PositionDetailsView,
    UnitDetailsView,
    SearchInputView,
    {SearchLayoutView: SearchLayoutView,
    UnitListLayoutView: UnitListLayoutView},
    SidebarRegion,
    MapView
) ->

    class NavigationLayout extends base.SMLayout
        className: 'service-sidebar'
        template: 'navigation-layout'
        regionType: SidebarRegion
        regions:
            header: '#navigation-header'
            contents: '#navigation-contents'
        onShow: ->
            @header.show new NavigationHeaderView
                layout: this
                searchState: @searchState
                searchResults: @searchResults
                selectedUnits: @selectedUnits
        initialize: (options) ->
            @serviceTreeCollection = options.serviceTreeCollection
            @selectedServices = options.selectedServices
            @searchResults = options.searchResults
            @selectedUnits = options.selectedUnits
            @units = options.units
            @selectedEvents = options.selectedEvents
            @selectedPosition = options.selectedPosition
            @searchState = options.searchState
            @routingParameters = options.routingParameters
            @route = options.route
            @breadcrumbs = [] # for service-tree view
            @openViewType = null # initially the sidebar is closed.
            @addListeners()
        addListeners: ->
            @listenTo @searchResults, 'ready', ->
                @change 'search'
            @listenTo @serviceTreeCollection, 'finished', ->
                @openViewType = null
                @change 'browse'
            @listenTo @selectedServices, 'reset', (coll, opts) ->
                unless opts?.skip_navigate
                    @change 'browse'
            @listenTo @selectedPosition, 'change:value', (w, value) ->
                previous = @selectedPosition.previous 'value'
                if previous?
                    @stopListening previous
                if value?
                    @listenTo value, 'change:radiusFilter', @radiusFilterChanged
                if @selectedPosition.isSet()
                    @change 'position'
                else if @openViewType == 'position'
                    @closeContents()
            @listenTo @selectedServices, 'add', (service) ->
                @closeContents()
                @service = service
                @listenTo @service.get('units'), 'finished', =>
                    @change 'service-units'
            @listenTo @selectedServices, 'remove', (service, coll) =>
                if coll.isEmpty()
                    if @openViewType == 'service-units'
                        @closeContents()
                else
                    @change 'service-units'
            @listenTo @selectedUnits, 'reset', (unit, coll, opts) ->
                currentViewType = @contents.currentView?.type
                if currentViewType == 'details'
                    if @searchResults.isEmpty() and @selectedUnits.isEmpty()
                        @closeContents()
                unless @selectedUnits.isEmpty()
                    @change 'details'
            @listenTo @selectedUnits, 'remove', (unit, coll, opts) ->
                @change null
            @listenTo @selectedEvents, 'reset', (unit, coll, opts) ->
                unless @selectedEvents.isEmpty()
                    @change 'event'
            @contents.on('show', @updateMaxHeights)
            $(window).resize @updateMaxHeights
            @listenTo(app.vent, 'landing-page-cleared', @setMaxHeight)
        updateMaxHeights: =>
            @setMaxHeight()
            currentViewType = @contents.currentView?.type
            MapView.setMapActiveAreaMaxHeight
                maximize: not currentViewType or currentViewType == 'search'
        setMaxHeight: =>
            # Set the sidebar content max height for proper scrolling.
            $limitedElement = @$el.find('.limit-max-height')
            return unless $limitedElement.length
            maxHeight = $(window).innerHeight() - $limitedElement.offset().top
            $limitedElement.css 'max-height': maxHeight
            @$el.find('.map-active-area').css 'padding-bottom', MapView.mapActiveAreaMaxHeight()
        getAnimationType: (newViewType) ->
            currentViewType = @contents.currentView?.type
            if currentViewType
                switch currentViewType
                    when 'event'
                        return 'right'
                    when 'details'
                        switch newViewType
                            when 'event' then return 'left'
                            when 'details' then return 'up-and-down'
                            else return 'right'
                    when 'service-tree'
                        return @contents.currentView.animationType or 'left'
            return null

        closeContents: ->
            @change null
            @openViewType = null
            @header.currentView.updateClasses null
            MapView.setMapActiveAreaMaxHeight maximize: true

        radiusFilterChanged: (value) ->
            if value.get('radiusFilter') > 0
                @listenToOnce @units, 'finished', =>
                    @change 'radius'

        change: (type) ->

            # Don't react if browse is already opened
            return if type is 'browse' and @openViewType is 'browse'

            switch type
                when 'browse'
                    view = new ServiceTreeView
                        collection: @serviceTreeCollection
                        selectedServices: @selectedServices
                        breadcrumbs: @breadcrumbs
                when 'radius'
                    view = new UnitListLayoutView
                        fullCollection: @units
                        collectionType: 'radius'
                        position: @selectedPosition.value()
                        resultType: 'unit'
                        onlyResultType: true
                when 'search'
                    view = new SearchLayoutView
                        collection: @searchResults
                when 'service-units'
                    view = new UnitListLayoutView
                        fullCollection: @units
                        collectionType: 'service'
                        resultType: 'unit'
                        onlyResultType: true
                when 'details'
                    view = new UnitDetailsView
                        model: @selectedUnits.first()
                        route: @route
                        parent: @
                        routingParameters: @routingParameters
                        searchResults: @searchResults
                        selectedUnits: @selectedUnits
                        selectedPosition: @selectedPosition
                when 'event'
                    view = new EventDetailsView
                        model: @selectedEvents.first()
                when 'position'
                    view = new PositionDetailsView
                        model: @selectedPosition.value()
                        route: @route
                        selectedPosition: @selectedPosition
                        routingParameters: @routingParameters
                else
                    @opened = false
                    view = null
                    @contents.reset()

            @updatePersonalisationButtonClass type

            if view?
                @contents.show view, animationType: @getAnimationType(type)
                @openViewType = type
                @opened = true
                @listenToOnce view, 'user:close', (ev) =>
                    if type == 'details'
                        if not @selectedServices.isEmpty()
                            @change 'service-units'
                        else if 'distance' of @units.filters
                            @change 'radius'
            unless type == 'details'
                # TODO: create unique titles for routes that require it
                app.vent.trigger 'site-title:change', null

        updatePersonalisationButtonClass: (type) ->
            # Update personalisation icon visibility.
            # Notice: "hidden" class only affects narrow media.
            if type in ['browse', 'search', 'details', 'event', 'position']
                $('#personalisation').addClass 'hidden'
            else
                $('#personalisation').removeClass 'hidden'

    class NavigationHeaderView extends base.SMLayout
        # This view is responsible for rendering the navigation
        # header which allows the user to switch between searching
        # and browsing.
        className: 'container'
        template: 'navigation-header'
        regions:
            search: '#search-region'
            browse: '#browse-region'

        events:
            'click .header': 'open'
            'keypress .header': 'toggleOnKeypress'
            'click .action-button.close-button': 'close'

        initialize: (options) ->
            @navigationLayout = options.layout
            @searchState = options.searchState
            @searchResults = options.searchResults
            @selectedUnits = options.selectedUnits

        onShow: ->
            searchInputView = new SearchInputView(@searchState, @searchResults)
            @search.show searchInputView
            @listenTo searchInputView, 'open', =>
                @updateClasses 'search'
                @navigationLayout.updatePersonalisationButtonClass 'search'
            @browse.show new BrowseButtonView()

        _open: (actionType) ->
            @updateClasses actionType
            @navigationLayout.change actionType

        open: (event) ->
            @_open $(event.currentTarget).data('type')

        toggleOnKeypress: (event) ->
            target = $(event.currentTarget).data('type')
            isNavigationVisible = !!$('#navigation-contents').children().length

            # An early return if the key is not 'enter'
            return if event.keyCode isnt 13

            if isNavigationVisible
                @_close target
            else
                @_open target

        _close: (headerType) ->
            @updateClasses null

            # Clear search query if search is closed.
            if headerType is 'search'
                @$el.find('input').val('')
                app.commands.execute 'closeSearch'
            if headerType is 'search' and not @selectedUnits.isEmpty()
                # Don't switch out of unit details when closing search.
                return
            @navigationLayout.closeContents()

        close: (event) ->
            event.preventDefault()
            event.stopPropagation()
            unless $(event.currentTarget).hasClass('close-button')
                return false
            headerType = $(event.target).closest('.header').data('type')
            @_close headerType

        updateClasses: (opening) ->
            classname = "#{opening}-open"
            if @$el.hasClass classname
                return
            @$el.removeClass().addClass('container')
            if opening?
                @$el.addClass classname

    class BrowseButtonView extends base.SMItemView
        template: 'navigation-browse'


    NavigationLayout

define [
    'app/p13n',
    'app/views/base',
    'app/views/accessibility-personalisation'
], (
    p13n,
    base,
    AccessibilityPersonalisationView
)  ->

    class PersonalisationView extends base.SMLayout
        className: 'personalisation-container'
        template: 'personalisation'
        regions:
            accessibility: '#accessibility-personalisation'
        events: ->
            'click .personalisation-button': 'personalisationButtonClick'
            'keydown .personalisation-button': @keyboardHandler @personalisationButtonClick, ['space', 'enter']
            'click .ok-button': 'toggleMenu'
            'keydown .ok-button': @keyboardHandler @toggleMenu, ['space']
            'click .select-on-map': 'selectOnMap'
            'click .personalisations a': 'switchPersonalisation'
            'keydown .personalisations a': @keyboardHandler @switchPersonalisation, ['space']
            'click .personalisation-message a': 'openMenuFromMessage'
            'click .personalisation-message .close-button': 'closeMessage'

        personalisationIcons:
            'city': [
                'helsinki'
                'espoo'
                'vantaa'
                'kauniainen'
            ]
            'senses': [
                'hearing_aid'
                'visually_impaired'
                'colour_blind'
            ]
            'mobility': [
                'wheelchair'
                'reduced_mobility'
                'rollator'
                'stroller'
            ]

        initialize: ->
            $(window).resize @setMaxHeight
            @listenTo p13n, 'change', ->
                @setActivations()
                @renderIconsForSelectedModes()
            @listenTo p13n, 'user:open', -> @personalisationButtonClick()

        personalisationButtonClick: (ev) ->
            ev?.preventDefault()
            unless $('#personalisation').hasClass('open')
                @toggleMenu(ev)

        toggleMenu: (ev) ->
            ev?.preventDefault()
            $('#personalisation').toggleClass('open')

        openMenuFromMessage: (ev) ->
            ev?.preventDefault()
            @toggleMenu()
            @closeMessage()

        closeMessage: (ev) ->
            @$('.personalisation-message').removeClass('open')

        selectOnMap: (ev) ->
            # Add here functionality for seleecting user's location from the map.
            ev.preventDefault()

        renderIconsForSelectedModes: ->
            $container = @$('.selected-personalisations').empty()
            for group, types of @personalisationIcons
                for type in types
                    if @modeIsActivated(type, group)
                        if group == 'city'
                            iconClass = 'icon-icon-coat-of-arms-' + type.split('_').join('-')
                        else
                            iconClass = 'icon-icon-' + type.split('_').join('-')
                        $icon = $("<span class='#{iconClass}'></span>")
                        $container.append($icon)

        modeIsActivated: (type, group) ->
            activated = false
            # FIXME
            if group == 'city'
                activated = p13n.get('city') == type
            else if group == 'mobility'
                activated = p13n.getAccessibilityMode('mobility') == type
            else
                activated = p13n.getAccessibilityMode type
            return activated

        setActivations: ->
            $list = @$el.find '.personalisations'
            $list.find('li').each (idx, li) =>
                $li = $(li)
                type = $li.data 'type'
                group = $li.data 'group'
                $button = $li.find('a[role="button"]')
                activated = @modeIsActivated(type, group)
                if activated
                    $li.addClass 'selected'
                else
                    $li.removeClass 'selected'
                $button.attr 'aria-pressed', activated

        switchPersonalisation: (ev) ->
            ev.preventDefault()
            parentLi = $(ev.target).closest 'li'
            group = parentLi.data 'group'
            type = parentLi.data 'type'

            if group == 'mobility'
                p13n.toggleMobility type
            else if group == 'senses'
                modeIsSet = p13n.toggleAccessibilityMode type
                currentBackground = p13n.get 'map_background_layer'
                if type in ['visually_impaired', 'colour_blind']
                    newBackground = null
                    if modeIsSet
                        newBackground = 'accessible_map'
                    else if currentBackground == 'accessible_map'
                        newBackground = 'servicemap'
                    if newBackground
                        p13n.setMapBackgroundLayer newBackground
            else if group == 'city'
                p13n.toggleCity type

        render: (opts) ->
            super opts
            @renderIconsForSelectedModes()
            @setActivations()

        onRender: ->
            @accessibility.show new AccessibilityPersonalisationView []
            @setMaxHeight()

        setMaxHeight: =>
            # TODO: Refactor this when we get some onDomAppend event.
            # The onRender function that calls setMaxHeight runs before @el
            # is inserted into DOM. Hence calculating heights and positions of
            # the template elements is currently impossible.
            personalisationHeaderHeight = 56
            windowWidth = $(window).width()
            offset = 0
            if windowWidth >= appSettings.mobile_ui_breakpoint
                offset = $('#personalisation').offset().top
            maxHeight = $(window).innerHeight() - personalisationHeaderHeight - offset
            @$el.find('.personalisation-content').css 'max-height': maxHeight

define [
    'underscore',
    'app/models',
    'app/map-view',
    'app/views/base',
    'app/views/route'
], (
    _,
    models,
    MapView,
    base,
    RouteView
) ->

    class PositionDetailsView extends base.SMLayout
        type: 'position'
        id: 'details-view-container'
        className: 'navigation-element limit-max-height'
        template: 'position'
        regions:
            'areaServices': '.area-services-placeholder'
            'adminDivisions': '.admin-div-placeholder'
            'routeRegion': '.section.route-section'
        events:
            'click .map-active-area': 'showMap'
            'click .mobile-header': 'showContent'
            'click .icon-icon-close': 'selfDestruct'
            'click #reset-location': 'resetLocation'
            'click #add-circle': 'addCircle'
        initialize: (options) ->
            @selectedPosition = options.selectedPosition
            @route = options.route
            @parent = options.parent
            @routingParameters = options.routingParameters
            @sortedDivisions = [
                'postcode_area',
                'neighborhood',
                'rescue_district',
                'health_station_district',
                'maternity_clinic_district',
                'income_support_district',
                'lower_comprehensive_school_district_fi',
                'lower_comprehensive_school_district_sv',
                'upper_comprehensive_school_district_fi',
                'upper_comprehensive_school_district_sv'
                ]

            @divList = new models.AdministrativeDivisionList()
            @listenTo @model, 'reverse-geocode', =>
                @fetchDivisions().done =>
                    @render()
            @divList.comparator = (a, b) =>
                indexA = _.indexOf @sortedDivisions, a.get('type')
                indexB = _.indexOf @sortedDivisions, b.get('type')
                if indexA < indexB then return -1
                if indexB < indexA then return 1
                return 0
            @listenTo @divList, 'reset', @renderAdminDivs
            @fetchDivisions().done =>
                @render()
        fetchDivisions: ->
            coords = @model.get('location').coordinates
            @divList.fetch
                data:
                    lon: coords[0]
                    lat: coords[1]
                    unit_include: 'name,root_services,location'
                    type: (_.union @sortedDivisions, ['emergency_care_district']).join(',')
                    geometry: 'true'
                reset: true
        serializeData: ->
            data = super()
            data.icon_class = switch @model.origin()
                when 'address' then 'icon-icon-address'
                when 'detected' then 'icon-icon-you-are-here'
                when 'clicked' then 'icon-icon-address'
            data.origin = @model.origin()
            data.neighborhood = @divList.findWhere type: 'neighborhood'
            data.name = @model.humanAddress()
            data

        resetLocation: ->
            app.commands.execute 'resetPosition', @model

        addCircle: ->
            app.commands.execute 'setRadiusFilter', 750

        onRender: ->
            @renderAdminDivs()
            @routeRegion.show new RouteView
                model: @model
                route: @route
                parentView: @
                routingParameters: @routingParameters
                selectedUnits: null
                selectedPosition: @selectedPosition
        renderAdminDivs: ->
            divsWithUnits = @divList.filter (x) -> x.has('unit')
            emergencyDiv = @divList.find (x) ->
                x.get('type') == 'emergency_care_district'
            if divsWithUnits.length > 0
                units = new models.UnitList(
                    divsWithUnits.map (x) ->
                        unit = new models.Unit x.get('unit')
                        unit.set 'area', x
                        if x.get('type') == 'health_station_district'
                            unit.set 'emergencyUnitId', emergencyDiv.getEmergencyCareUnit()
                        unit
                )
                @areaServices.show new UnitListView
                    collection: units
                @adminDivisions.show new DivisionListView
                    collection: new models.AdministrativeDivisionList(@divList.filter (x) => x.get('type') != 'emergency_care_district')
        showMap: (event) ->
            event.preventDefault()
            @$el.addClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: true
        showContent: (event) ->
            event.preventDefault()
            @$el.removeClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: false

        selfDestruct: (event) ->
            event.stopPropagation()
            app.commands.execute 'clearSelectedPosition'

    class DivisionListItemView extends base.SMItemView
        events:
            'click': 'handleClick'
        tagName: 'li'
        template: 'division-list-item'
        handleClick: =>
            app.commands.execute 'toggleDivision', @model
        initialize: =>
            @listenTo @model, 'change:selected', @render

    class DivisionListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'division-list sublist'
        itemView: DivisionListItemView


    class UnitListItemView extends base.SMItemView
        events:
            'click a': 'handleInnerClick'
            'click': 'handleClick'
        tagName: 'li'
        template: 'unit-list-item'
        serializeData: ->
            data = super()
            data
        handleInnerClick: (ev) =>
            ev?.stopPropagation()
        handleClick: (ev) =>
            ev?.preventDefault()
            app.commands.execute 'setUnit', @model
            app.commands.execute 'selectUnit', @model

    class UnitListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'unit-list sublist'
        itemView: UnitListItemView



    PositionDetailsView

define [
    'app/views/base',
], (
    base,
) ->

    class RadiusControlsView extends base.SMItemView
        template: 'radius-controls'
        className: 'radius-controls'
        events: 'change': 'onChange'
        serializeData: ->
            selected: @selected or 750
            values: [
                250, 500, 750, 1000,
                2000, 3000, 4000]
        initialize: (radius: @selected) ->
        onChange: (ev) ->
            @selected = $(ev.target).val()
            @render()
            app.commands.execute 'setRadiusFilter', @selected

define [
    'underscore',
    'moment',
    'bootstrap-datetimepicker',
    'app/p13n',
    'app/models',
    'app/search',
    'app/views/base',
    'app/views/accessibility',
    'app/geocoding',
    'app/jade'
], (
    _,
    moment,
    datetimepicker,
    p13n,
    models,
    search,
    base,
    accessibilityViews,
    geocoding,
    jade
) ->

    class RouteSettingsView extends base.SMLayout
        template: 'route-settings'
        regions:
            'headerRegion': '.route-settings-header'
            'routeControllersRegion': '.route-controllers'
            'accessibilitySummaryRegion': '.accessibility-viewpoint-part'
            'transportModeControlsRegion': '.transport_mode_controls'

        initialize: (attrs) ->
            @unit = attrs.unit
            @listenTo @model, 'change', @updateRegions

        onRender: ->
            @headerRegion.show new RouteSettingsHeaderView
                model: @model
            @routeControllersRegion.show new RouteControllersView
                model: @model
                unit: @unit
            @accessibilitySummaryRegion.show new accessibilityViews.AccessibilityViewpointView
                filterTransit: true
                template: 'accessibility-viewpoint-oneline'
            @transportModeControlsRegion.show new TransportModeControlsView

        updateRegions: ->
            @headerRegion.currentView.render()
            @accessibilitySummaryRegion.currentView.render()
            @transportModeControlsRegion.currentView.render()


    class RouteSettingsHeaderView extends base.SMItemView
        template: 'route-settings-header'
        events:
            'click .settings-summary': 'toggleSettingsVisibility'
            'click .ok-button': 'toggleSettingsVisibility'

        serializeData: ->
            profiles = p13n.getAccessibilityProfileIds true

            origin = @model.getOrigin()
            originName = @model.getEndpointName origin
            if (
                (origin?.isDetectedLocation() and not origin?.isPending()) or
                (origin? and origin instanceof models.CoordinatePosition)
            )
                originName = originName.toLowerCase()

            transportIcons = []
            for mode, value of p13n.get('transport')
                if value
                    transportIcons.push "icon-icon-#{mode.replace('_', '-')}"

            profile_set: _.keys(profiles).length
            profiles: p13n.getProfileElements profiles
            origin_name: originName
            origin_is_pending: @model.getOrigin().isPending()
            transport_icons: transportIcons

        toggleSettingsVisibility: (event) ->
            event.preventDefault()
            $('#route-details').toggleClass('settings-open')
            $('.bootstrap-datetimepicker-widget').hide()
            $('#route-details').trigger "shown"

    class TransportModeControlsView extends base.SMItemView
        template: 'transport-mode-controls'
        events:
            'click .transport-modes a': 'switchTransportMode'

        onRender: =>
            _(['public', 'bicycle']).each (group) =>
                @$el.find(".#{group}-details a").click (ev) =>
                    ev.preventDefault()
                    @switchTransportDetails ev, group

        serializeData: ->
            transportModes = p13n.get('transport')
            bicycleDetailsClasses = ''
            if transportModes.public_transport
                bicycleDetailsClasses += 'no-arrow '
            unless transportModes.bicycle
                bicycleDetailsClasses += 'hidden'
            selectedValues = (modes) =>
                _(modes)
                    .chain()
                    .pairs()
                    .filter (v) => v[1] == true
                    .map (v) => v[0]
                    .value()
            transportModes = selectedValues transportModes
            publicModes = selectedValues p13n.get('transport_detailed_choices').public

            transport_modes: transportModes
            public_modes: publicModes
            transport_detailed_choices: p13n.get('transport_detailed_choices')
            bicycle_details_classes: bicycleDetailsClasses

        switchTransportMode: (ev) ->
            ev.preventDefault()
            type = $(ev.target).closest('li').data 'type'
            p13n.toggleTransport type

        switchTransportDetails: (ev, group) ->
            ev.preventDefault()
            type = $(ev.target).closest('li').data 'type'
            p13n.toggleTransportDetails group, type

    class RouteControllersView extends base.SMItemView
        template: 'route-controllers'
        events:
            'click .preset.unlocked': 'switchToLocationInput'
            'click .preset-current-time': 'switchToTimeInput'
            'click .preset-current-date': 'switchToDateInput'
            'click .time-mode': 'setTimeMode'
            'click .swap-endpoints': 'swapEndpoints'
            'click .tt-suggestion': (e) ->
                e.stopPropagation()
            'click': 'undoChanges'
            # Important: the above click handler requires the following
            # to not disable the time picker widget.
            'click .time': (ev) -> ev.stopPropagation()
            'click .date': (ev) -> ev.stopPropagation()

        initialize: (attrs) ->
            window.debugRoutingControls = @
            @permanentModel = @model
            @pendingPosition = @permanentModel.pendingPosition
            @currentUnit = attrs.unit
            @_reset()

        _reset: ->
            @stopListening @model
            @model = @permanentModel.clone()
            @listenTo @model, 'change', (model, options) =>
                # If the change was an interaction with the datetimepicker
                # widget, we shouldn't re-render.
                unless options?.alreadyVisible
                    @$el.find('input.time').data("DateTimePicker")?.hide()
                    @$el.find('input.time').data("DateTimePicker")?.destroy()
                    @$el.find('input.date').data("DateTimePicker")?.hide()
                    @$el.find('input.date').data("DateTimePicker")?.destroy()
                    @render()
            @listenTo @model.getOrigin(), 'change', @render
            @listenTo @model.getDestination(), 'change', @render

        onRender: ->
            @enableTypeahead '.transit-end input'
            @enableTypeahead '.transit-start input'
            @enableDatetimePicker()

        enableDatetimePicker: ->
            keys = ['time', 'date']
            other = (key) =>
                keys[keys.indexOf(key) + 1 % keys.length]
            inputElement = (key) =>
                @$el.find "input.#{key}"
            otherHider = (key) => =>
                inputElement(other(key)).data("DateTimePicker")?.hide()
            valueSetter = (key) => (ev) =>
                keyUpper = key.charAt(0).toUpperCase() + key.slice 1
                @model["set#{keyUpper}"].call @model, ev.date.toDate(),
                    alreadyVisible: true
                @applyChanges()

            closePicker = true
            _.each keys, (key) =>
                $input = inputElement key
                if $input.length > 0
                    options = {}
                    disablePick = (
                        time: 'pickDate'
                        date: 'pickTime'
                    )[key]
                    options[disablePick] = false

                    $input.datetimepicker options
                    $input.on 'dp.show', =>
                        # If a different picker is shown, don't close
                        # it immediately.
                        # TODO: get rid of unnecessarily complex open/close logic
                        if @activateOnRender != 'date' and @shown? and @shown != key then closePicker = false
                        otherHider(key)()
                        @shown = key
                    $input.on 'dp.change', valueSetter(key)
                    dateTimePicker = $input.data("DateTimePicker")
                    $input.on 'click', =>
                        if closePicker then @_closeDatetimePicker $input
                        closePicker = !closePicker
                    if @activateOnRender == key
                        dateTimePicker.show()
                        $input.attr 'readonly', @_isScreenHeightLow()
            @activateOnRender = null

        applyChanges: ->
            @permanentModel.set @model.attributes
            @permanentModel.triggerComplete()
        undoChanges: ->
            @_reset()
            origin = @model.getOrigin()
            destination = @model.getDestination()
            @model.trigger 'change'

        enableTypeahead: (selector) ->
            @$searchEl = @$el.find selector
            unless @$searchEl.length
                return

            geocoderBackend = new geocoding.GeocoderSourceBackend()
            options = geocoderBackend.getDatasetOptions()
            options.templates.empty = (ctx) -> jade.template 'typeahead-no-results', ctx
            @$searchEl.typeahead null, [options]

            @$searchEl.on 'keyup', (e) =>
                $('.tt-suggestion:first-child').trigger('click') if e.keyCode is 13

            selectAddress = (event, match) =>
                @commit = true
                switch $(event.currentTarget).attr 'data-endpoint'
                    when 'origin'
                        @model.setOrigin match
                    when 'destination'
                        @model.setDestination match

                @applyChanges()

            geocoderBackend.setOptions
                $inputEl: @$searchEl
                selectionCallback: selectAddress

            # Focus on search-elem when #route-details has been opened
            $('#route-details').on "shown", =>
                @$searchEl.attr('tabindex', -1).focus()

        _locationNameAndLocking: (object) ->
            name: @model.getEndpointName object
            lock: @model.getEndpointLocking object

        _isScreenHeightLow: ->
            $(window).innerHeight() < 700

        serializeData: ->
            datetime = moment @model.getDatetime()
            today = new Date()
            tomorrow = moment(today).add 1, 'days'
            # try to avoid opening the mobile virtual keyboard
            disable_keyboard: @_isScreenHeightLow()
            is_today: not @forceDateInput and datetime.isSame(today, 'day')
            is_tomorrow: datetime.isSame tomorrow, 'day'
            params: @model
            origin: @_locationNameAndLocking @model.getOrigin()
            destination: @_locationNameAndLocking @model.getDestination()
            time: datetime.format 'LT'
            date: datetime.format 'L'
            time_mode: @model.get 'time_mode'

        swapEndpoints: (ev) ->
            ev.stopPropagation()
            @permanentModel.swapEndpoints
                silent: true
            @model.swapEndpoints()
            if @model.isComplete()
                @applyChanges()

        switchToLocationInput: (ev) ->
            ev.stopPropagation()
            @_reset()
            position = @pendingPosition
            position.clear()
            switch $(ev.currentTarget).attr 'data-route-node'
                when 'start' then @model.setOrigin position
                when 'end' then @model.setDestination position
            @listenToOnce position, 'change', =>
                @applyChanges()
                @render()
            position.trigger 'request'

        setTimeMode: (ev) ->
            ev.stopPropagation()
            timeMode = $(ev.target).data('value')
            if timeMode != @model.get 'time_mode'
                @model.setTimeMode(timeMode)
                @applyChanges()

        _closeDatetimePicker: ($input) ->
            $input.data("DateTimePicker").hide()
        switchToTimeInput: (ev) ->
            ev.stopPropagation()
            @activateOnRender = 'time'
            @model.setDefaultDatetime()
        switchToDateInput: (ev) ->
            ev.stopPropagation()
            @activateOnRender = 'date'
            @forceDateInput = true
            @model.trigger 'change'

    RouteSettingsView

define [
    'underscore',
    'moment',
    'i18next',
    'app/p13n',
    'app/models',
    'app/spinner',
    'app/views/base',
    'app/views/route-settings'
], (
    _,
    moment,
    i18n,
    p13n,
    models,
    SMSpinner,
    base,
    RouteSettingsView
) ->

    class RouteView extends base.SMLayout
        id: 'route-view-container'
        className: 'route-view'
        template: 'route'
        regions:
            'routeSettingsRegion': '.route-settings'
            'routeSummaryRegion': '.route-summary'
        events:
            'click a.collapser.route': 'toggleRoute'
            'click .show-map': 'showMap'
        initialize: (options) ->
            @parentView = options.parentView
            @selectedUnits = options.selectedUnits
            @selectedPosition = options.selectedPosition
            @route = options.route
            @routingParameters = options.routingParameters
            # Debounce to avoid flooding the OTP server on small time input change.
            @listenTo @routingParameters, 'complete', _.debounce _.bind(@requestRoute, @), 300
            @listenTo p13n, 'change', @changeTransitIcon
            @listenTo @route, 'change:plan', (route) =>
                if route.has 'plan'
                    @routingParameters.set 'route', @route
                    @showRouteSummary @route
            @listenTo p13n, 'change', (path, val) =>
                # if path[0] == 'accessibility'
                #     if path[1] != 'mobility'
                #         return
                # else if path[0] != 'transport'
                #     return
                @requestRoute()

        serializeData: ->
            transit_icon: @getTransitIcon()

        getTransitIcon: () ->
            setModes = _.filter _.pairs(p13n.get('transport')), ([k, v]) -> v == true
            mode = setModes.pop()[0]
            modeIconName = mode.replace '_', '-'
            "icon-icon-#{modeIconName}"

        changeTransitIcon: ->
            $iconEl = @$el.find('#route-section-icon')
            $iconEl.removeClass().addClass @getTransitIcon()

        toggleRoute: (ev) ->
            $element = $(ev.currentTarget)
            if $element.hasClass 'collapsed'
                @showRoute()
            else
                @hideRoute()

        showMap: (ev) ->
            @parentView.showMap(ev)

        showRoute: ->
            # Route planning
            #
            lastPos = p13n.getLastPosition()
            # Ensure that any user entered position is the origin for the new route
            # so that setting the destination won't overwrite the user entered data.
            @routingParameters.ensureUnitDestination()
            @routingParameters.setDestination @model
            previousOrigin = @routingParameters.getOrigin()
            if lastPos
                if not previousOrigin
                    @routingParameters.setOrigin lastPos,
                        silent: true
                @requestRoute()
            else
                @listenTo p13n, 'position', (pos) =>
                    @requestRoute()
                @listenTo p13n, 'position_error', =>
                    @showRouteSummary null
                if not previousOrigin
                    @routingParameters.setOrigin new models.CoordinatePosition
                p13n.requestLocation @routingParameters.getOrigin()

            @routeSettingsRegion.show new RouteSettingsView
                model: @routingParameters
                unit: @model

            @showRouteSummary null

        showRouteSummary: (route) ->
            @routeSummaryRegion.show new RoutingSummaryView
                model: @routingParameters
                noRoute: !route?

        requestRoute: ->
            if not @routingParameters.isComplete()
                return

            spinner = new SMSpinner
                container:
                    @$el.find('#route-details .route-spinner').get(0)

            spinner.start()
            @listenTo @route, 'change:plan', (plan) =>
                spinner.stop()
            @listenTo @route, 'error', =>
                spinner.stop()

            @routingParameters.unset 'route'

            opts = {}

            if p13n.getAccessibilityMode('mobility') == 'wheelchair'
                opts.wheelchair = true
                opts.walkReluctance = 5
                opts.walkBoardCost = 12*60
                opts.walkSpeed = 0.75
                opts.minTransferTime = 3*60+1

            if p13n.getAccessibilityMode('mobility') == 'reduced_mobility'
                opts.walkReluctance = 5
                opts.walkBoardCost = 10*60
                opts.walkSpeed = 0.5

            if p13n.getAccessibilityMode('mobility') == 'rollator'
                opts.wheelchair = true
                opts.walkReluctance = 5
                opts.walkSpeed = 0.5
                opts.walkBoardCost = 12*60

            if p13n.getAccessibilityMode('mobility') == 'stroller'
                opts.walkBoardCost = 10*60
                opts.walkSpeed = 1

            if p13n.getTransport 'bicycle'
                opts.bicycle = true
                # TODO: take/park bike

            if p13n.getTransport 'car'
                opts.car = true

            if p13n.getTransport 'public_transport'
                publicTransportChoices = p13n.get('transport_detailed_choices').public
                selectedVehicles = _(publicTransportChoices)
                    .chain()
                    .pairs().filter(_.last).map(_.first)
                    .value()
                if selectedVehicles.length == _(publicTransportChoices).values().length
                    opts.transit = true
                else
                    opts.transit = false
                    opts.modes = selectedVehicles

            datetime = @routingParameters.getDatetime()
            opts.date = moment(datetime).format('YYYY/MM/DD')
            opts.time = moment(datetime).format('HH:mm')
            opts.arriveBy = @routingParameters.get('time_mode') == 'arrive'

            from = @routingParameters.getOrigin().otpSerializeLocation
                forceCoordinates: opts.car
            to = @routingParameters.getDestination().otpSerializeLocation
                forceCoordinates: opts.car

            @route.requestPlan from, to, opts

        hideRoute: ->
            @route.clear()


    class RoutingSummaryView extends base.SMItemView
        #itemView: LegSummaryView
        #itemViewContainer: '#route-details'
        template: 'routing-summary'
        className: 'route-summary'
        events:
            'click .route-selector a': 'switchItinerary'
            'click .accessibility-viewpoint': 'setAccessibility'

        initialize: (options) ->
            @itineraryChoicesStartIndex = 0
            @detailsOpen = false
            @skipRoute = options.noRoute
            @route = @model.get 'route'

        NUMBER_OF_CHOICES_SHOWN = 3

        LEG_MODES =
            WALK:
                icon: 'icon-icon-by-foot'
                colorClass: 'transit-walk'
                text: i18n.t('transit.walk')
            BUS:
                icon: 'icon-icon-bus'
                colorClass: 'transit-default'
                text: i18n.t('transit.bus')
            BICYCLE:
                icon: 'icon-icon-bicycle'
                colorClass: 'transit-bicycle'
                text: i18n.t('transit.bicycle')
            CAR:
                icon: 'icon-icon-car'
                colorClass: 'transit-car'
                text: i18n.t('transit.car')
            TRAM:
                icon: 'icon-icon-tram'
                colorClass: 'transit-tram'
                text: i18n.t('transit.tram')
            SUBWAY:
                icon: 'icon-icon-subway'
                colorClass: 'transit-subway'
                text: i18n.t('transit.subway')
            RAIL:
                icon: 'icon-icon-train'
                colorClass: 'transit-rail',
                text: i18n.t('transit.rail')
            FERRY:
                icon: 'icon-icon-ferry'
                colorClass: 'transit-ferry'
                text: i18n.t('transit.ferry')
            WAIT:
                icon: '',
                colorClass: 'transit-default'
                text: i18n.t('transit.wait')

        MODES_WITH_STOPS = [
            'BUS'
            'FERRY'
            'RAIL'
            'SUBWAY'
            'TRAM'
        ]

        serializeData: ->
            if @skipRoute
                return skip_route: true

            window.debugRoute = @route

            itinerary = @route.getSelectedItinerary()
            filteredLegs = _.filter(itinerary.legs, (leg) -> leg.mode != 'WAIT')

            mobilityAccessibilityMode = p13n.getAccessibilityMode 'mobility'
            mobilityElement = null
            if mobilityAccessibilityMode
                mobilityElement = p13n.getProfileElement mobilityAccessibilityMode
            else
                mobilityElement = LEG_MODES['WALK']

            legs = _.map(filteredLegs, (leg) =>
                steps = @parseSteps leg

                if leg.mode == 'WALK'
                    icon = mobilityElement.icon
                    if mobilityAccessibilityMode == 'wheelchair'
                        text = i18n.t 'transit.mobility_mode.wheelchair'
                    else
                        text = i18n.t 'transit.walk'
                else
                    icon = LEG_MODES[leg.mode].icon
                    text = LEG_MODES[leg.mode].text
                if leg.from.bogusName
                    startLocation = i18n.t "otp.bogus_name.#{leg.from.name.replace ' ', '_' }"
                start_time: moment(leg.startTime).format('LT')
                start_location: startLocation || p13n.getTranslatedAttr(leg.from.translatedName) || leg.from.name
                distance: @getLegDistance leg, steps
                icon: icon
                transit_color_class: LEG_MODES[leg.mode].colorClass
                transit_mode: text
                route: @getRouteText leg
                transit_destination: @getTransitDestination leg
                steps: steps
                has_warnings: !!_.find(steps, (step) -> step.warning)
            )

            end = {
                time: moment(itinerary.endTime).format('LT')
                name: p13n.getTranslatedAttr(@route.get('plan').to.translatedName) || @route.get('plan').to.name
                address: p13n.getTranslatedAttr(
                    @model.getDestination().get 'street_address'
                )
            }

            route = {
                duration: Math.round(itinerary.duration / 60) + ' min'
                walk_distance: (itinerary.walkDistance / 1000).toFixed(1) + 'km'
                legs: legs
                end: end
            }
            choices = @getItineraryChoices()

            skip_route: false
            profile_set: _.keys(p13n.getAccessibilityProfileIds(true)).length
            itinerary: route
            itinerary_choices: choices
            selected_itinerary_index: @route.get 'selected_itinerary'
            details_open: @detailsOpen
            current_time: moment(new Date()).format('YYYY-MM-DDTHH:mm')

        parseSteps: (leg) ->
            steps = []

            if leg.mode in ['WALK', 'BICYCLE', 'CAR']
                for step in leg.steps
                    warning = null
                    if step.bogusName
                        step.streetName = i18n.t "otp.bogus_name.#{step.streetName.replace ' ', '_' }"
                    else if p13n.getTranslatedAttr step.translatedName
                        step.streetName = p13n.getTranslatedAttr step.translatedName
                    text = i18n.t "otp.step_directions.#{step.relativeDirection}",
                        {street: step.streetName, postProcess: "fixFinnishStreetNames"}
                    if 'alerts' of step and step.alerts.length
                        warning = step.alerts[0].alertHeaderText.someTranslation
                    steps.push(text: text, warning: warning)
            else if leg.mode in MODES_WITH_STOPS and leg.intermediateStops
                if 'alerts' of leg and leg.alerts.length
                    for alert in leg.alerts
                        steps.push(
                            text: ""
                            warning: alert.alertHeaderText.someTranslation
                        )
                for stop in leg.intermediateStops
                    steps.push(
                        text: p13n.getTranslatedAttr(stop.translatedName) || stop.name
                        time: moment(stop.arrival).format('LT')
                    )
            else
                steps.push(text: 'No further info.')


            return steps

        getLegDistance: (leg, steps) ->
            if leg.mode in MODES_WITH_STOPS
                stops = _.reject(steps, (step) -> 'warning' of step)
                return "#{stops.length} #{i18n.t('transit.stops')}"
            else
                return (leg.distance / 1000).toFixed(1) + 'km'

        getTransitDestination: (leg) ->
            if leg.mode in MODES_WITH_STOPS
                return "#{i18n.t('transit.toward')} #{leg.headsign}"
            else
                return ''

        getRouteText: (leg) ->
            route = if leg.route.length < 5 then leg.route else ''
            if leg.mode == 'FERRY'
                route = ''
            return route

        getItineraryChoices: ->
            numberOfItineraries = @route.get('plan').itineraries.length
            start = @itineraryChoicesStartIndex
            stop = Math.min(start + NUMBER_OF_CHOICES_SHOWN, numberOfItineraries)
            _.range(start, stop)

        switchItinerary: (event) ->
            event.preventDefault()
            @detailsOpen = true
            @route.set 'selected_itinerary', $(event.currentTarget).data('index')
            @render()

        setAccessibility: (event) ->
            event.preventDefault()
            p13n.trigger 'user:open'


    RouteView

define [
    'typeahead.bundle',
    'app/models',
    'app/jade',
    'app/search',
    'app/geocoding',
    'app/views/base',
], (
    typeahead,
    models,
    jade,
    search,
    geocoding,
    base
) ->
    class SearchInputView extends base.SMItemView
        classname: 'search-input-element'
        template: 'navigation-search'

        initialize: (@model, @searchResults) ->
            @listenTo @searchResults, 'ready', @adaptToQuery
            @listenTo @searchResults, 'reset', =>
                if @searchResults.isEmpty()
                    @setInputText ''

        adaptToQuery: (model, value, opts) ->
            $container = @$el.find('.action-button')
            $icon = $container.find('span')
            if @isEmpty()
                if @searchResults.query?.length
                    @setInputText @searchResults.query
                    @trigger 'open'
            if @isEmpty() or @getInputText() == @searchResults.query
                $icon.removeClass 'icon-icon-forward-bold'
                $icon.addClass 'icon-icon-close'
                $container.removeClass 'search-button'
                $container.addClass 'close-button'
            else
                $icon.addClass 'icon-icon-forward-bold'
                $icon.removeClass 'icon-icon-close'
                $container.removeClass 'close-button'
                $container.addClass 'search-button'

        events:
            'typeahead:selected': 'autosuggestShowDetails'
            # Important! The following ensures the click
            # will only cause the intended typeahead selection,
            # and doesn't affect the header state
            'click .tt-suggestion': (e) ->
                e.stopPropagation()
            'click input': '_onInputClicked'
            'click .typeahead-suggestion.fulltext': 'executeQuery'
            'click .action-button.search-button': 'search'
            'submit .input-container': 'search'
            'input input': 'checkInputValue'

        checkInputValue: ()->
            if @isEmpty()
                @$searchEl.typeahead('val', '')
                app.commands.execute 'clearSearchResults', navigate: true

        search: (e) ->
            e.stopPropagation()
            unless @isEmpty()
                @$searchEl.typeahead 'close'
                @executeQuery()
            e.preventDefault()

        isEmpty: () ->
            query = @getInputText()
            if query? and query.length > 0
                return false
            return true

        _onInputClicked: (ev) ->
            @trigger 'open'
            ev.stopPropagation()

        _getSearchEl: ->
            if @$searchEl?
                @$searchEl
            else
                @$searchEl = @$el.find 'input.form-control[type=search]'

        setInputText: (query) ->
            $el = @_getSearchEl()
            if $el.length
                $el.typeahead 'val', query

        getInputText: ->
            $el = @_getSearchEl()
            if $el.length
                $el.typeahead 'val'
            else
                null

        onRender: () ->
            @enableTypeahead('input.form-control[type=search]')
            @setTypeaheadWidth()
            $(window).resize => @setTypeaheadWidth()

        setTypeaheadWidth: ->
            windowWidth = window.innerWidth or document.documentElement.clientWidth or document.body.clientWidth
            if windowWidth < appSettings.mobile_ui_breakpoint
                width = $('#navigation-header').width()
                @$el.find('.tt-dropdown-menu').css 'width': width
            else
                @$el.find('.tt-dropdown-menu').css 'width': 'auto'

        enableTypeahead: (selector) ->
            @$searchEl = @$el.find selector
            serviceDataset =
                name: 'service'
                source: search.servicemapEngine.ttAdapter(),
                displayKey: (c) -> c.name[p13n.getLanguage()]
                templates:
                    suggestion: (ctx) -> jade.template 'typeahead-suggestion', ctx
            eventDataset =
                name: 'event'
                source: search.linkedeventsEngine.ttAdapter(),
                displayKey: (c) -> c.name[p13n.getLanguage()]
                templates:
                    suggestion: (ctx) -> jade.template 'typeahead-suggestion', ctx


            # A hack needed to ensure the header is always rendered.
            fullDataset =
                name: 'header'
                # Source has to return non-empty list
                source: (q, c) -> c([{query: q, object_type: 'query'}])
                displayKey: (s) -> s.query
                name: 'full'
                templates:
                    suggestion: (s) -> jade.template 'typeahead-fulltext', s

            @geocoderBackend = new geocoding.GeocoderSourceBackend()
            @$searchEl.typeahead hint: false, [
                fullDataset,
                @geocoderBackend.getDatasetOptions(),
                serviceDataset,
                eventDataset]
            @geocoderBackend.setOptions
                $inputEl: @$searchEl
                selectionCallback: (ev, data) ->
                    app.commands.execute 'selectPosition', data
        getQuery: () ->
            return $.trim @$searchEl.val()

        executeQuery: () ->
            @geocoderBackend.street = null
            @$searchEl.typeahead 'close'
            app.commands.execute 'search', @getInputText()

        autosuggestShowDetails: (ev, data, _) ->
            # Remove focus from the search box to hide keyboards on touch devices.
            # TODO: re-enable in a compatible way
            #$('.search-container input').blur()
            model = null
            objectType = data.object_type
            if objectType == 'address'
                return
            @$searchEl.typeahead 'val', ''
            app.commands.execute 'clearSearchResults', navigate: false
            $('.search-container input').val('')
            @$searchEl.typeahead 'close'
            switch objectType
                when 'unit'
                    model = new models.Unit(data)
                    app.commands.execute 'selectUnit', model, replace: true
                when 'service'
                    app.commands.execute 'addService',
                        new models.Service(data)
                when 'event'
                    app.commands.execute 'selectEvent',
                        new models.Event(data)
                when 'query'
                    app.commands.execute 'search', data.query

define [
    'underscore',
    'i18next',
    'app/models',
    'app/views/base',
    'app/views/radius',
    'app/spinner'
], (
    _,
    i18n,
    models,
    base,
    RadiusControlsView,
    SMSpinner
) ->

    RESULT_TYPES =
        unit: models.UnitList
        service: models.ServiceList
        # event: models.EventList
        address: models.PositionList

    EXPAND_CUTOFF = 3
    PAGE_SIZE = 20

    isElementInViewport = (el) ->
      if typeof jQuery == 'function' and el instanceof jQuery
        el = el[0]
      rect = el.getBoundingClientRect()
      return rect.bottom <= (window.innerHeight or document.documentElement.clientHeight) + (el.offsetHeight * 0)


    class SearchResultView extends base.SMItemView
        template: 'search-result'
        tagName: 'li'
        events: ->
            keyhandler = @keyboardHandler @selectResult, ['enter']
            'click': 'selectResult'
            'keydown': keyhandler
            'focus': 'highlightResult'
            'mouseenter': 'highlightResult'
        initialize: (opts) ->
            @order = opts.order
        selectResult: (ev) ->
            object_type = @model.get('object_type') or 'unit'
            switch object_type
                when 'unit'
                    app.commands.execute 'selectUnit', @model
                when 'service'
                    app.commands.execute 'addService', @model
                when 'address'
                    app.commands.execute 'selectPosition', @model

        highlightResult: (ev) ->
            app.commands.execute 'highlightUnit', @model

        serializeData: ->
            data = super()
            data.specifier_text = @model.getSpecifierText()
            switch @order
                when 'distance'
                    fn = @model.getDistanceToLastPosition
                    if fn?
                        data.distance = fn.apply @model
                when 'accessibility'
                    fn = @model.getShortcomingCount
                    if fn?
                        data.shortcomings = fn.apply @model
            if @model.get('object_type') == 'address'
                data.name = @model.humanAddress exclude: municipality: true
            data

    class SearchResultsView extends base.SMCollectionView
        tagName: 'ul'
        className: 'main-list'
        itemView: SearchResultView
        itemViewOptions: ->
            order: @parent.getComparatorKey()
        initialize: (opts) ->
            super opts
            @parent = opts.parent

    class LocationPromptView extends base.SMItemView
        tagName: 'ul'
        className: 'main-list'
        render: ->
            @$el.html "<li>#{i18n.t('search.location_info')}</li>"
            @

    class SearchResultsLayoutView extends base.SMLayout
        template: 'search-results'
        regions:
            results: '.result-contents'
            controls: '#list-controls'
        className: 'search-results-container'
        events:
            'click .back-button': 'goBack'
            'click .sorting': 'cycleSorting'

        goBack: (ev) ->
            @expansion = EXPAND_CUTOFF
            @requestedExpansion = 0
            @parent.backToSummary()

        cycleSorting: (ev) ->
            @fullCollection.cycleComparator()
            key = @fullCollection.getComparatorKey()
            @renderLocationPrompt = false
            if key == 'distance'
                unless p13n.getLastPosition()?
                    @renderLocationPrompt = true
                    @listenTo p13n, 'position', =>
                        @renderLocationPrompt = false
                        @fullCollection.sort()
                    @listenTo p13n, 'position_error', =>
                        @renderLocationPrompt = false
                    p13n.requestLocation()
            @expansion = 2 * PAGE_SIZE
            @render()

        onBeforeRender: ->
            @collection = new @fullCollection.constructor @fullCollection.slice(0, @expansion)

        nextPage: (ev) ->
            if @expansion == EXPAND_CUTOFF
                # Initial expansion
                delta = 2 * PAGE_SIZE - EXPAND_CUTOFF
            else
                # Already expanded, next page
                delta = PAGE_SIZE
            newExpansion = @expansion + delta

            # Only handle repeated scroll events once.
            if @requestedExpansion == newExpansion then return
            @requestedExpansion = newExpansion

            @expansion = @requestedExpansion
            @render()

        getDetailedFieldset: ->
            switch @resultType
                when 'unit'
                    ['services']
                when 'service'
                    ['ancestors']
                else
                    null

        initialize: ({
            collectionType: @collectionType
            fullCollection: @fullCollection
            resultType: @resultType
            parent: @parent
            onlyResultType: @onlyResultType
            position: @position
        }) ->
            @expansion = EXPAND_CUTOFF
            @$more = null
            @requestedExpansion = 0
            @ready = false
            @ready = true
            if @onlyResultType
                @expansion = 2 * PAGE_SIZE
                @parent?.expand @resultType
            @listenTo @fullCollection, 'hide', =>
                @hidden = true
                @render()
            @listenTo @fullCollection, 'show-all', @nextPage
            @listenTo @fullCollection, 'sort', @render
            @listenTo @fullCollection, 'batch-remove', @render
            @listenTo p13n, 'accessibility-change', =>
                key = @fullCollection.getComparatorKey()
                if p13n.hasAccessibilityIssues()
                    @fullCollection.setComparator 'accessibility'
                else if key == 'accessibility'
                    @fullCollection.setDefaultComparator()
                @fullCollection.sort()
                @render()

        getComparatorKey: ->
            @fullCollection.getComparatorKey()

        serializeData: ->
            if @hidden or not @collection?
                return hidden: true
            data = super()
            if @collection.length
                crumb = switch @collectionType
                    when 'search'
                        i18n.t('sidebar.search_results')
                    when 'radius'
                        if @position?
                            @position.humanAddress()
                data =
                    comparatorKey: @fullCollection.getComparatorKey()
                    controls: @collectionType == 'radius'
                    target: @resultType
                    expanded: @_expanded()
                    showAll: false
                    showMore: false
                    onlyResultType: @onlyResultType
                    crumb: crumb
                    header: i18n.t("search.type.#{@resultType}.count", count: @fullCollection.length)
                if @fullCollection.length > EXPAND_CUTOFF and !@_expanded()
                    data.showAll = i18n.t "search.type.#{@resultType}.show_all",
                        count: @fullCollection.length
                else if @fullCollection.length > @expansion and not @renderLocationPrompt
                    data.showMore = true
            data

        onRender: ->
            if @renderLocationPrompt
                @results.show new LocationPromptView()
                return
            unless @ready
                @ready = true
                return
            collectionView = new SearchResultsView
                collection: @collection
                parent: @
            @listenTo collectionView, 'collection:rendered', =>
                _.defer =>
                    @$more = $(@el).find '.show-more'
                    # Just in case the initial long list somehow
                    # fits inside the page:
                    @tryNextPage()
                    @trigger 'rendered'
            @results.show collectionView
            if @collectionType == 'radius'
                @controls.show new RadiusControlsView radius: @fullCollection.filters.distance

        tryNextPage: ->
            if @$more?.length
                if isElementInViewport @$more
                    @$more.find('.text-content').html i18n.t('accessibility.pending')
                    spinner = new SMSpinner
                        container: @$more.find('.spinner-container').get(0),
                        radius: 5,
                        length: 3,
                        lines: 12,
                        width: 2,
                    spinner.start()
                    @nextPage()

        _expanded: ->
            @expansion > EXPAND_CUTOFF

    class BaseListingLayoutView extends base.SMLayout
        className: -> 'search-results navigation-element limit-max-height'
        events: ->
            'scroll': 'tryNextPage'
        onRender: ->
            view = @getPrimaryResultLayoutView()
            unless view?
                return
            @listenToOnce view, 'rendered', =>
                _.defer => @$el.find('.search-result').first().focus()

    class UnitListLayoutView extends BaseListingLayoutView
        template: 'service-units'
        regions:
            'unitRegion': '.unit-region'
        tryNextPage: ->
            @resultLayoutView.tryNextPage()
        initialize: (opts, rest...) ->
            @resultLayoutView = new SearchResultsLayoutView opts, rest...
        onRender: ->
            @unitRegion.show @resultLayoutView
            super()
        getPrimaryResultLayoutView: ->
            @resultLayoutView

    class SearchLayoutView extends BaseListingLayoutView
        template: 'search-layout'
        type: 'search'
        events: ->
            _.extend {}, super(), 'click .show-all': 'showAllOfSingleType'
        tryNextPage: ->
            if @expanded
                @resultLayoutViews[@expanded]?.tryNextPage()
        expand: (target) ->
            @expanded = target
        showAllOfSingleType: (ev) ->
            ev?.preventDefault()
            target = $(ev.currentTarget).data 'target'
            @expanded = target
            _(@collections).each (collection, key) =>
                if key == target
                    collection.trigger 'show-all'
                else
                    collection.trigger 'hide'
        backToSummary: ->
            @expanded = null
            @render()

        _regionId: (key) ->
            "#{key}Region"
        _getRegionForType: (key) ->
            @getRegion @_regionId(key)

        initialize: ->
            @expanded = null
            @collections = {}
            @resultLayoutViews = {}

            _(RESULT_TYPES).each (val, key) =>
                @collections[key] = new val(null, setComparator: true)
                @addRegion @_regionId(key), ".#{key}-region"

            @listenTo @collection, 'hide', => @$el.hide()

        serializeData: ->
            data = super()
            _(RESULT_TYPES).each (__, key) =>
                @collections[key].set @collection.where(object_type: key)
            #@collections.unit.sort()

            unless @collection.length
                if @collection.query
                    data.noResults = true
                    data.query = @collection.query
            data

        getPrimaryResultLayoutView: ->
            @resultLayoutViews['unit']

        onRender: ->
            @$el.show()
            resultTypeCount = _(@collections).filter((c) => c.length > 0).length
            _(RESULT_TYPES).each (__, key) =>
                if @collections[key].length
                    @resultLayoutViews[key] = new SearchResultsLayoutView
                        resultType: key
                        collectionType: 'search'
                        fullCollection: @collections[key]
                        onlyResultType: resultTypeCount == 1
                        parent: @
                    @_getRegionForType(key).show @resultLayoutViews[key]
            super()

    SearchLayoutView: SearchLayoutView
    UnitListLayoutView: UnitListLayoutView

define [
    'underscore',
    'app/p13n',
    'app/views/base',
], (
    _,
    p13n,
    base
)  ->

    class ServiceCartView extends base.SMItemView
        template: 'service-cart'
        tagName: 'ul'
        className: 'expanded container main-list'
        events: ->
            'click .personalisation-container .maximizer': 'maximize'
            'keydown .personalisation-container .maximizer': @keyboardHandler @maximize, ['space', 'enter']
            'click .button.cart-close-button': 'minimize'
            'click .button.close-button': 'closeService'
            'keydown .button.close-button': @keyboardHandler @closeService, ['space', 'enter']
            'click input': 'selectLayerInput'
            'click label': 'selectLayerLabel'
        initialize: (opts) ->
            @collection = opts.collection
            @listenTo @collection, 'add', @maximize
            @listenTo @collection, 'remove', =>
                if @collection.length
                    @render()
                else
                    @minimize()
            @listenTo @collection, 'reset', @render
            @listenTo @collection, 'minmax', @render
            @listenTo p13n, 'change', (path, value) =>
                if path[0] == 'map_background_layer' then @render()
            if @collection.length
                @minimized = false
            else
                @minimized = true
        maximize: ->
            @minimized = false
            @collection.trigger 'minmax'
        minimize: ->
            @minimized = true
            @collection.trigger 'minmax'
        onRender: ->
            if @minimized
                @$el.removeClass 'expanded'
                @$el.addClass 'minimized'
            else
                @$el.addClass 'expanded'
                @$el.removeClass 'minimized'
                _.defer =>
                    @$el.find('input:checked').first().focus()
        serializeData: ->
            if @minimized
                return minimized: true
            data = super()
            data.layers = p13n.getMapBackgroundLayers()
            data
        closeService: (ev) ->
            app.commands.execute 'removeService', $(ev.currentTarget).data('service')
        _selectLayer: (value) ->
            p13n.setMapBackgroundLayer value
        selectLayerInput: (ev) ->
            @_selectLayer $(ev.currentTarget).attr('value')
        selectLayerLabel: (ev) ->
            @_selectLayer $(ev.currentTarget).data('layer')

define [
    'i18next',
    'app/views/base'
],
(
    {t: t},
    {SMItemView: SMItemView}
) ->
    ServiceMapDisclaimersView: class ServiceMapDisclaimersView extends SMItemView
        template: 'description-of-service'
        className: 'content modal-dialog about'
        serializeData: ->
            lang: p13n.getLanguage()
    ServiceMapDisclaimersOverlayView: class ServiceMapDisclaimersOverlayView extends SMItemView
        template: 'disclaimers-overlay'
        serializeData: ->
            layer = p13n.get('map_background_layer')
            if layer in ['servicemap', 'accessible_map']
                copyrightLink = "https://www.openstreetmap.org/copyright"
            copyright: t "disclaimer.copyright.#{layer}"
            copyrightLink: copyrightLink
        events:
            'click #about-the-service': 'onAboutClick'
        onAboutClick: (ev) ->
            app.commands.execute 'showServiceMapDescription'

define [
    'underscore',
    'i18next',
    'app/models'
    'app/views/base',
], (
    _,
    i18n,
    models,
    base
)  ->

    class ServiceTreeView extends base.SMLayout
        id: 'service-tree-container'
        className: 'navigation-element'
        template: 'service-tree'
        events: ->
            openOnKbd = @keyboardHandler @openService, ['enter']
            toggleOnKbd = @keyboardHandler @toggleLeafButton, ['enter', 'space']
            'click .service.has-children': 'openService'
            'keydown .service.parent': openOnKbd
            'keydown .service.has-children': openOnKbd
            'keydown .service.has-children a.show-icon': toggleOnKbd
            'click .service.parent': 'openService'
            'click .crumb': 'handleBreadcrumbClick'
            'click .service.leaf': 'toggleLeaf'
            'keydown .service.leaf': toggleOnKbd
            'click .service .show-icon': 'toggleButton'
            'mouseenter .service .show-icon': 'showTooltip'
            'mouseleave .service .show-icon': 'removeTooltip'
        type: 'service-tree'

        initialize: (options) ->
            @selectedServices = options.selectedServices
            @breadcrumbs = options.breadcrumbs
            @animationType = 'left'
            @scrollPosition = 0
            @listenTo @selectedServices, 'remove', @render
            @listenTo @selectedServices, 'add', @render
            @listenTo @selectedServices, 'reset', @render

        toggleLeaf: (event) ->
            @toggleElement($(event.currentTarget).find('.show-icon'))
        toggleLeafButton: (event) ->
            @toggleElement $(event.currentTarget)

        toggleButton: (event) ->
            @removeTooltip()
            event.preventDefault()
            event.stopPropagation()
            @toggleElement($(event.target))

        showTooltip: (event) ->
            @removeTooltip()
            @$tooltipElement = $("<div id=\"tooltip\">#{i18n.t('sidebar.show_tooltip')}</div>")
            $targetEl = $(event.currentTarget)
            $('body').append @$tooltipElement
            buttonOffset = $targetEl.offset()
            originalOffset = @$tooltipElement.offset()
            @$tooltipElement.css 'top', "#{buttonOffset.top + originalOffset.top}px"
            @$tooltipElement.css 'left', "#{buttonOffset.left + originalOffset.left}px"
        removeTooltip: (event) ->
            @$tooltipElement?.remove()

        getShowIconClasses: (showing, rootId) ->
            if showing
                return "show-icon selected service-color-#{rootId}"
            else
                return "show-icon service-hover-color-#{rootId}"

        toggleElement: ($targetElement) ->
            serviceId = $targetElement.closest('li').data('service-id')
            unless @selected(serviceId) is true
                app.commands.execute 'clearSearchResults'
                service = new models.Service id: serviceId
                service.fetch
                    success: =>
                        app.commands.execute 'addService', service
            else
                app.commands.execute 'removeService', serviceId

        handleBreadcrumbClick: (event) ->
            event.preventDefault()
            # We need to stop the event from bubling to the containing element.
            # That would make the service tree go back only one step even if
            # user is clicking an earlier point in breadcrumbs.
            event.stopPropagation()
            @openService(event)

        openService: (event) ->
            $target = $(event.currentTarget)
            serviceId = $target.data('service-id')
            serviceName = $target.data('service-name')
            @animationType = $target.data('slide-direction')

            if not serviceId
                return null

            if serviceId == 'root'
                serviceId = null
                # Use splice to affect the original breadcrumbs array.
                @breadcrumbs.splice 0, @breadcrumbs.length
            else
                # See if the service is already in the breadcrumbs.
                index = _.indexOf(_.pluck(@breadcrumbs, 'serviceId'), serviceId)
                if index != -1
                    # Use splice to affect the original breadcrumbs array.
                    @breadcrumbs.splice index, @breadcrumbs.length - index
                @breadcrumbs.push(serviceId: serviceId, serviceName: serviceName)

            spinnerOptions =
                container: $target.get(0)
                hideContainerContent: true
            @collection.expand serviceId, spinnerOptions

        onRender: ->
            if @serviceToDisplay
                $targetElement = @$el.find("[data-service-id=#{@serviceToDisplay.id}]").find('.show-icon')
                @serviceToDisplay = false
                @toggleElement($targetElement)

            $ul = @$el.find('ul')
            $ul.on('scroll', (ev) =>
                @scrollPosition = ev.currentTarget.scrollTop)
            $ul.scrollTop(@scrollPosition)
            @scrollPosition = 0
            @setBreadcrumbWidths()

        setBreadcrumbWidths: ->
            CRUMB_MIN_WIDTH = 40
            # We need to use the last() jQuery method here, because at this
            # point the animations are still running and the DOM contains,
            # both the old and the new content. We only want to get the new
            # content and its breadcrumbs as a basis for our calculations.
            $container = @$el.find('.header-item').last()
            $crumbs = $container.find('.crumb')
            return unless $crumbs.length > 1

            # The last breadcrumb is given preference, so separate that from the
            # rest of the breadcrumbs.
            $lastCrumb = $crumbs.last()
            $crumbs = $crumbs.not(':last')

            $chevrons = $container.find('.icon-icon-forward')
            spaceAvailable = $container.width() - ($chevrons.length * $chevrons.first().outerWidth())
            lastWidth = $lastCrumb.width()
            spaceNeeded = lastWidth + $crumbs.length * CRUMB_MIN_WIDTH

            if spaceNeeded > spaceAvailable
                # Not enough space -> make the last breadcrumb narrower.
                lastWidth = spaceAvailable - $crumbs.length * CRUMB_MIN_WIDTH
                $lastCrumb.css('max-width': lastWidth)
                $crumbs.css('max-width': CRUMB_MIN_WIDTH)
            else
                # More space -> Make the other breadcrumbs wider.
                crumbWidth = (spaceAvailable - lastWidth) / $crumbs.length
                $crumbs.css('max-width': crumbWidth)

        selected: (serviceId) ->
            @selectedServices.get(serviceId)?
        close: ->
            @removeTooltip()
            @remove()
            @stopListening()

        serializeData: ->
            classes = (category) ->
                if category.get('children').length > 0
                    return ['service has-children']
                else
                    return ['service leaf']

            listItems = @collection.map (category) =>
                selected = @selected(category.id)

                rootId = category.get 'root'

                id: category.get 'id'
                name: category.getText 'name'
                classes: classes(category).join " "
                has_children: category.attributes.children.length > 0
                unit_count: category.attributes.unit_count or 1
                selected: selected
                root_id: rootId
                show_icon_classes: @getShowIconClasses selected, rootId

            parentItem = {}
            back = null

            if @collection.chosenService
                back = @collection.chosenService.get('parent') or 'root'
                parentItem.name = @collection.chosenService.getText 'name'
                parentItem.rootId = @collection.chosenService.get 'root'

            data =
                back: back
                parent_item: parentItem
                list_items: listItems
                breadcrumbs: _.initial @breadcrumbs # everything but the last crumb

        onRender: ->
            $target = null
            if @collection.chosenService
                $target = @$el.find('li.service.parent.header-item')
            else
                $target = @$el.find('li.service').first()
            _.defer =>
                $target
                .focus()
                .addClass('autofocus')
                .on 'blur', () ->
                    $target.removeClass('autofocus')


define [
    'underscore',
    'backbone.marionette',
    'app/jade',
    'app/animations'
], (
    _,
    Marionette,
    jade,
    animations
) ->

    class SidebarRegion extends Marionette.Region

        SUPPORTED_ANIMATIONS = ['left', 'right']

        _trigger: (eventName, view) =>
            Marionette.triggerMethod.call(@, eventName, view)
            if _.isFunction view.triggerMethod
                view.triggerMethod eventName
            else
                Marionette.triggerMethod.call(view, eventName)

        show: (view, options) =>
            showOptions = options or {}
            @ensureEl()
            isViewClosed = view.isClosed or _.isUndefined(view.$el)
            isDifferentView = view != @currentView
            preventClose =  !!showOptions.preventClose
            _shouldCloseView = not preventClose and isDifferentView
            animationType = showOptions.animationType
            $oldContent = @currentView?.$el

            shouldAnimate = $oldContent?.length and animationType in SUPPORTED_ANIMATIONS and view.template?

            # RENDER WITH ANIMATIONS
            # ----------------------
            if shouldAnimate
                data = view.serializeData?() or {}
                templateString = jade.template view.template, data
                $container = @$el
                $newContent = view.$el.append($(templateString))

                @_trigger('before:render', view)
                @_trigger('before:show', view)

                animationCallback = =>
                    @close() if _shouldCloseView
                    @currentView = view
                    @_trigger('render', view)
                    @_trigger('show', view)

                animations.render($container, $oldContent, $newContent, animationType, animationCallback)

            # RENDER WITHOUT ANIMATIONS
            # -------------------------
            else
                # Close the old view
                @close() if _shouldCloseView

                view.render()
                @_trigger('before:show', view)

                # Attach the view's Html to the region's el
                if isDifferentView or isViewClosed
                    @open view

                @currentView = view
                @_trigger('show', view)

            return @

        # Close the currentView
        close: ->
            view = @currentView
            return if not view or view.isClosed

            # call 'close' or 'remove', depending on which is found
            if view.close
                view.close()
            else if view.remove
                view.remove()

            Marionette.triggerMethod.call(@, 'close', view)
            delete @currentView

    return SidebarRegion

define [
    'app/p13n',
    'app/jade',
    'app/views/base',
], (
    p13n,
    jade,
    base
)  ->

    class TitleView extends base.SMItemView
        className:
            'title-control'
        render: =>
            @el.innerHTML = jade.template 'title-view', lang: p13n.getLanguage(), root: appSettings.url_prefix
            @el

    class LandingTitleView extends base.SMItemView
        template: 'landing-title-view'
        id: 'title'
        className: 'landing-title-control'
        initialize: ->
            @listenTo(app.vent, 'title-view:hide', @hideTitleView)
            @listenTo(app.vent, 'title-view:show', @unHideTitleView)
        serializeData: ->
            isHidden: @isHidden
            lang: p13n.getLanguage()
        hideTitleView: ->
            $('body').removeClass 'landing'
            @isHidden = true
            @render()
        unHideTitleView: ->
            $('body').addClass 'landing'
            @isHidden = false
            @render()

    TitleView: TitleView
    LandingTitleView: LandingTitleView

define [
    'i18next',
    'harvey',
    'app/p13n',
    'app/dateformat',
    'app/draw',
    'app/map-view',
    'app/views/base',
    'app/views/route',
    'app/views/accessibility'
], (
    i18n,
    _harvey,
    p13n,
    dateformat,
    draw,
    MapView,
    base,
    RouteView,
    {AccessibilityDetailsView: AccessibilityDetailsView}
)  ->

    class UnitDetailsView extends base.SMLayout
        id: 'details-view-container'
        className: 'navigation-element'
        template: 'details'
        regions:
            'routeRegion': '.section.route-section'
            'accessibilityRegion': '.section.accessibility-section'
            'eventsRegion': '.event-list'
            'feedbackRegion': '.feedback-list'
        events:
            'click .back-button': 'userClose'
            'click .icon-icon-close': 'userClose'
            'click .map-active-area': 'showMap'
            'click .show-map': 'showMap'
            'click .mobile-header': 'showContent'
            'click .show-more-events': 'showMoreEvents'
            'click .disabled': 'preventDisabledClick'
            'click .set-accessibility-profile': 'openAccessibilityMenu'
            'click .leave-feedback': 'leaveFeedbackOnAccessibility'
            'click .section.main-info .description .body-expander': 'toggleDescriptionBody'
            'show.bs.collapse': 'scrollToExpandedSection'
            'click .send-feedback': '_onClickSendFeedback'
        type: 'details'

        initialize: (options) ->
            @INITIAL_NUMBER_OF_EVENTS = 5
            @NUMBER_OF_EVENTS_FETCHED = 20
            @embedded = options.embedded
            @searchResults = options.searchResults
            @selectedUnits = options.selectedUnits
            @selectedPosition = options.selectedPosition
            @routingParameters = options.routingParameters
            @route = options.route
            @listenTo @searchResults, 'reset', @render

        _$getMobileHeader: ->
            @$el.find '.mobile-header'
        _$getDefaultHeader: ->
            @$el.find '.content .main-info .header'
        _hideHeader: ($header) ->
            $header.attr 'aria-hidden', 'true'
        _showHeader: ($header) ->
            $header.removeAttr 'aria-hidden'
        _attachMobileHeaderListeners: ->
            Harvey.attach '(max-width:767px)',
                on: =>
                    @_hideHeader @_$getDefaultHeader()
                    @_showHeader @_$getMobileHeader()
            Harvey.attach '(min-width:768px)',
                on: =>
                    @_hideHeader @_$getMobileHeader()
                    @_showHeader @_$getDefaultHeader()
        _onClickSendFeedback: (ev) ->
            app.commands.execute 'composeFeedback', @model
        onRender: ->
            # Events
            #
            if @model.eventList.isEmpty()
                @listenTo @model.eventList, 'reset', (list) =>
                    @updateEventsUi(list.fetchState)
                    @renderEvents(list)
                @model.eventList.pageSize = @INITIAL_NUMBER_OF_EVENTS
                @model.getEvents()
                @model.eventList.pageSize = @NUMBER_OF_EVENTS_FETCHED
                @model.getFeedback()
            else
                @updateEventsUi(@model.eventList.fetchState)
                @renderEvents(@model.eventList)

            if @model.feedbackList.isEmpty()
                @listenTo @model.feedbackList, 'reset', (list) =>
                    @renderFeedback @model.feedbackList
            else
                @renderFeedback @model.feedbackList

            @accessibilityRegion.show new AccessibilityDetailsView
                model: @model
            @routeRegion.show new RouteView
                model: @model
                route: @route
                parentView: @
                routingParameters: @routingParameters
                selectedUnits: @selectedUnits
                selectedPosition: @selectedPosition

            app.vent.trigger 'site-title:change', @model.get('name')
            @_attachMobileHeaderListeners()

            markerCanvas = @$el.find('#details-marker-canvas').get(0)
            markerCanvasMobile = @$el.find('#details-marker-canvas-mobile').get(0)
            context = markerCanvas.getContext('2d')
            contextMobile = markerCanvasMobile.getContext('2d')
            size = 40
            color = app.colorMatcher.unitColor(@model) or 'rgb(0, 0, 0)'
            id = 0
            rotation = 90

            marker = new draw.Plant size, color, id, rotation
            marker.draw context
            marker.draw contextMobile

            _.defer => @$el.find('a').first().focus()

        updateEventsUi: (fetchState) =>
            $eventsSection = @$el.find('.events-section')

            # Update events section short text count.
            if fetchState.count
                shortText = i18n.t 'sidebar.event_count',
                    count: fetchState.count
            else
                # Handle no events -cases.
                shortText = i18n.t('sidebar.no_events')
                @$('.show-more-events').hide()
                $eventsSection.find('.collapser').addClass('disabled')
            $eventsSection.find('.short-text').text(shortText)

            # Remove show more button if all events are visible.
            if !fetchState.next and @model.eventList.length == @eventsRegion.currentView?.collection.length
                @$('.show-more-events').hide()

        userClose: (event) ->
            event.stopPropagation()
            app.commands.execute 'clearSelectedUnit'
            unless @searchResults.isEmpty()
                app.commands.execute 'search', @searchResults.query
            @trigger 'user:close'

        preventDisabledClick: (event) ->
            event.preventDefault()
            event.stopPropagation()

        showMap: (event) ->
            event.preventDefault()
            @$el.addClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: true

        showContent: (event) ->
            event.preventDefault()
            @$el.removeClass 'minimized'
            MapView.setMapActiveAreaMaxHeight maximize: false

        getTranslatedProvider: (providerType) ->
            SUPPORTED_PROVIDER_TYPES = [101, 102, 103, 104, 105]
            if providerType in SUPPORTED_PROVIDER_TYPES
                i18n.t("sidebar.provider_type.#{ providerType }")
            else
                ''

        serializeData: ->
            embedded = @embedded
            data = @model.toJSON()
            data.provider = @getTranslatedProvider @model.get 'provider_type'
            unless @searchResults.isEmpty()
                data.back_to = i18n.t 'sidebar.back_to.search'
            MAX_LENGTH = 20
            description = data.description
            if description
                words = description.split /[ ]+/
                if words.length > MAX_LENGTH + 1
                    data.description_ingress = words[0...MAX_LENGTH].join ' '
                    data.description_body = words[MAX_LENGTH...].join ' '
                else
                    data.description_ingress = description

            data.embedded_mode = embedded
            data.feedback_count = @model.feedbackList.length
            data

        renderEvents: (events) ->
            if events?
                unless events.isEmpty()
                    @$el.find('.section.events-section').removeClass 'hidden'
                    @eventsRegion.show new EventListView
                        collection: events

        _feedbackSummary: (feedbackItems) ->
            count = feedbackItems.size()
            if count
                i18n.t 'feedback.count', count: count
            else
                ''

        renderFeedback: (feedbackItems) ->
            if @model.get('organization') != 91
                return
            if feedbackItems?
                feedbackItems.unit = @model
                feedbackSummary = @_feedbackSummary feedbackItems
                $feedbackSection = @$el.find('.feedback-section')
                $feedbackSection.find('.short-text').text feedbackSummary
                $feedbackSection.find('.feedback-count').text feedbackSummary
                @feedbackRegion.show new FeedbackListView
                    collection: feedbackItems

        showMoreEvents: (event) ->
            event.preventDefault()
            options =
                spinnerOptions:
                    container: @$('.show-more-events').get(0)
                    hideContainerContent: true
            if @model.eventList.length <= @INITIAL_NUMBER_OF_EVENTS
                @model.getEvents({}, options)
            else
                options.success = =>
                    @updateEventsUi(@model.eventList.fetchState)
                @model.eventList.fetchNext(options)

        toggleDescriptionBody: (ev) ->
            $target = $(ev.currentTarget)
            $target.toggle()
            $target.closest('.description').find('.body').toggle()

        scrollToExpandedSection: (event) ->
            $container = @$el.find('.content').first()
            # Don't scroll if route leg is expanded.
            return if $(event.target).hasClass('steps')
            $section = $(event.target).closest('.section')
            scrollTo = $container.scrollTop() + $section.position().top
            $('#details-view-container .content').animate(scrollTop: scrollTo)

        openAccessibilityMenu: (event) ->
            event.preventDefault()
            p13n.trigger 'user:open'


    class EventListRowView extends base.SMItemView
        tagName: 'li'
        template: 'event-list-row'
        events:
            'click .show-event-details': 'showEventDetails'

        serializeData: ->
            startTime = @model.get 'start_time'
            endTime = @model.get 'end_time'
            formattedDatetime = dateformat.humanizeEventDatetime(
                startTime, endTime, 'small')
            name: p13n.getTranslatedAttr(@model.get 'name')
            datetime: formattedDatetime
            info_url: p13n.getTranslatedAttr(@model.get 'info_url')

        showEventDetails: (event) ->
            event.preventDefault()
            app.commands.execute 'selectEvent', @model

    class EventListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'events'
        itemView: EventListRowView
        initialize: (opts) ->
            @parent = opts.parent

    class FeedbackItemView extends base.SMItemView
        tagName: 'li'
        template: 'feedback-list-row'
        initialize: (options) ->
            @unit = options.unit
        serializeData: ->
            data = super()
            data.unit = @unit.toJSON()
            data

    class FeedbackListView extends base.SMCollectionView
        tagName: 'ul'
        className: 'feedback'
        itemView: FeedbackItemView
        itemViewOptions: ->
            unit: @collection.unit

    UnitDetailsView


define [
    'app/draw',
    'leaflet',
    'leaflet.markercluster',
    'underscore',
    'jquery',
    'backbone',
    'app/jade'
], (
    draw,
    leaflet,
    markercluster,
    _,
    $,
    Backbone,
    jade
) ->

    anchor = (size) ->
        x = size.x/3 + 5
        y = size.y/2 + 16
        new L.Point x, y

    SMMarker = L.Marker
    REDUCED_OPACITY = 1

    initializer = ->
        # BEGIN hack to enable transparent markers
        REDUCED_OPACITY = 0.5
        OriginalMarkerCluster = L.MarkerCluster
        SMMarkerCluster = L.MarkerCluster.extend
            setOpacity: (opacity) ->
                children = @getAllChildMarkers()
                reducedProminence = false
                if children.length
                    reducedProminence = children[0].unit?.collection?.hasReducedPriority()
                if reducedProminence and opacity == 1
                    opacity = REDUCED_OPACITY
                OriginalMarkerCluster::setOpacity.call @, opacity
        L.MarkerCluster = SMMarkerCluster

        SMMarker = L.Marker.extend
            setOpacity: (opacity) ->
                if @options.reducedProminence and opacity == 1
                    opacity = REDUCED_OPACITY
                L.Marker::setOpacity.call @, opacity
        # END hack
    createMarker = (args...) ->
        new SMMarker args...

    CanvasIcon = L.Icon.extend
        initialize: (@dimension, options) ->
            @options.iconSize = new L.Point @dimension, @dimension
            @options.iconAnchor = @iconAnchor()
            @options.reducedProminence = options.reducedProminence
            @options.pixelRatio = (el) ->
                context = el.getContext('2d')
                devicePixelRatio = window.devicePixelRatio || 1
                backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1
                return devicePixelRatio / backingStoreRatio
        options:
            className: 'leaflet-canvas-icon'
        setupCanvas: ->
            el = document.createElement 'canvas'
            context = el.getContext('2d')
            # Set ratio based on device dpi
            ratio = @options.pixelRatio(el)
            # If the IE Canvas polyfill is installed, the element needs to be specially
            # initialized.
            if G_vmlCanvasManager?
                G_vmlCanvasManager.initElement el
            @_setIconStyles el, 'icon'
            s = @options.iconSize
            # Set el width based on device dpi
            el.width = s.x * ratio
            el.height = s.y * ratio
            el.style.width = s.x + 'px'
            el.style.height = s.y + 'px'
            # Scale down to normal
            context.scale(ratio, ratio)
            if @options.reducedProminence
                L.DomUtil.setOpacity el, REDUCED_OPACITY
            el
        createIcon: ->
            el = @setupCanvas()
            @draw el.getContext('2d')
            el
        createShadow: ->
            return null
        iconAnchor: ->
            anchor @options.iconSize

    CirclePolygon = L.Polygon.extend
        initialize: (latLng, radius, options) ->
            @circle = L.circle latLng, radius
            latLngs = @_calculateLatLngs()
            L.Polygon.prototype.initialize.call(@, [latLngs], options);
        _calculateLatLngs: ->
            bounds = @circle.getBounds()
            north = bounds.getNorth()
            east = bounds.getEast()
            center = @circle.getLatLng()
            lngRadius = east - center.lng
            latRadius = north - center.lat
            STEPS = 180
            for i in [0 ... STEPS]
                rad = (2 * i * Math.PI) / STEPS
                [center.lat + Math.sin(rad) * latRadius
                 center.lng + Math.cos(rad) * lngRadius]

    PlantCanvasIcon: CanvasIcon.extend
        initialize: (@dimension, @color, id, options) ->
            CanvasIcon.prototype.initialize.call this, @dimension, options
            @plant = new draw.Plant @dimension, @color, id
        draw: (ctx) ->
            @plant.draw ctx

    PointCanvasIcon: CanvasIcon.extend
        initialize: (@dimension, @color, id) ->
            CanvasIcon.prototype.initialize.call this, @dimension
            @drawer = new draw.PointPlant @dimension, @color, 2
        draw: (ctx) ->
            @drawer.draw ctx

    CanvasClusterIcon: CanvasIcon.extend
        initialize: (@count, @dimension, @colors, id, options) ->
            CanvasIcon.prototype.initialize.call this, @dimension, options
            @options.iconSize = new L.Point @dimension + 30, @dimension + 30
            if @count > 5
                @count = 5
            rotations = [130,110,90,70,50]
            translations = [[0,5],[10, 7],[12,8],[15,10],[5, 12]]
            @plants = _.map [1..@count], (i) =>
                new draw.Plant(@dimension, @colors[(i-1) % @colors.length],
                    id, rotations[i-1], translations[i-1])
        draw: (ctx) ->
            for plant in @plants
                plant.draw ctx

    PointCanvasClusterIcon: CanvasIcon.extend
        initialize: (count, @dimension, @colors, id) ->
            CanvasIcon.prototype.initialize.call this, @dimension
            @count = (Math.min(20, count) / 5) * 5
            @radius = 2
            range = =>
                @radius + Math.random() * (@dimension - 2 * @radius)
            @positions = _.map [1..@count], (i) =>
                [range(), range()]
            @clusterDrawer = new draw.PointCluster @dimension, @colors, @positions, @radius
        draw: (ctx) ->
            @clusterDrawer.draw ctx

    LeftAlignedPopup: L.Popup.extend
        _updatePosition: ->
            if !this._map
                return

            pos = this._map.latLngToLayerPoint(this._latlng)
            animated = this._animated
            offset = L.point(this.options.offset)

            properOffset =
                x: 15
                y: -27

            if animated
                pos.y = pos.y + properOffset.y
                pos.x = pos.x + properOffset.x
                L.DomUtil.setPosition(this._container, pos);

            this._containerBottom = -offset.y - (if animated then 0 else pos.y + properOffset.y)
            this._containerLeft = offset.x + (if animated then 0 else pos.x + properOffset.x)

            # bottom position the popup in case the height of the popup changes (images loading etc)
            this._container.style.bottom = this._containerBottom + 'px';
            this._container.style.left = this._containerLeft + 'px';

    ControlWrapper: L.Control.extend
        initialize: (@view, options) ->
            L.Util.setOptions @, options
        onAdd: (map) ->
            @view.render()

    initializer: initializer
    createMarker: createMarker
    CirclePolygon: CirclePolygon

//
(function() {
  define(function() {
    var ColorMatcher;
    ColorMatcher = (function() {
      ColorMatcher.serviceColors = {
        50000: [77, 139, 0],
        50001: [192, 79, 220],
        50002: [252, 173, 0],
        50003: [154, 0, 0],
        26412: [0, 81, 142],
        27918: [67, 48, 64],
        27718: [60, 210, 0],
        25000: [142, 139, 255],
        26190: [240, 66, 0]
      };

      function ColorMatcher(selectedServices) {
        this.selectedServices = selectedServices;
      }

      ColorMatcher.rgb = function(r, g, b) {
        return "rgb(" + r + ", " + g + ", " + b + ")";
      };

      ColorMatcher.rgba = function(r, g, b, a) {
        return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
      };

      ColorMatcher.prototype.serviceColor = function(service) {
        return this.serviceRootIdColor(service.get('root'));
      };

      ColorMatcher.prototype.serviceRootIdColor = function(id) {
        var b, g, r, _ref;
        _ref = this.constructor.serviceColors[id], r = _ref[0], g = _ref[1], b = _ref[2];
        return this.constructor.rgb(r, g, b);
      };

      ColorMatcher.prototype.unitColor = function(unit) {
        var b, g, r, rootService, roots, _ref;
        roots = unit.get('root_services');
        if (this.selectedServices != null) {
          rootService = _.find(roots, (function(_this) {
            return function(rid) {
              return _this.selectedServices.find(function(s) {
                return s.get('root') === rid;
              });
            };
          })(this));
        }
        if (rootService == null) {
          rootService = roots[0];
        }
        _ref = this.constructor.serviceColors[rootService], r = _ref[0], g = _ref[1], b = _ref[2];
        return this.constructor.rgb(r, g, b);
      };

      return ColorMatcher;

    })();
    return ColorMatcher;
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['jquery', 'backbone.marionette', 'app/base', 'app/models'], function($, Marionette, sm, Models) {
    var BaseControl, PAGE_SIZE;
    PAGE_SIZE = appSettings.page_size;
    return BaseControl = (function(_super) {
      __extends(BaseControl, _super);

      function BaseControl() {
        this.toggleDivision = __bind(this.toggleDivision, this);
        return BaseControl.__super__.constructor.apply(this, arguments);
      }

      BaseControl.prototype.initialize = function(appModels) {
        this.units = appModels.units;
        this.services = appModels.selectedServices;
        this.selectedUnits = appModels.selectedUnits;
        this.selectedPosition = appModels.selectedPosition;
        this.searchResults = appModels.searchResults;
        this.divisions = appModels.divisions;
        return this.selectedDivision = appModels.selectedDivision;
      };

      BaseControl.prototype.setMapProxy = function(mapProxy) {
        this.mapProxy = mapProxy;
      };

      BaseControl.prototype.setUnits = function(units, filter) {
        this.services.set([]);
        this._setSelectedUnits();
        this.units.reset(units.toArray());
        if (filter != null) {
          return this.units.setFilter(filter, true);
        } else {
          return this.units.clearFilters();
        }
      };

      BaseControl.prototype.setUnit = function(unit) {
        this.services.set([]);
        return this.units.reset([unit]);
      };

      BaseControl.prototype.getUnit = function(id) {
        return this.units.get(id);
      };

      BaseControl.prototype._setSelectedUnits = function(units, options) {
        this.selectedUnits.each(function(u) {
          return u.set('selected', false);
        });
        if (units != null) {
          _(units).each(function(u) {
            return u.set('selected', true);
          });
          return this.selectedUnits.reset(units, options);
        } else {
          if (this.selectedUnits.length) {
            return this.selectedUnits.reset([], options);
          }
        }
      };

      BaseControl.prototype.selectUnit = function(unit, opts) {
        var hasObject, requiredObjects;
        this.selectedDivision.clear();
        if (typeof this._setSelectedUnits === "function") {
          this._setSelectedUnits([unit], {
            silent: true
          });
        }
        if (opts != null ? opts.replace : void 0) {
          this.units.reset([unit]);
          this.units.clearFilters();
        } else if (!this.units.contains(unit)) {
          this.units.add(unit);
          this.units.trigger('reset', this.units);
        }
        hasObject = function(unit, key) {
          var o;
          o = unit.get(key);
          return (o != null) && typeof o === 'object';
        };
        requiredObjects = ['department', 'municipality', 'services'];
        if (!_(requiredObjects).find(function(x) {
          return !hasObject(unit, x);
        })) {
          this.selectedUnits.trigger('reset', this.selectedUnits);
          return sm.resolveImmediately();
        } else {
          return unit.fetch({
            data: {
              include: 'department,municipality,services'
            },
            success: (function(_this) {
              return function() {
                return _this.selectedUnits.trigger('reset', _this.selectedUnits);
              };
            })(this)
          });
        }
      };

      BaseControl.prototype.addUnitsWithinBoundingBoxes = function(bboxStrings, level) {
        var bboxCount, getBbox, _ref;
        if (level === 'none') {
          return;
        }
        if (level == null) {
          level = 'customer_service';
        }
        bboxCount = bboxStrings.length;
        if (bboxCount > 4) {
          null;
        }
        if (((_ref = this.selectedPosition.value()) != null ? _ref.get('radiusFilter') : void 0) != null) {
          return;
        }
        this.units.clearFilters();
        getBbox = (function(_this) {
          return function(bboxStrings) {
            var bboxString, layer, opts, unitList;
            if (bboxStrings.length === 0) {
              _this.units.setFilter('bbox', true);
              _this.units.trigger('finished', {
                keepViewport: true
              });
              return;
            }
            bboxString = _.first(bboxStrings);
            unitList = new models.UnitList(null, {
              forcedPriority: false
            });
            opts = {
              success: function(coll, resp, options) {
                if (unitList.length) {
                  _this.units.add(unitList.toArray());
                }
                if (!unitList.fetchNext(opts)) {
                  return unitList.trigger('finished', {
                    keepViewport: true
                  });
                }
              }
            };
            unitList.pageSize = PAGE_SIZE;
            unitList.setFilter('bbox', bboxString);
            layer = p13n.get('map_background_layer');
            unitList.setFilter('bbox_srid', layer === 'servicemap' || layer === 'accessible_map' ? 3067 : 3879);
            unitList.setFilter('only', 'name,location,root_services');
            if (level != null) {
              unitList.setFilter('level', level);
            }
            _this.listenTo(unitList, 'finished', function() {
              return getBbox(_.rest(bboxStrings));
            });
            return unitList.fetch(opts);
          };
        })(this);
        return getBbox(bboxStrings);
      };

      BaseControl.prototype._clearRadius = function() {};

      BaseControl.prototype.clearSearchResults = function() {};

      BaseControl.prototype.clearUnits = function() {};

      BaseControl.prototype.reset = function() {};

      BaseControl.prototype.toggleDivision = function(division) {
        var old;
        this._clearRadius();
        old = this.selectedDivision.value();
        if (old != null) {
          old.set('selected', false);
        }
        if (division === old) {
          return this.selectedDivision.clear();
        } else {
          this.selectedDivision.wrap(division);
          return division.set('selected', true);
        }
      };

      BaseControl.prototype.renderUnitById = function(id) {
        var deferred, unit;
        deferred = $.Deferred();
        unit = new Models.Unit({
          id: id
        });
        unit.fetch({
          data: {
            include: 'department,municipality,services'
          },
          success: (function(_this) {
            return function() {
              _this.setUnit(unit);
              _this.selectUnit(unit);
              return deferred.resolve(unit);
            };
          })(this)
        });
        return deferred.promise();
      };

      BaseControl.prototype.selectPosition = function(position) {
        var previous;
        if (typeof this.clearSearchResults === "function") {
          this.clearSearchResults();
        }
        if (typeof this._setSelectedUnits === "function") {
          this._setSelectedUnits();
        }
        previous = this.selectedPosition.value();
        if ((previous != null ? previous.get('radiusFilter') : void 0) != null) {
          this.units.reset([]);
          this.units.clearFilters();
        }
        if (position === previous) {
          this.selectedPosition.trigger('change:value', this.selectedPosition);
        } else {
          this.selectedPosition.wrap(position);
        }
        return sm.resolveImmediately();
      };

      BaseControl.prototype.setRadiusFilter = function(radius) {
        var opts, pos, unitList;
        this.services.reset([], {
          skip_navigate: true
        });
        this.units.reset([]);
        this.units.clearFilters();
        this.units.overrideComparatorKeys = ['distance_precalculated', 'alphabetic', 'alphabetic_reverse'];
        this.units.setComparator('distance_precalculated');
        if (this.selectedPosition.isEmpty()) {
          return;
        }
        pos = this.selectedPosition.value();
        pos.set('radiusFilter', radius);
        unitList = new models.UnitList([], {
          pageSize: PAGE_SIZE
        }).setFilter('only', 'name,location,root_services').setFilter('include', 'services,accessibility_properties').setFilter('lat', pos.get('location').coordinates[1]).setFilter('lon', pos.get('location').coordinates[0]).setFilter('distance', radius);
        opts = {
          success: (function(_this) {
            return function() {
              _this.units.add(unitList.toArray(), {
                merge: true
              });
              _this.units.setFilter('distance', radius);
              if (!unitList.fetchNext(opts)) {
                return _this.units.trigger('finished', {
                  refit: true
                });
              }
            };
          })(this)
        };
        return unitList.fetch(opts);
      };

      BaseControl.prototype._addService = function(service) {
        var ancestor;
        this._clearRadius();
        this._setSelectedUnits();
        this.services.add(service);
        if (this.services.length === 1) {
          this.units.reset([]);
          this.units.clearFilters();
          this.units.setDefaultComparator();
          this.clearSearchResults();
        }
        if (service.has('ancestors')) {
          ancestor = this.services.find(function(s) {
            var _ref;
            return _ref = s.id, __indexOf.call(service.get('ancestors'), _ref) >= 0;
          });
          if (ancestor != null) {
            this.removeService(ancestor);
          }
        }
        return this._fetchServiceUnits(service);
      };

      BaseControl.prototype._fetchServiceUnits = function(service) {
        var municipality, opts, unitList;
        unitList = new models.UnitList([], {
          pageSize: PAGE_SIZE,
          setComparator: true
        }).setFilter('service', service.id).setFilter('only', 'name,location,root_services').setFilter('include', 'services,accessibility_properties');
        municipality = p13n.get('city');
        if (municipality) {
          unitList.setFilter('municipality', municipality);
        }
        opts = {
          success: (function(_this) {
            return function() {
              _this.units.add(unitList.toArray(), {
                merge: true
              });
              service.get('units').add(unitList.toArray());
              if (!unitList.fetchNext(opts)) {
                _this.units.overrideComparatorKeys = ['alphabetic', 'alphabetic_reverse', 'distance'];
                _this.units.setDefaultComparator();
                _this.units.trigger('finished', {
                  refit: true
                });
                return service.get('units').trigger('finished');
              }
            };
          })(this)
        };
        return unitList.fetch(opts);
      };

      BaseControl.prototype.addService = function(service) {
        if (service.has('ancestors')) {
          return this._addService(service);
        } else {
          return sm.withDeferred((function(_this) {
            return function(deferred) {
              return service.fetch({
                data: {
                  include: 'ancestors'
                },
                success: function() {
                  return _this._addService(service).done(function() {
                    return deferred.resolve();
                  });
                }
              });
            };
          })(this));
        }
      };

      BaseControl.prototype._search = function(query) {
        this._clearRadius();
        this.selectedPosition.clear();
        this.clearUnits({
          all: true
        });
        return sm.withDeferred((function(_this) {
          return function(deferred) {
            var opts;
            if (_this.searchResults.query === query) {
              _this.searchResults.trigger('ready');
              deferred.resolve();
              return;
            }
            if (__indexOf.call(_(_this.units.filters).keys(), 'search') >= 0) {
              _this.units.reset([]);
            }
            if (!_this.searchResults.isEmpty()) {
              _this.searchResults.reset([]);
            }
            opts = {
              success: function() {
                if (typeof _paq !== "undefined" && _paq !== null) {
                  _paq.push(['trackSiteSearch', query, false, _this.searchResults.models.length]);
                }
                _this.units.add(_this.searchResults.filter(function(r) {
                  return r.get('object_type') === 'unit';
                }));
                _this.units.setFilter('search', true);
                if (!_this.searchResults.fetchNext(opts)) {
                  _this.searchResults.trigger('ready');
                  _this.units.trigger('finished');
                  _this.services.set([]);
                  return deferred.resolve();
                }
              }
            };
            return opts = _this.searchResults.search(query, opts);
          };
        })(this));
      };

      BaseControl.prototype.search = function(query) {
        if (query == null) {
          query = this.searchResults.query;
        }
        if ((query != null) && query.length > 0) {
          return this._search(query);
        } else {
          return sm.resolveImmediately();
        }
      };

      BaseControl.prototype.renderUnitsByServices = function(serviceIdString) {
        var deferreds, serviceIds;
        serviceIds = serviceIdString.split(',');
        deferreds = _.map(serviceIds, (function(_this) {
          return function(id) {
            return _this.addService(new models.Service({
              id: id
            }));
          };
        })(this));
        return $.when.apply($, deferreds);
      };

      BaseControl.prototype._fetchDivisions = function(divisionIds, callback) {
        return this.divisions.setFilter('ocd_id', divisionIds.join(',')).setFilter('geometry', true).fetch({
          success: callback
        });
      };

      BaseControl.prototype._getLevel = function(context, defaultLevel) {
        var _ref;
        if (defaultLevel == null) {
          defaultLevel = 'none';
        }
        return (context != null ? (_ref = context.query) != null ? _ref.level : void 0 : void 0) || defaultLevel;
      };

      BaseControl.prototype._renderDivisions = function(ocdIds, context) {
        var defaultLevel, level;
        level = this._getLevel(context, defaultLevel = 'none');
        return sm.withDeferred((function(_this) {
          return function(deferred) {
            return _this._fetchDivisions(ocdIds, function() {
              var opts;
              if (level === 'none') {
                deferred.resolve();
                return;
              }
              if (level !== 'all') {
                _this.units.setFilter('level', context.query.level);
              }
              _this.units.setFilter('division', ocdIds.join(',')).setFilter('only', ['root_services', 'location', 'name'].join(','));
              opts = {
                success: function() {
                  if (!_this.units.fetchNext(opts)) {
                    _this.units.trigger('finished');
                    return deferred.resolve();
                  }
                }
              };
              _this.units.fetch(opts);
              return _this.units;
            });
          };
        })(this));
      };

      BaseControl.prototype.renderDivision = function(municipality, divisionId, context) {
        return this._renderDivisions(["" + municipality + "/" + divisionId], context);
      };

      BaseControl.prototype.renderMultipleDivisions = function(_path, context) {
        if (context.query.ocdId.length > 0) {
          return this._renderDivisions(context.query.ocdId, context);
        }
      };

      BaseControl.prototype.renderAddress = function(municipality, street, numberPart, context) {
        var defaultLevel, level;
        level = this._getLevel(context, defaultLevel = 'none');
        return sm.withDeferred((function(_this) {
          return function(deferred) {
            var SEPARATOR, positionList, slug;
            SEPARATOR = /-/g;
            slug = "" + municipality + "/" + street + "/" + numberPart;
            positionList = models.PositionList.fromSlug(municipality, street, numberPart);
            return _this.listenTo(positionList, 'sync', function(p) {
              var addressInfo, err, exactMatch, position;
              try {
                if (p.length === 0) {
                  throw new Error('Address slug not found', slug);
                } else if (p.length === 1) {
                  position = p.pop();
                } else if (p.length > 1) {
                  exactMatch = p.filter(function(pos) {
                    var letter, letterMatch, numberEndMatch, numberParts, number_end;
                    numberParts = numberPart.split(SEPARATOR);
                    letter = pos.get('letter');
                    number_end = pos.get('number_end');
                    if (numberParts.length === 1) {
                      return letter === null && number_end === null;
                    }
                    letterMatch = function() {
                      return letter && letter.toLowerCase() === numberParts[1].toLowerCase();
                    };
                    numberEndMatch = function() {
                      return number_end && number_end === numberParts[1];
                    };
                    return letterMatch() || numberEndMatch();
                  });
                  if (exactMatch.length !== 1) {
                    throw new Error('Too many address matches');
                  }
                }
                _this.selectPosition(position);
              } catch (_error) {
                err = _error;
                addressInfo = {
                  address: slug
                };
                Raven.captureException(err, {
                  extra: addressInfo
                });
              }
              return deferred.resolve({
                afterMapInit: function() {
                  if (level !== 'none') {
                    return _this._showAllUnits(level);
                  }
                }
              });
            });
          };
        })(this));
      };

      BaseControl.prototype._showAllUnits = function(level) {
        var bbox, bboxes, transformedBounds, _i, _len;
        transformedBounds = this.mapProxy.getTransformedBounds();
        bboxes = [];
        for (_i = 0, _len = transformedBounds.length; _i < _len; _i++) {
          bbox = transformedBounds[_i];
          bboxes.push("" + bbox[0][0] + "," + bbox[0][1] + "," + bbox[1][0] + "," + bbox[1][1]);
        }
        return this.addUnitsWithinBoundingBoxes(bboxes, level);
      };

      BaseControl.prototype.renderHome = function(path, context) {
        var defaultLevel, level;
        if (!((path == null) || path === '' || (path instanceof Array && (path.length = 0)))) {
          context = path;
        }
        level = this._getLevel(context, defaultLevel = 'none');
        this.reset();
        return sm.withDeferred((function(_this) {
          return function(d) {
            return d.resolve({
              afterMapInit: function() {
                if (level !== 'none') {
                  return _this._showAllUnits(level);
                }
              }
            });
          };
        })(this));
      };

      BaseControl.prototype.renderSearch = function(path, opts) {
        var _ref;
        if (((_ref = opts.query) != null ? _ref.q : void 0) == null) {
          return;
        }
        return this.search(opts.query.q);
      };

      BaseControl.prototype._matchResourceUrl = function(path) {
        var match;
        match = path.match(/^([0-9]+)/);
        if (match != null) {
          return match[0];
        }
      };

      BaseControl.prototype.renderUnit = function(path, opts) {
        var def, id, query;
        id = this._matchResourceUrl(path);
        if (id != null) {
          def = $.Deferred();
          this.renderUnitById(id).done((function(_this) {
            return function(unit) {
              return def.resolve({
                afterMapInit: function() {
                  return _this.selectUnit(unit);
                }
              });
            };
          })(this));
          return def.promise();
        }
        query = opts.query;
        if (query != null ? query.service : void 0) {
          return this.renderUnitsByServices(opts.query.service);
        }
      };

      return BaseControl;

    })(Marionette.Controller);
  });

}).call(this);

//

(function() {
  define(['moment'], function(moment) {
    var clockWord, dateFormat, formatEventDatetime, formatSpecs, getLanguage, humanize, humanizeEventDatetime, humanizeSingleDatetime, isMultiDayEvent, isMultiMonthEvent, isMultiYearEvent;
    isMultiDayEvent = function(_arg) {
      var end, start;
      start = _arg[0], end = _arg[1];
      return (end != null) && !start.isSame(end, 'day');
    };
    isMultiYearEvent = function(_arg) {
      var end, start;
      start = _arg[0], end = _arg[1];
      return (end != null) && !start.isSame(end, 'year');
    };
    isMultiMonthEvent = function(_arg) {
      var end, start;
      start = _arg[0], end = _arg[1];
      return (end != null) && !start.isSame(end, 'month');
    };
    getLanguage = function() {
      return moment.locale();
    };
    clockWord = {
      'fi': 'klo',
      'sv': 'kl.',
      'en-gb': 'at'
    };
    dateFormat = function(specs, includeMonth, includeYear) {
      var add, format;
      if (includeMonth == null) {
        includeMonth = true;
      }
      if (includeYear == null) {
        includeYear = false;
      }
      format = [];
      add = function(x) {
        return format.push(x);
      };
      if (specs.includeWeekday) {
        add(specs.format.weekday);
      }
      if (true) {
        add(specs.format.dayOfMonth);
      }
      if (includeMonth) {
        add(specs.format.month);
      }
      if (includeYear) {
        add(specs.format.year);
      }
      return format;
    };
    humanize = function(m) {
      var day;
      day = m.calendar();
      day = day.replace(/( (klo|at))* \d{1,2}[:.]\d{1,2}$/, '');
      return day;
    };
    formatEventDatetime = function(start, end, specs) {
      var diff, endDate, format, includeMonth, includeYear, results, sod, startDate, startTime;
      results = {};
      format = dateFormat(specs, includeMonth = specs.includeStartTime || specs.includeFirstMonth, includeYear = specs.includeFirstYear);
      if (specs.humanize) {
        startDate = humanize(start);
      } else {
        startDate = start.format(format.join(' '));
      }
      startTime = start.format(specs.format.time);
      if (isMultiDayEvent([start, end])) {
        format = dateFormat(specs, includeMonth = true, includeYear = specs.includeLastYear);
        if (!specs.includeLastYear && specs.includeStartTime) {
          startDate += ' ' + startTime;
        }
        endDate = end.format(format.join(' '));
        if (!specs.includeLastYear && specs.includeEndTime) {
          endDate += ' ' + end.format(specs.format.time);
        }
      } else {
        if (specs.includeStartTime) {
          results.startTime = startTime;
        }
        if (specs.includeEndTime) {
          results.endTime = end.format(specs.format.time);
        }
      }
      sod = moment().startOf('day');
      diff = start.diff(sod, 'days', true);
      if (specs.humanizeNotice && (diff < 2) && (diff > -1)) {
        results.notice = humanize(start);
      }
      if (results.startTime) {
        results.time = "" + clockWord[getLanguage()] + " " + results.startTime;
        delete results.startTime;
      }
      if (results.endTime) {
        results.time += "&nbsp;" + results.endTime;
        delete results.endTime;
      }
      results.date = [startDate, endDate];
      return results;
    };
    formatSpecs = function(language, space) {
      var dayOfMonth, month, weekday;
      weekday = space === 'large' ? 'dddd' : getLanguage() === 'en-gb' ? 'ddd' : 'dd';
      month = space === 'large' ? getLanguage() === 'fi' ? 'MMMM[ta]' : 'MMMM' : getLanguage() === 'fi' ? 'Mo' : getLanguage() === 'sv' ? 'M[.]' : getLanguage() === 'en-gb' ? 'MMM' : 'M';
      dayOfMonth = getLanguage() === 'sv' ? 'D[.]' : getLanguage() === 'en-gb' ? 'D' : 'Do';
      return {
        time: 'LT',
        year: 'YYYY',
        weekday: weekday,
        month: month,
        dayOfMonth: dayOfMonth
      };
    };
    humanizeSingleDatetime = function(datetime) {
      return humanizeEventDatetime(datetime, null, 'small');
    };
    humanizeEventDatetime = function(start, end, space) {
      var diff, ev, hasEndTime, hasStartTime, now, result, sod, specs, _humanize;
      hasStartTime = start.length > 11;
      hasEndTime = hasStartTime && ((end != null ? end.length : void 0) > 11);
      start = moment(start);
      if (end != null) {
        end = moment(end);
      }
      now = moment();
      ev = [start, end];
      if (isMultiDayEvent(ev && !hasStartTime)) {
        hasEndTime = false;
      }
      specs = {};
      specs.includeFirstYear = isMultiYearEvent(ev);
      specs.includeLastYear = (!now.isSame(end, 'year')) || isMultiYearEvent(ev);
      specs.includeFirstMonth = isMultiMonthEvent(ev);
      if (space === 'large' && isMultiDayEvent(ev)) {
        specs.includeWeekday = true;
      }
      specs.includeStartTime = hasStartTime && ((space === 'large' && hasEndTime) || !isMultiDayEvent(ev));
      specs.includeEndTime = hasEndTime && space === 'large';
      if (!isMultiDayEvent(ev)) {
        specs.includeFirstMonth = true;
        sod = now.startOf('day');
        diff = start.diff(sod, 'days', true);
        _humanize = diff > -7 && diff <= 7;
        if (space === 'large') {
          specs.humanizeNotice = _humanize;
        } else {
          specs.humanize = _humanize;
        }
        if (!specs.humanize) {
          specs.includeWeekday = true;
        }
      }
      specs.format = formatSpecs(getLanguage(), space);
      result = formatEventDatetime(start, end, specs);
      return result;
    };
    return {
      humanizeEventDatetime: humanizeEventDatetime,
      humanizeSingleDatetime: humanizeSingleDatetime
    };
  });

}).call(this);

//

(function() {
  var __slice = [].slice;

  define(['backbone'], function(Backbone) {
    var EventDebugger, STATEFUL_EVENT, debugEvents, debugVariables, exports, log;
    debugVariables = ['units', 'services', 'selectedUnits', 'selectedEvents', 'searchResults', 'searchState'];
    debugEvents = ['all'];
    log = function(x) {
      return console.log(x);
    };
    STATEFUL_EVENT = (function() {
      function STATEFUL_EVENT() {}

      return STATEFUL_EVENT;

    })();
    EventDebugger = (function() {
      function EventDebugger(appControl) {
        this.appControl = appControl;
        _.extend(this, Backbone.Events);
        this.addListeners();
      }

      EventDebugger.prototype.addListeners = function() {
        var eventSpec, interceptor, variableName, _i, _len, _results;
        interceptor = function(variableName) {
          return function() {
            var data, eventName, i, param, rest, target, _i, _len;
            eventName = arguments[0], target = arguments[1], rest = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
            data = new STATEFUL_EVENT;
            data.variable = variableName;
            data.event = eventName;
            data.target = (target != null ? typeof target.toJSON === "function" ? target.toJSON() : void 0 : void 0) || target;
            for (i = _i = 0, _len = rest.length; _i < _len; i = ++_i) {
              param = rest[i];
              data["param_" + (i + 1)] = param;
            }
            return log(data);
          };
        };
        _results = [];
        for (_i = 0, _len = debugVariables.length; _i < _len; _i++) {
          variableName = debugVariables[_i];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = debugEvents.length; _j < _len1; _j++) {
              eventSpec = debugEvents[_j];
              _results1.push(this.listenTo(this.appControl[variableName], eventSpec, interceptor(variableName)));
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };

      return EventDebugger;

    })();
    return exports = {
      EventDebugger: EventDebugger,
      log: log
    };
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(function() {
    var Berry, CanvasDrawer, Plant, PointCluster, PointPlant, Stem, drawSimpleBerry, exports;
    CanvasDrawer = (function() {
      function CanvasDrawer() {}

      CanvasDrawer.prototype.referenceLength = 4500;

      CanvasDrawer.prototype.strokePath = function(c, callback) {
        c.beginPath();
        callback(c);
        c.stroke();
        return c.closePath();
      };

      CanvasDrawer.prototype.dim = function(part) {
        return this.ratio * this.defaults[part];
      };

      return CanvasDrawer;

    })();
    Stem = (function(_super) {
      __extends(Stem, _super);

      function Stem(size, rotation) {
        this.size = size;
        this.rotation = rotation;
        this.ratio = this.size / this.referenceLength;
      }

      Stem.prototype.defaults = {
        width: 250,
        base: 370,
        top: 2670,
        control: 1030
      };

      Stem.prototype.startingPoint = function() {
        return [this.size / 2, this.size];
      };

      Stem.prototype.berryCenter = function(rotation) {
        var x, y;
        rotation = Math.PI * rotation / 180;
        x = 0.8 * Math.cos(rotation) * this.dim('top') + (this.size / 2);
        y = -Math.sin(rotation) * this.dim('top') + this.size - this.dim('base');
        return [x, y];
      };

      Stem.prototype.setup = function(c) {
        c.lineJoin = 'round';
        c.strokeStyle = '#333';
        c.lineCap = 'round';
        return c.lineWidth = this.dim('width');
      };

      Stem.prototype.draw = function(c) {
        var point;
        this.setup(c);
        c.fillStyle = '#000';
        point = this.startingPoint();
        this.strokePath(c, (function(_this) {
          return function(c) {
            var controlPoint;
            c.moveTo.apply(c, point);
            point[1] -= _this.dim('base');
            c.lineTo.apply(c, point);
            controlPoint = point;
            controlPoint[1] -= _this.dim('control');
            point = _this.berryCenter(_this.rotation);
            return c.quadraticCurveTo.apply(c, __slice.call(controlPoint).concat(__slice.call(point)));
          };
        })(this));
        return point;
      };

      return Stem;

    })(CanvasDrawer);
    Berry = (function(_super) {
      __extends(Berry, _super);

      function Berry(size, point, color) {
        this.size = size;
        this.point = point;
        this.color = color;
        this.ratio = this.size / this.referenceLength;
      }

      Berry.prototype.draw = function(c) {
        var oldComposite;
        c.beginPath();
        c.fillStyle = this.color;
        c.arc.apply(c, __slice.call(this.point).concat([this.defaults.radius * this.ratio], [0], [2 * Math.PI]));
        c.fill();
        if (!(getIeVersion() && getIeVersion() < 9)) {
          c.strokeStyle = 'rgba(0,0,0,1.0)';
          oldComposite = c.globalCompositeOperation;
          c.globalCompositeOperation = "destination-out";
          c.lineWidth = 1.5;
          c.stroke();
          c.globalCompositeOperation = oldComposite;
        }
        c.closePath();
        c.beginPath();
        c.arc.apply(c, __slice.call(this.point).concat([this.defaults.radius * this.ratio - 1], [0], [2 * Math.PI]));
        c.strokeStyle = '#fcf7f5';
        c.lineWidth = 1;
        c.stroke();
        return c.closePath();
      };

      Berry.prototype.defaults = {
        radius: 1000,
        stroke: 125
      };

      return Berry;

    })(CanvasDrawer);
    Plant = (function(_super) {
      __extends(Plant, _super);

      function Plant(size, color, id, rotation, translation) {
        this.size = size;
        this.color = color;
        this.rotation = rotation != null ? rotation : 70 + (id % 40);
        this.translation = translation != null ? translation : [0, -3];
        this.stem = new Stem(this.size, this.rotation);
      }

      Plant.prototype.draw = function(context) {
        var berryPoint, _ref;
        this.context = context;
        this.context.save();
        (_ref = this.context).translate.apply(_ref, this.translation);
        berryPoint = this.stem.draw(this.context);
        this.berry = new Berry(this.size, berryPoint, this.color);
        this.berry.draw(this.context);
        return this.context.restore();
      };

      return Plant;

    })(CanvasDrawer);
    drawSimpleBerry = function(c, x, y, radius, color) {
      c.fillStyle = color;
      c.beginPath();
      c.arc(x, y, radius, 0, 2 * Math.PI);
      return c.fill();
    };
    PointCluster = (function(_super) {
      __extends(PointCluster, _super);

      function PointCluster(size, colors, positions, radius) {
        this.size = size;
        this.colors = colors;
        this.positions = positions;
        this.radius = radius;
        this.draw = __bind(this.draw, this);
      }

      PointCluster.prototype.draw = function(c) {
        return _.each(this.positions, (function(_this) {
          return function(pos) {
            return drawSimpleBerry.apply(null, [c].concat(__slice.call(pos), [_this.radius], ["#000"]));
          };
        })(this));
      };

      return PointCluster;

    })(CanvasDrawer);
    PointPlant = (function(_super) {
      __extends(PointPlant, _super);

      function PointPlant(size, color, radius) {
        this.size = size;
        this.color = color;
        this.radius = radius;
        this.draw = __bind(this.draw, this);
        true;
      }

      PointPlant.prototype.draw = function(c) {
        return drawSimpleBerry(c, 10, 10, this.radius, "#f00");
      };

      return PointPlant;

    })(CanvasDrawer);
    exports = {
      Plant: Plant,
      PointCluster: PointCluster,
      PointPlant: PointPlant
    };
    return exports;
  });

}).call(this);

//

(function() {
  var PAGE_SIZE, requirejsConfig,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  requirejsConfig = {
    baseUrl: appSettings.static_path + 'vendor',
    paths: {
      app: '../js'
    },
    shim: {
      bootstrap: {
        deps: ['jquery']
      },
      backbone: {
        deps: ['underscore', 'jquery'],
        exports: 'Backbone'
      },
      'leaflet.markercluster': {
        deps: ['leaflet']
      },
      'iexhr': {
        deps: ['jquery']
      }
    },
    config: {
      'app/p13n': {
        localStorageEnabled: false
      }
    }
  };

  requirejs.config(requirejsConfig);

  PAGE_SIZE = 1000;

  window.getIeVersion = function() {
    var isInternetExplorer, matches;
    isInternetExplorer = function() {
      return window.navigator.appName === "Microsoft Internet Explorer";
    };
    if (!isInternetExplorer()) {
      return false;
    }
    matches = new RegExp(" MSIE ([0-9]+)\\.([0-9])").exec(window.navigator.userAgent);
    return parseInt(matches[1]);
  };

  requirejs(['app/models', 'app/p13n', 'app/color', 'app/map-base-view', 'app/map', 'app/views/embedded-title', 'backbone', 'backbone.marionette', 'jquery', 'iexhr', 'i18next', 'URI', 'bootstrap', 'app/router', 'app/control', 'app/embedded-views', 'app/widgets'], function(models, p13n, ColorMatcher, BaseMapView, map, TitleView, Backbone, Marionette, $, iexhr, i18n, URI, Bootstrap, Router, BaseControl, TitleBarView, widgets) {
    var EmbeddedMapView, app, appState, fullUrl;
    app = new Backbone.Marionette.Application();
    window.app = app;
    fullUrl = function() {
      var currentUri;
      currentUri = URI(window.location.href);
      return currentUri.segment(0, "").toString();
    };
    EmbeddedMapView = (function(_super) {
      __extends(EmbeddedMapView, _super);

      function EmbeddedMapView() {
        return EmbeddedMapView.__super__.constructor.apply(this, arguments);
      }

      EmbeddedMapView.prototype.mapOptions = {
        dragging: true,
        touchZoom: true,
        scrollWheelZoom: false,
        doubleClickZoom: true,
        boxZoom: false
      };

      EmbeddedMapView.prototype.postInitialize = function() {
        var logo, zoom;
        EmbeddedMapView.__super__.postInitialize.call(this);
        zoom = L.control.zoom({
          position: 'bottomright',
          zoomInText: "<span class=\"icon-icon-zoom-in\"></span>",
          zoomOutText: "<span class=\"icon-icon-zoom-out\"></span>"
        });
        logo = new widgets.ControlWrapper(new TitleView({
          href: fullUrl()
        }), {
          position: 'bottomleft',
          autoZIndex: false
        });
        zoom.addTo(this.map);
        logo.addTo(this.map);
        this.allMarkers.on('click', (function(_this) {
          return function(l) {
            var root, _ref;
            root = URI(window.location.href).host();
            if (((_ref = l.layer) != null ? _ref.unit : void 0) != null) {
              return window.open(("http://" + root + "/unit/") + l.layer.unit.get('id'));
            } else {
              return window.open(fullUrl());
            }
          };
        })(this));
        return this.allMarkers.on('clusterclick', (function(_this) {
          return function() {
            return window.open(fullUrl());
          };
        })(this));
      };

      EmbeddedMapView.prototype.clusterPopup = function(event) {
        var childCount, cluster, html, popup;
        cluster = event.layer;
        childCount = cluster.getChildCount();
        popup = this.createPopup();
        html = "<div class='servicemap-prompt'>\n    " + (i18n.t('embed.click_prompt_move')) + "\n</div>";
        popup.setContent(html);
        popup.setLatLng(cluster.getBounds().getCenter());
        return popup;
      };

      EmbeddedMapView.prototype.createPopup = function(unit) {
        var htmlContent, popup;
        popup = L.popup({
          offset: L.point(0, 30),
          closeButton: false
        });
        if (unit != null) {
          htmlContent = "<div class='unit-name'>" + (unit.getText('name')) + "</div>\n<div class='servicemap-prompt'>" + (i18n.t('embed.click_prompt')) + "</div>";
          popup.setContent(htmlContent);
        }
        return popup;
      };

      EmbeddedMapView.prototype.getFeatureGroup = function() {
        return L.markerClusterGroup({
          showCoverageOnHover: false,
          maxClusterRadius: (function(_this) {
            return function(zoom) {
              if (zoom >= map.MapUtils.getZoomlevelToShowAllMarkers()) {
                return 4;
              } else {
                return 30;
              }
            };
          })(this),
          iconCreateFunction: (function(_this) {
            return function(cluster) {
              return _this.createClusterIcon(cluster);
            };
          })(this),
          zoomToBoundsOnClick: false
        });
      };

      EmbeddedMapView.prototype.handlePosition = function(positionObject) {
        var accuracy, latLng, marker, name, popup;
        accuracy = location.accuracy;
        latLng = map.MapUtils.latLngFromGeojson(positionObject);
        marker = map.MapUtils.createPositionMarker(latLng, accuracy, positionObject.origin(), {
          clickable: true
        });
        marker.position = positionObject;
        popup = L.popup({
          offset: L.point(0, 40),
          closeButton: false
        });
        name = positionObject.humanAddress();
        popup.setContent("<div class='unit-name'>" + name + "</div>");
        marker.bindPopup(popup);
        marker.addTo(this.map);
        this.map.adapt();
        marker.openPopup();
        return marker.on('click', (function(_this) {
          return function() {
            return window.open(fullUrl());
          };
        })(this));
      };

      return EmbeddedMapView;

    })(BaseMapView);
    appState = {
      divisions: new models.AdministrativeDivisionList,
      units: new models.UnitList(null, {
        pageSize: 500
      }),
      selectedUnits: new models.UnitList(),
      selectedPosition: new models.WrappedModel(),
      selectedDivision: new models.WrappedModel(),
      selectedServices: new models.ServiceList(),
      searchResults: new models.SearchList([], {
        pageSize: appSettings.page_size
      })
    };
    appState.services = appState.selectedServices;
    window.appState = appState;
    app.addInitializer(function(opts) {
      var baseRoot, control, currentUri, root, rootRegexp, router, url;
      this.colorMatcher = new ColorMatcher;
      control = new BaseControl(appState);
      router = new Router({
        controller: control,
        makeMapView: (function(_this) {
          return function(mapOptions) {
            var mapView;
            mapView = new EmbeddedMapView(appState, mapOptions, true);
            app.getRegion('map').show(mapView);
            return control.setMapProxy(mapView.getProxy());
          };
        })(this)
      });
      baseRoot = "" + appSettings.url_prefix + "embed";
      root = baseRoot + '/';
      if (!(window.history && history.pushState)) {
        rootRegexp = new RegExp(baseRoot + '\/?');
        url = window.location.href;
        url = url.replace(rootRegexp, '/');
        currentUri = URI(url);
        currentUri;
        router.routeEmbedded(currentUri);
      } else {
        Backbone.history.start({
          pushState: true,
          root: root
        });
      }
      return this.commands.setHandler('addUnitsWithinBoundingBoxes', (function(_this) {
        return function(bboxes) {
          return control.addUnitsWithinBoundingBoxes(bboxes);
        };
      })(this));
    });
    app.addRegions({
      navigation: '#navigation-region',
      map: '#app-container'
    });
    return $.when(p13n.deferred).done(function() {
      var $appContainer;
      app.start();
      $appContainer = $('#app-container');
      $appContainer.attr('class', p13n.get('map_background_layer'));
      return $appContainer.addClass('embed');
    });
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/models', 'app/spinner', 'app/embedded-views', 'backbone.marionette', 'jquery'], function(models, Spinner, TitleBarView, Marionette, $) {
    var PAGE_SIZE, Router, delayTime, spinner;
    PAGE_SIZE = 1000;
    delayTime = 1000;
    spinner = new Spinner({
      container: document.body
    });
    Router = (function(_super) {
      __extends(Router, _super);

      function Router() {
        return Router.__super__.constructor.apply(this, arguments);
      }

      Router.prototype.execute = function(callback, args) {
        var model;
        _.delay(this.indicateLoading, delayTime);
        model = callback.apply(this, args);
        this.listenTo(model, 'sync', this.removeLoadingIndicator);
        return this.listenTo(model, 'finished', this.removeLoadingIndicator);
      };

      Router.prototype._parseParameters = function(params) {
        var parsedParams;
        parsedParams = {};
        _(params.split('&')).each((function(_this) {
          return function(query) {
            var k, v, _ref;
            _ref = query.split('=', 2), k = _ref[0], v = _ref[1];
            if (v.match(/,/)) {
              v = v.split(',');
            } else {
              v = [v];
            }
            return parsedParams[k] = v;
          };
        })(this));
        parsedParams;
        if (_(params).has('titlebar')) {
          return app.getRegion('navigation').show(new TitleBarView(this.appState.divisions));
        }
      };

      Router.prototype.indicateLoading = function() {
        return spinner.start();
      };

      Router.prototype.removeLoadingIndicator = function() {
        return spinner != null ? spinner.stop() : void 0;
      };

      return Router;

    })(Marionette.AppRouter);
    return Router;
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['app/views/base', 'backbone'], function(baseviews, Backbone) {
    var EmbeddedMap, TitleBarView;
    EmbeddedMap = (function(_super) {
      __extends(EmbeddedMap, _super);

      function EmbeddedMap() {
        return EmbeddedMap.__super__.constructor.apply(this, arguments);
      }

      EmbeddedMap.prototype.initialize = function(options) {
        this.mapView = options.mapView;
        this.listenTo(app.vent, 'unit:render-one', this.renderUnit);
        this.listenTo(app.vent, 'units:render-with-filter', this.renderUnitsWithFilter);
        return this.listenTo(app.vent, 'units:render-category', this.renderUnitsByCategory);
      };

      EmbeddedMap.prototype.renderUnitsByCategory = function(isSelected) {
        var onlyCategories, privateCategories, privateUnits, publicCategories, publicUnits, unitsInCategory;
        publicCategories = [100, 101, 102, 103, 104];
        privateCategories = [105];
        onlyCategories = function(categoriesArray) {
          return function(model) {
            return _.contains(categoriesArray, model.get('provider_type'));
          };
        };
        publicUnits = this.unitList.filter(onlyCategories(publicCategories));
        privateUnits = this.unitList.filter(onlyCategories(privateCategories));
        unitsInCategory = [];
        if (!isSelected["public"]) {
          _.extend(unitsInCategory, publicUnits);
        }
        if (!isSelected["private"]) {
          _.extend(unitsInCategory, privateUnits);
        }
        return this.mapView.drawUnits(new models.UnitList(unitsInCategory));
      };

      EmbeddedMap.prototype.fetchAdministrativeDivisions = function(params, callback) {
        var divisions;
        divisions = new models.AdministrativeDivisionList();
        return divisions.fetch({
          data: {
            ocd_id: params
          },
          success: callback
        });
      };

      EmbeddedMap.prototype.findUniqueAdministrativeDivisions = function(collection) {
        var byName, divisionNames, divisionNamesPartials;
        byName = function(divisionModel) {
          return divisionModel.toJSON().name;
        };
        divisionNames = collection.chain().map(byName).compact().unique().value();
        divisionNamesPartials = {};
        if (divisionNames.length > 1) {
          divisionNamesPartials.start = _.initial(divisionNames).join(', ');
          divisionNamesPartials.end = _.last(divisionNames);
        } else {
          divisionNamesPartials.start = divisionNames[0];
        }
        return app.vent.trigger('administration-divisions-fetched', divisionNamesPartials);
      };

      return EmbeddedMap;

    })(Backbone.View);
    TitleBarView = (function(_super) {
      __extends(TitleBarView, _super);

      function TitleBarView() {
        this.divisionNames = __bind(this.divisionNames, this);
        return TitleBarView.__super__.constructor.apply(this, arguments);
      }

      TitleBarView.prototype.template = 'embedded-title-bar';

      TitleBarView.prototype.className = 'panel panel-default';

      TitleBarView.prototype.events = {
        'click a': 'preventDefault',
        'click .show-button': 'toggleShow',
        'click .panel-heading': 'collapseCategoryMenu'
      };

      TitleBarView.prototype.initialize = function(model) {
        this.model = model;
        return this.listenTo(this.model, 'sync', this.render);
      };

      TitleBarView.prototype.divisionNames = function(divisions) {
        return divisions.pluck('name');
      };

      TitleBarView.prototype.serializeData = function() {
        return {
          divisions: this.divisionNames(this.model)
        };
      };

      TitleBarView.prototype.show = function() {
        this.delegateEvents;
        return this.$el.removeClass('hide');
      };

      TitleBarView.prototype.hide = function() {
        this.undelegateEvents();
        return this.$el.addClass('hide');
      };

      TitleBarView.prototype.preventDefault = function(ev) {
        return ev.preventDefault();
      };

      TitleBarView.prototype.toggleShow = function(ev) {
        var isSelected, privateToggle, publicToggle, target;
        publicToggle = this.$('.public');
        privateToggle = this.$('.private');
        target = $(ev.target);
        target.toggleClass('selected');
        isSelected = {
          "public": publicToggle.hasClass('selected'),
          "private": privateToggle.hasClass('selected')
        };
        return app.vent.trigger('units:render-category', isSelected);
      };

      TitleBarView.prototype.collapseCategoryMenu = function() {
        return $('.panel-heading').toggleClass('open');
      };

      return TitleBarView;

    })(baseviews.SMItemView);
    return TitleBarView;
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['app/base', 'app/p13n', 'app/settings', 'app/jade', 'app/models', 'typeahead.bundle', 'backbone'], function(sm, p13n, settings, jade, models, _typeahead, Backbone) {
    var GeocoderSourceBackend, monkeyPatchTypeahead;
    monkeyPatchTypeahead = (function(_this) {
      return function($element) {
        var originalSelect, proto, typeahead;
        typeahead = $element.data('ttTypeahead');
        proto = Object.getPrototypeOf(typeahead);
        originalSelect = proto._select;
        proto._select = function(datum) {
          this.input.setQuery(datum.value);
          this.input.setInputValue(datum.value, true);
          this._setLanguageDirection();
          return this.eventBus.trigger('selected', datum.raw, datum.datasetName);
        };
        return proto.closeCompletely = function() {
          this.close();
          return _.defer(_.bind(this.dropdown.empty, this.dropdown));
        };
      };
    })(this);
    return {
      GeocoderSourceBackend: GeocoderSourceBackend = (function() {
        function GeocoderSourceBackend(options) {
          var geocoderStreetEngine;
          this.options = options;
          this.getDatasetOptions = __bind(this.getDatasetOptions, this);
          this.getSource = __bind(this.getSource, this);
          this.addressSource = __bind(this.addressSource, this);
          this.setStreet = __bind(this.setStreet, this);
          _.extend(this, Backbone.Events);
          this.street = void 0;
          geocoderStreetEngine = this._createGeocoderStreetEngine(p13n.getLanguage());
          this.geocoderStreetSource = geocoderStreetEngine.ttAdapter();
        }

        GeocoderSourceBackend.prototype.setOptions = function(options) {
          this.options = options;
          this.options.$inputEl.on('typeahead:selected', _.bind(this.typeaheadSelected, this));
          this.options.$inputEl.on('typeahead:autocompleted', _.bind(this.typeaheadSelected, this));
          return monkeyPatchTypeahead(this.options.$inputEl);
        };

        GeocoderSourceBackend.prototype._createGeocoderStreetEngine = function(lang) {
          var e;
          e = new Bloodhound({
            name: 'street_suggestions',
            remote: {
              url: appSettings.service_map_backend + "/street/?page_size=4",
              replace: (function(_this) {
                return function(url, query) {
                  url += "&input=" + query;
                  url += "&language=" + (lang !== 'sv' ? 'fi' : lang);
                  return url;
                };
              })(this),
              ajax: settings.applyAjaxDefaults({}),
              filter: (function(_this) {
                return function(parsedResponse) {
                  var results;
                  results = new models.StreetList(parsedResponse.results);
                  if (results.length === 1) {
                    _this.setStreet(results.first());
                  }
                  return results.toArray();
                };
              })(this),
              rateLimitWait: 50
            },
            datumTokenizer: function(datum) {
              return Bloodhound.tokenizers.whitespace(datum.name[lang]);
            },
            queryTokenizer: (function(_this) {
              return function(s) {
                var res;
                return res = [s];
              };
            })(this)
          });
          e.initialize();
          return e;
        };

        GeocoderSourceBackend.prototype.typeaheadSelected = function(ev, data) {
          var objectType;
          objectType = data.object_type;
          if (objectType === 'address') {
            if (data instanceof models.Position) {
              this.options.$inputEl.typeahead('close');
              return this.options.selectionCallback(ev, data);
            } else {
              return this.setStreet(data).done((function(_this) {
                return function() {
                  _this.options.$inputEl.val(_this.options.$inputEl.val() + ' ');
                  return _this.options.$inputEl.trigger('input');
                };
              })(this));
            }
          } else {
            return this.setStreet(null);
          }
        };

        GeocoderSourceBackend.prototype.streetSelected = function() {
          if (this.street == null) {
            return;
          }
          return _.defer((function(_this) {
            return function() {
              var streetName;
              streetName = p13n.getTranslatedAttr(_this.street.name);
              _this.options.$inputEl.typeahead('val', '');
              _this.options.$inputEl.typeahead('val', streetName + ' ');
              return _this.options.$inputEl.trigger('input');
            };
          })(this));
        };

        GeocoderSourceBackend.prototype.setStreet = function(street) {
          return sm.withDeferred((function(_this) {
            return function(deferred) {
              var _ref;
              if (street == null) {
                _this.street = void 0;
                deferred.resolve();
                return;
              }
              if (street.get('id') === ((_ref = _this.street) != null ? _ref.get('id') : void 0)) {
                deferred.resolve();
                return;
              }
              _this.street = street;
              _this.street.translatedName = (_this.street.get('name')[p13n.getLanguage()] || _this.street.get('name').fi).toLowerCase();
              _this.street.addresses = new models.AddressList([], {
                pageSize: 200
              });
              _this.street.addresses.comparator = function(x) {
                return parseInt(x.get('number'));
              };
              _this.street.addressesFetched = false;
              return _this.street.addresses.fetch({
                data: {
                  street: _this.street.get('id')
                },
                success: function() {
                  var _ref1;
                  if ((_ref1 = _this.street) != null) {
                    _ref1.addressesFetched = true;
                  }
                  return deferred.resolve();
                }
              });
            };
          })(this));
        };

        GeocoderSourceBackend.prototype.addressSource = function(query, callback) {
          var done, matches, numberPart, q, re;
          re = new RegExp("^\\s*" + this.street.translatedName + "(\\s+\\d.*)?", 'i');
          matches = query.match(re);
          if (matches != null) {
            q = matches[0], numberPart = matches[1];
            if (numberPart == null) {
              numberPart = '';
            }
            numberPart = numberPart.replace(/\s+/g, '').replace(/[^0-9]+/g, '');
            done = (function(_this) {
              return function() {
                var filtered, last, results;
                if (_this.street == null) {
                  callback([]);
                  return;
                }
                if (_this.street.addresses.length === 1) {
                  callback(_this.street.addresses.toArray());
                  return;
                }
                filtered = _this.street.addresses.filter(function(a) {
                  return a.humanNumber().indexOf(numberPart) === 0;
                });
                results = filtered.slice(0, 2);
                last = _(filtered).last();
                if (__indexOf.call(results, last) < 0) {
                  if (last != null) {
                    results.push(last);
                  }
                }
                return callback(results);
              };
            })(this);
            if (this.street.addressesFetched) {
              return done();
            } else {
              return this.listenToOnce(this.street.addresses, 'sync', (function(_this) {
                return function() {
                  return done();
                };
              })(this));
            }
          }
        };

        GeocoderSourceBackend.prototype.getSource = function() {
          return (function(_this) {
            return function(query, cb) {
              if ((_this.street != null) && _this.street.translatedName.length <= query.length) {
                return _this.addressSource(query, cb);
              } else {
                return _this.geocoderStreetSource(query, cb);
              }
            };
          })(this);
        };

        GeocoderSourceBackend.prototype.getDatasetOptions = function() {
          return {
            name: 'address',
            displayKey: function(c) {
              return c.humanAddress();
            },
            source: this.getSource(),
            templates: {
              suggestion: (function(_this) {
                return function(c) {
                  if (c instanceof models.Position) {
                    c.set('street', _this.street);
                  }
                  c.address = c.humanAddress();
                  c.object_type = 'address';
                  return jade.template('typeahead-suggestion', c);
                };
              })(this)
            }
          };
        };

        return GeocoderSourceBackend;

      })()
    };
  });

}).call(this);

//

(function() {
  define(['underscore', 'jquery', 'i18next', 'app/p13n', 'app/dateformat'], function(_, $, i18n, p13n, dateformat) {
    var Jade, setHelper;
    if (typeof jade !== 'object') {
      throw new Error("Jade not loaded before app");
    }
    setHelper = function(data, name, helper) {
      if (name in data) {
        return;
      }
      return data[name] = helper;
    };
    Jade = (function() {
      function Jade() {}

      Jade.prototype.getTemplate = function(name) {
        var key, templateFunc;
        key = "views/templates/" + name;
        if (!(key in JST)) {
          throw new Error("template '" + name + "' not loaded");
        }
        templateFunc = JST[key];
        return templateFunc;
      };

      Jade.prototype.tAttr = function(attr) {
        return p13n.getTranslatedAttr(attr);
      };

      Jade.prototype.tAttrHasLang = function(attr) {
        if (!attr) {
          return false;
        }
        return p13n.getLanguage() in attr;
      };

      Jade.prototype.phoneI18n = function(num) {
        if (num.indexOf('0' === 0)) {
          num = '+358' + num.substring(1);
        }
        num = num.replace(/\s/g, '');
        num = num.replace(/-/g, '');
        return num;
      };

      Jade.prototype.staticPath = function(path) {
        if (path.indexOf('/') === 0) {
          path = path.substring(1);
        }
        return appSettings.static_path + path;
      };

      Jade.prototype.humanDateRange = function(startTime, endTime) {
        var formatted, hasEndTime;
        formatted = dateformat.humanizeEventDatetime(startTime, endTime, 'small', hasEndTime = false);
        return formatted.date;
      };

      Jade.prototype.humanDistance = function(meters) {
        var a, b, val, _ref;
        if (meters === Number.MAX_VALUE) {
          return "?";
        } else if (meters < 1000) {
          return "" + (Math.ceil(meters)) + "m";
        } else {
          val = Math.ceil(meters / 100).toString();
          _ref = [val.slice(0, -1), val.slice(-1)], a = _ref[0], b = _ref[1];
          if (b !== "0") {
            return "" + a + "." + b + "km";
          } else {
            return "" + a + "km";
          }
        }
      };

      Jade.prototype.humanShortcomings = function(count) {
        if (count === Number.MAX_VALUE) {
          return i18n.t('accessibility.no_data');
        } else if (count === 0) {
          return i18n.t('accessibility.no_shortcomings');
        } else {
          return i18n.t('accessibility.shortcoming_count', {
            count: count
          });
        }
      };

      Jade.prototype.humanDate = function(datetime) {
        var res;
        return res = dateformat.humanizeSingleDatetime(datetime);
      };

      Jade.prototype.uppercaseFirst = function(val) {
        return val.charAt(0).toUpperCase() + val.slice(1);
      };

      Jade.prototype.mixinHelpers = function(data) {
        setHelper(data, 't', i18n.t);
        setHelper(data, 'tAttr', this.tAttr);
        setHelper(data, 'tAttrHasLang', this.tAttrHasLang);
        setHelper(data, 'phoneI18n', this.phoneI18n);
        setHelper(data, 'staticPath', this.staticPath);
        setHelper(data, 'humanDateRange', this.humanDateRange);
        setHelper(data, 'humanDate', this.humanDate);
        setHelper(data, 'humanDistance', this.humanDistance);
        setHelper(data, 'uppercaseFirst', this.uppercaseFirst);
        setHelper(data, 'humanShortcomings', this.humanShortcomings);
        setHelper(data, 'pad', (function(_this) {
          return function(s) {
            return " " + s + " ";
          };
        })(this));
        return data;
      };

      Jade.prototype.template = function(name, locals) {
        var data, func, templateStr;
        if (locals != null) {
          if (typeof locals !== 'object') {
            throw new Error("template must get an object argument");
          }
        } else {
          locals = {};
        }
        func = this.getTemplate(name);
        data = _.clone(locals);
        this.mixinHelpers(data);
        templateStr = func(data);
        return $.trim(templateStr);
      };

      return Jade;

    })();
    return new Jade;
  });

}).call(this);

//

(function() {
  define(function() {
    var clearLandingPage;
    clearLandingPage = function() {
      if ($('body').hasClass('landing')) {
        $('body').removeClass('landing');
        return $('#navigation-region').one('transitionend webkitTransitionEnd otransitionend oTransitionEnd MSTransitionEnd', function(event) {
          app.vent.trigger('landing-page-cleared');
          return $(this).off('transitionend webkitTransitionEnd oTransitionEnd MSTransitnd');
        });
      }
    };
    return {
      clear: clearLandingPage
    };
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['backbone', 'backbone.marionette', 'i18next', 'leaflet', 'leaflet.markercluster', 'leaflet.snogylop', 'app/map', 'app/widgets', 'app/jade', 'app/map-state-model'], function(Backbone, Marionette, i18n, leaflet, markercluster, leaflet_snogylop, map, widgets, jade, MapStateModel) {
    var DEFAULT_CENTER, ICON_SIZE, MARKER_POINT_VARIANT, MapBaseView;
    MARKER_POINT_VARIANT = false;
    DEFAULT_CENTER = {
      helsinki: [60.171944, 24.941389],
      espoo: [60.19792, 24.708885],
      vantaa: [60.309045, 25.004675],
      kauniainen: [60.21174, 24.729595]
    };
    ICON_SIZE = 40;
    if (getIeVersion() && getIeVersion() < 9) {
      ICON_SIZE *= .8;
    }
    MapBaseView = (function(_super) {
      __extends(MapBaseView, _super);

      function MapBaseView() {
        this.drawInitialState = __bind(this.drawInitialState, this);
        this.fitBbox = __bind(this.fitBbox, this);
        return MapBaseView.__super__.constructor.apply(this, arguments);
      }

      MapBaseView.prototype.initialize = function(opts, mapOpts, embedded) {
        this.opts = opts;
        this.mapOpts = mapOpts;
        this.embedded = embedded;
        this.markers = {};
        this.units = this.opts.units;
        this.selectedUnits = this.opts.selectedUnits;
        this.selectedPosition = this.opts.selectedPosition;
        this.divisions = this.opts.divisions;
        this.listenTo(this.units, 'reset', this.drawUnits);
        return this.listenTo(this.units, 'finished', (function(_this) {
          return function(options) {
            _this.drawUnits(_this.units, options);
            if (_this.selectedUnits.isSet()) {
              return _this.highlightSelectedUnit(_this.selectedUnits.first());
            }
          };
        })(this));
      };

      MapBaseView.prototype.getProxy = function() {
        var fn;
        fn = (function(_this) {
          return function() {
            return map.MapUtils.overlappingBoundingBoxes(_this.map);
          };
        })(this);
        return {
          getTransformedBounds: fn
        };
      };

      MapBaseView.prototype.mapOptions = {};

      MapBaseView.prototype.render = function() {
        return this.$el.attr('id', 'map');
      };

      MapBaseView.prototype.getMapStateModel = function() {
        return new MapStateModel(this.opts, this.embedded);
      };

      MapBaseView.prototype.onShow = function() {
        var mapStyle, options;
        mapStyle = p13n.get('map_background_layer');
        options = {
          style: mapStyle,
          language: p13n.getLanguage()
        };
        this.map = map.MapMaker.createMap(this.$el.get(0), options, this.mapOptions, this.getMapStateModel());
        this.map.on('click', _.bind(this.onMapClicked, this));
        this.allMarkers = this.getFeatureGroup();
        this.allMarkers.addTo(this.map);
        this.divisionLayer = L.featureGroup();
        this.divisionLayer.addTo(this.map);
        return this.postInitialize();
      };

      MapBaseView.prototype.onMapClicked = function(ev) {};

      MapBaseView.prototype.calculateInitialOptions = function() {
        var boundaries, bounds, center, city, iteratee;
        if (this.selectedPosition.isSet()) {
          return {
            zoom: map.MapUtils.getZoomlevelToShowAllMarkers(),
            center: map.MapUtils.latLngFromGeojson(this.selectedPosition.value())
          };
        } else if (this.selectedUnits.isSet()) {
          return {
            zoom: this.getMaxAutoZoom(),
            center: map.MapUtils.latLngFromGeojson(this.selectedUnits.first())
          };
        } else if (this.divisions.isSet()) {
          boundaries = this.divisions.map((function(_this) {
            return function(d) {
              return new L.GeoJSON(d.get('boundary'));
            };
          })(this));
          iteratee = (function(_this) {
            return function(memo, value) {
              return memo.extend(value.getBounds());
            };
          })(this);
          bounds = _.reduce(boundaries, iteratee, L.latLngBounds([]));
          return {
            bounds: bounds
          };
        } else {
          city = p13n.get('city');
          if (city == null) {
            city = 'helsinki';
          }
          center = DEFAULT_CENTER[city];
          return {
            zoom: p13n.get('map_background_layer') === 'servicemap' ? 10 : 5,
            center: center
          };
        }
      };

      MapBaseView.prototype.postInitialize = function() {
        this._addMouseoverListeners(this.allMarkers);
        this.popups = L.layerGroup();
        this.popups.addTo(this.map);
        this.setInitialView();
        return this.drawInitialState();
      };

      MapBaseView.prototype.fitBbox = function(bbox) {
        var bounds, ne, sw;
        sw = L.latLng(bbox.slice(0, 2));
        ne = L.latLng(bbox.slice(2, 4));
        bounds = L.latLngBounds(sw, ne);
        return this.map.fitBounds(bounds);
      };

      MapBaseView.prototype.getMaxAutoZoom = function() {
        var layer;
        layer = p13n.get('map_background_layer');
        if (layer === 'guidemap') {
          return 7;
        } else if (layer === 'ortographic') {
          return 9;
        } else {
          return 12;
        }
      };

      MapBaseView.prototype.setInitialView = function() {
        var opts, _ref;
        if (((_ref = this.mapOpts) != null ? _ref.bbox : void 0) != null) {
          return this.fitBbox(this.mapOpts.bbox);
        } else {
          opts = this.calculateInitialOptions();
          if (opts.bounds != null) {
            return this.map.fitBounds(opts.bounds);
          } else {
            return this.map.setView(opts.center, opts.zoom);
          }
        }
      };

      MapBaseView.prototype.drawInitialState = function() {
        if (this.selectedPosition.isSet()) {
          return this.handlePosition(this.selectedPosition.value(), {
            center: false,
            skipRefit: true,
            initial: true
          });
        } else if (this.selectedUnits.isSet()) {
          return this.drawUnits(this.units, {
            noRefit: true
          });
        } else {
          if (this.units.isSet()) {
            this.drawUnits(this.units);
          }
          if (this.divisions.isSet()) {
            this.divisionLayer.clearLayers();
            return this.drawDivisions(this.divisions);
          }
        }
      };

      MapBaseView.prototype.drawUnits = function(units, options) {
        var latLngs, markers, unitsWithLocation, _ref;
        this.allMarkers.clearLayers();
        if (((_ref = units.filters) != null ? _ref.bbox : void 0) != null) {
          if (this._skipBboxDrawing) {
            return;
          }
        }
        unitsWithLocation = units.filter((function(_this) {
          return function(unit) {
            return unit.get('location') != null;
          };
        })(this));
        markers = unitsWithLocation.map((function(_this) {
          return function(unit) {
            return _this.createMarker(unit, options != null ? options.marker : void 0);
          };
        })(this));
        latLngs = _(markers).map((function(_this) {
          return function(m) {
            return m.getLatLng();
          };
        })(this));
        if (!(options != null ? options.keepViewport : void 0)) {
          if (typeof this.preAdapt === "function") {
            this.preAdapt();
          }
          this.map.adaptToLatLngs(latLngs);
        }
        return this.allMarkers.addLayers(markers);
      };

      MapBaseView.prototype._combineMultiPolygons = function(multiPolygons) {
        return multiPolygons.map((function(_this) {
          return function(mp) {
            return mp.coordinates[0];
          };
        })(this));
      };

      MapBaseView.prototype.drawDivisionGeometry = function(geojson) {
        var mp;
        mp = L.GeoJSON.geometryToLayer(geojson, null, null, {
          invert: true,
          color: '#ff8400',
          weight: 3,
          strokeOpacity: 1,
          fillColor: '#000',
          fillOpacity: 0.2
        });
        this.map.adapt();
        return mp.addTo(this.divisionLayer);
      };

      MapBaseView.prototype.drawDivisions = function(divisions) {
        var geojson;
        geojson = {
          coordinates: this._combineMultiPolygons(divisions.pluck('boundary')),
          type: 'MultiPolygon'
        };
        return this.drawDivisionGeometry(geojson);
      };

      MapBaseView.prototype.drawDivision = function(division) {
        if (division == null) {
          return;
        }
        return this.drawDivisionGeometry(division.get('boundary'));
      };

      MapBaseView.prototype.highlightUnselectedUnit = function(unit) {
        var marker, popup;
        marker = unit.marker;
        popup = marker != null ? marker.popup : void 0;
        if (popup != null ? popup.selected : void 0) {
          return;
        }
        this._clearOtherPopups(popup, {
          clearSelected: true
        });
        if (popup != null) {
          $(marker.popup._wrapper).removeClass('selected');
          popup.setLatLng(marker != null ? marker.getLatLng() : void 0);
          return this.popups.addLayer(popup);
        }
      };

      MapBaseView.prototype.clusterPopup = function(event) {
        var COUNT_LIMIT, childCount, cluster, data, names, overflowCount, popup, popuphtml;
        cluster = event.layer;
        COUNT_LIMIT = 3;
        childCount = cluster.getChildCount();
        names = _.map(cluster.getAllChildMarkers(), function(marker) {
          return p13n.getTranslatedAttr(marker.unit.get('name'));
        }).sort();
        data = {};
        overflowCount = childCount - COUNT_LIMIT;
        if (overflowCount > 1) {
          names = names.slice(0, COUNT_LIMIT);
          data.overflow_message = i18n.t('general.more_units', {
            count: overflowCount
          });
        }
        data.names = names;
        popuphtml = jade.getTemplate('popup_cluster')(data);
        popup = this.createPopup();
        popup.setLatLng(cluster.getBounds().getCenter());
        popup.setContent(popuphtml);
        cluster.popup = popup;
        this.map.on('zoomstart', (function(_this) {
          return function() {
            return _this.popups.removeLayer(popup);
          };
        })(this));
        return popup;
      };

      MapBaseView.prototype._addMouseoverListeners = function(markerClusterGroup) {
        this.bindDelayedPopup(markerClusterGroup, null, {
          showEvent: 'clustermouseover',
          hideEvent: 'clustermouseout',
          popupCreateFunction: _.bind(this.clusterPopup, this)
        });
        markerClusterGroup.on('spiderfied', (function(_this) {
          return function(e) {
            var icon, _ref;
            icon = $((_ref = e.target._spiderfied) != null ? _ref._icon : void 0);
            return icon != null ? icon.fadeTo('fast', 0) : void 0;
          };
        })(this));
        this._lastOpenedClusterIcon = null;
        return markerClusterGroup.on('spiderfied', (function(_this) {
          return function(e) {
            var icon;
            if (_this._lastOpenedClusterIcon) {
              L.DomUtil.removeClass(_this._lastOpenedClusterIcon, 'hidden');
            }
            icon = e.target._spiderfied._icon;
            L.DomUtil.addClass(icon, 'hidden');
            return _this._lastOpenedClusterIcon = icon;
          };
        })(this));
      };

      MapBaseView.prototype.getZoomlevelToShowAllMarkers = function() {
        var layer;
        layer = p13n.get('map_background_layer');
        if (layer === 'guidemap') {
          return 8;
        } else if (layer === 'ortographic') {
          return 8;
        } else {
          return 14;
        }
      };

      MapBaseView.prototype.getServices = function() {
        return null;
      };

      MapBaseView.prototype.createClusterIcon = function(cluster) {
        var colors, count, ctor, iconOpts, markers, serviceId, serviceIds, services;
        count = cluster.getChildCount();
        serviceIds = {};
        serviceId = null;
        markers = cluster.getAllChildMarkers();
        services = this.getServices();
        _.each(markers, (function(_this) {
          return function(marker) {
            var root, service;
            if (marker.unit == null) {
              return;
            }
            if (marker.popup != null) {
              cluster.on('remove', function(event) {
                return _this.popups.removeLayer(marker.popup);
              });
            }
            if (!services || services.isEmpty()) {
              root = marker.unit.get('root_services')[0];
            } else {
              service = services.find(function(s) {
                var _ref;
                return _ref = s.get('root'), __indexOf.call(marker.unit.get('root_services'), _ref) >= 0;
              });
              root = (service != null ? service.get('root') : void 0) || 50000;
            }
            return serviceIds[root] = true;
          };
        })(this));
        cluster.on('remove', (function(_this) {
          return function(event) {
            if (cluster.popup != null) {
              return _this.popups.removeLayer(cluster.popup);
            }
          };
        })(this));
        colors = _(serviceIds).map((function(_this) {
          return function(val, id) {
            return app.colorMatcher.serviceRootIdColor(id);
          };
        })(this));
        if (MARKER_POINT_VARIANT) {
          ctor = widgets.PointCanvasClusterIcon;
        } else {
          ctor = widgets.CanvasClusterIcon;
        }
        iconOpts = {};
        if (_(markers).find((function(_this) {
          return function(m) {
            var _ref, _ref1;
            return m != null ? (_ref = m.unit) != null ? (_ref1 = _ref.collection) != null ? _ref1.hasReducedPriority() : void 0 : void 0 : void 0;
          };
        })(this)) != null) {
          iconOpts.reducedProminence = true;
        }
        return new ctor(count, ICON_SIZE, colors, null, iconOpts);
      };

      MapBaseView.prototype.getFeatureGroup = function() {
        return L.markerClusterGroup({
          showCoverageOnHover: false,
          maxClusterRadius: (function(_this) {
            return function(zoom) {
              if (zoom >= map.MapUtils.getZoomlevelToShowAllMarkers()) {
                return 4;
              } else {
                return 30;
              }
            };
          })(this),
          iconCreateFunction: (function(_this) {
            return function(cluster) {
              return _this.createClusterIcon(cluster);
            };
          })(this),
          zoomToBoundsOnClick: true
        });
      };

      MapBaseView.prototype.createMarker = function(unit, markerOptions) {
        var icon, id, marker, popup, _ref;
        id = unit.get('id');
        if (id in this.markers) {
          marker = this.markers[id];
          marker.unit = unit;
          unit.marker = marker;
          return marker;
        }
        icon = this.createIcon(unit, this.selectedServices);
        marker = widgets.createMarker(map.MapUtils.latLngFromGeojson(unit), {
          reducedProminence: (_ref = unit.collection) != null ? _ref.hasReducedPriority() : void 0,
          icon: icon,
          zIndexOffset: 100
        });
        marker.unit = unit;
        unit.marker = marker;
        if (this.selectMarker != null) {
          this.listenTo(marker, 'click', this.selectMarker);
        }
        marker.on('remove', (function(_this) {
          return function(event) {
            marker = event.target;
            if (marker.popup != null) {
              return _this.popups.removeLayer(marker.popup);
            }
          };
        })(this));
        popup = this.createPopup(unit);
        popup.setLatLng(marker.getLatLng());
        this.bindDelayedPopup(marker, popup);
        return this.markers[id] = marker;
      };

      MapBaseView.prototype._clearOtherPopups = function(popup, opts) {
        return this.popups.eachLayer((function(_this) {
          return function(layer) {
            if (layer === popup) {
              return;
            }
            if ((opts != null ? opts.clearSelected : void 0) || !layer.selected) {
              return _this.popups.removeLayer(layer);
            }
          };
        })(this));
      };

      MapBaseView.prototype.bindDelayedPopup = function(marker, popup, opts) {
        var createdPopup, delay, hideEvent, popupOff, popupOn, prevent, showEvent;
        showEvent = (opts != null ? opts.showEvent : void 0) || 'mouseover';
        hideEvent = (opts != null ? opts.hideEvent : void 0) || 'mouseout';
        delay = (opts != null ? opts.delay : void 0) || 600;
        if (marker && popup) {
          marker.popup = popup;
          popup.marker = marker;
        }
        prevent = false;
        createdPopup = null;
        popupOn = (function(_this) {
          return function(event) {
            var _popup;
            if (!prevent) {
              if ((opts != null ? opts.popupCreateFunction : void 0) != null) {
                _popup = opts.popupCreateFunction(event);
                createdPopup = _popup;
              } else {
                _popup = popup;
              }
              _this._clearOtherPopups(_popup, {
                clearSelected: false
              });
              _this.popups.addLayer(_popup);
            }
            return prevent = false;
          };
        })(this);
        popupOff = (function(_this) {
          return function(event) {
            var _popup, _ref;
            if (opts != null ? opts.popupCreateFunction : void 0) {
              _popup = createdPopup;
            } else {
              _popup = popup;
            }
            if (_popup != null) {
              if ((_this.selectedUnits != null) && ((_ref = _popup.marker) != null ? _ref.unit : void 0) === _this.selectedUnits.first()) {
                prevent = true;
              } else {
                _this.popups.removeLayer(_popup);
              }
            }
            return _.delay((function() {
              return prevent = false;
            }), delay);
          };
        })(this);
        marker.on(hideEvent, popupOff);
        return marker.on(showEvent, _.debounce(popupOn, delay));
      };

      MapBaseView.prototype.createPopup = function(unit, opts, offset) {
        var htmlContent, popup;
        popup = this.createPopupWidget(opts, offset);
        if (unit != null) {
          htmlContent = "<div class='unit-name'>" + (unit.getText('name')) + "</div>";
          popup.setContent(htmlContent);
        }
        return popup;
      };

      MapBaseView.prototype.createPopupWidget = function(opts, offset) {
        var defaults;
        defaults = {
          closeButton: false,
          autoPan: false,
          zoomAnimation: false,
          className: 'unit',
          maxWidth: 500,
          minWidth: 150
        };
        if (opts != null) {
          opts = _.defaults(opts, defaults);
        } else {
          opts = defaults;
        }
        if (offset != null) {
          opts.offset = offset;
        }
        return new widgets.LeftAlignedPopup(opts);
      };

      MapBaseView.prototype.createIcon = function(unit, services) {
        var color, ctor, icon, iconOptions, _ref;
        color = app.colorMatcher.unitColor(unit) || 'rgb(255, 255, 255)';
        if (MARKER_POINT_VARIANT) {
          ctor = widgets.PointCanvasIcon;
        } else {
          ctor = widgets.PlantCanvasIcon;
        }
        iconOptions = {};
        if ((_ref = unit.collection) != null ? _ref.hasReducedPriority() : void 0) {
          iconOptions.reducedProminence = true;
        }
        return icon = new ctor(ICON_SIZE, color, unit.id, iconOptions);
      };

      return MapBaseView;

    })(Backbone.Marionette.View);
    return MapBaseView;
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['leaflet', 'backbone', 'app/map'], function(L, Backbone, _arg) {
    var MapStateModel, MapUtils, VIEWPOINTS, boundsFromRadius, _latitudeDeltaFromRadius, _longitudeDeltaFromRadius;
    MapUtils = _arg.MapUtils;
    VIEWPOINTS = {
      singleUnitImmediateVicinity: 200,
      singleObjectEmbedded: 400
    };
    _latitudeDeltaFromRadius = function(radiusMeters) {
      return (radiusMeters / 40075017) * 360;
    };
    _longitudeDeltaFromRadius = function(radiusMeters, latitude) {
      return _latitudeDeltaFromRadius(radiusMeters) / Math.cos(L.LatLng.DEG_TO_RAD * latitude);
    };
    boundsFromRadius = function(radiusMeters, latLng) {
      var delta, max, min;
      delta = L.latLng(_latitudeDeltaFromRadius(radiusMeters), _longitudeDeltaFromRadius(radiusMeters, latLng.lat));
      min = L.latLng(latLng.lat - delta.lat, latLng.lng - delta.lng);
      max = L.latLng(latLng.lat + delta.lat, latLng.lng + delta.lng);
      return L.latLngBounds([min, max]);
    };
    return MapStateModel = (function(_super) {
      __extends(MapStateModel, _super);

      function MapStateModel() {
        this.onSelectPosition = __bind(this.onSelectPosition, this);
        return MapStateModel.__super__.constructor.apply(this, arguments);
      }

      MapStateModel.prototype.initialize = function(opts, embedded) {
        this.opts = opts;
        this.embedded = embedded;
        this.userHasModifiedView = false;
        this.wasAutomatic = false;
        this.zoom = null;
        this.bounds = null;
        this.center = null;
        return this.listenTo(this.opts.selectedPosition, 'change:value', this.onSelectPosition);
      };

      MapStateModel.prototype.setMap = function(map) {
        this.map = map;
        this.map.mapState = this;
        return this.map.on('moveend', _.bind(this.onMoveEnd, this));
      };

      MapStateModel.prototype.onSelectPosition = function(position) {
        if (position.isSet()) {
          return this.setUserModified();
        }
      };

      MapStateModel.prototype.onMoveEnd = function() {
        if (!this.wasAutomatic) {
          this.setUserModified();
        }
        return this.wasAutomatic = false;
      };

      MapStateModel.prototype.setUserModified = function() {
        return this.userHasModifiedView = true;
      };

      MapStateModel.prototype.adaptToLayer = function(layer) {
        return this.adaptToBounds(layer.getBounds());
      };

      MapStateModel.prototype.adaptToBounds = function(bounds) {
        var EMBED_RADIUS, mapBounds, radiusFilter, unitsInsideMap, viewOptions, zoom, _ref;
        mapBounds = this.map.getBounds();
        if ((bounds != null) && (this.map.getZoom() === this.map.getBoundsZoom(bounds) && mapBounds.contains(bounds))) {
          return;
        }
        if ((_ref = this.opts.route) != null ? _ref.has('plan') : void 0) {
          if (bounds != null) {
            this.map.fitBounds(bounds, {
              paddingTopLeft: [20, 0],
              paddingBottomRight: [20, 20]
            });
          }
          return;
        }
        viewOptions = {
          center: null,
          zoom: null,
          bounds: null
        };
        zoom = Math.max(MapUtils.getZoomlevelToShowAllMarkers(), this.map.getZoom());
        EMBED_RADIUS = VIEWPOINTS['singleObjectEmbedded'];
        if (this.opts.selectedUnits.isSet()) {
          if (this.embedded === true) {
            viewOptions.zoom = null;
            viewOptions.bounds = boundsFromRadius(EMBED_RADIUS, MapUtils.latLngFromGeojson(this.opts.selectedUnits.first()));
          } else {
            viewOptions.center = MapUtils.latLngFromGeojson(this.opts.selectedUnits.first());
            viewOptions.zoom = zoom;
          }
        } else if (this.opts.selectedPosition.isSet()) {
          if (this.embedded === true) {
            viewOptions.zoom = null;
            viewOptions.bounds = boundsFromRadius(EMBED_RADIUS, MapUtils.latLngFromGeojson(this.opts.selectedPosition.value()));
          } else {
            viewOptions.center = MapUtils.latLngFromGeojson(this.opts.selectedPosition.value());
            radiusFilter = this.opts.selectedPosition.value().get('radiusFilter');
            if (radiusFilter != null) {
              viewOptions.zoom = null;
              viewOptions.bounds = bounds;
            } else {
              viewOptions.zoom = zoom;
            }
          }
        }
        if (this.opts.selectedDivision.isSet()) {
          viewOptions = this._widenToDivision(this.opts.selectedDivision.value(), viewOptions);
        }
        if (this.opts.services.size() || this.opts.searchResults.size() && this.opts.selectedUnits.isEmpty()) {
          if (bounds != null) {
            if (!(this.opts.selectedPosition.isEmpty() && mapBounds.contains(bounds))) {
              if (this.embedded === true) {
                this.map.fitBounds(bounds);
                return;
              } else {
                unitsInsideMap = this._objectsInsideBounds(mapBounds, this.opts.units);
                if (!(this.opts.selectedPosition.isEmpty() && unitsInsideMap)) {
                  viewOptions = this._widenViewMinimally(this.opts.units, viewOptions);
                }
              }
            }
          }
        }
        return this.setMapView(viewOptions);
      };

      MapStateModel.prototype.setMapView = function(viewOptions) {
        var bounds;
        if (viewOptions == null) {
          return;
        }
        bounds = viewOptions.bounds;
        if (bounds) {
          if (this.map.getZoom() === this.map.getBoundsZoom(bounds) && this.map.getBounds().contains(bounds)) {
            return;
          }
          return this.map.fitBounds(viewOptions.bounds, {
            paddingTopLeft: [20, 0],
            paddingBottomRight: [20, 20]
          });
        } else if (viewOptions.center && viewOptions.zoom) {
          return this.map.setView(viewOptions.center, viewOptions.zoom);
        }
      };

      MapStateModel.prototype.centerLatLng = function(latLng, opts) {
        var zoom;
        zoom = this.map.getZoom();
        if (this.opts.selectedPosition.isSet()) {
          zoom = MapUtils.getZoomlevelToShowAllMarkers();
        } else if (this.opts.selectedUnits.isSet()) {
          zoom = MapUtils.getZoomlevelToShowAllMarkers();
        }
        return this.map.setView(latLng, zoom);
      };

      MapStateModel.prototype.adaptToLatLngs = function(latLngs) {
        if (latLngs.length === 0) {
          return;
        }
        return this.adaptToBounds(L.latLngBounds(latLngs));
      };

      MapStateModel.prototype._objectsInsideBounds = function(bounds, objects) {
        return objects.find(function(object) {
          var latLng;
          latLng = MapUtils.latLngFromGeojson(object);
          if (latLng != null) {
            return bounds.contains(latLng);
          }
          return false;
        });
      };

      MapStateModel.prototype._widenToDivision = function(division, viewOptions) {
        var bounds, mapBounds;
        mapBounds = this.map.getBounds();
        viewOptions.center = null;
        viewOptions.zoom = null;
        bounds = L.latLngBounds(L.GeoJSON.geometryToLayer(division.get('boundary'), null, null, {}).getBounds());
        if (mapBounds.contains(bounds)) {
          viewOptions = null;
        } else {
          viewOptions.bounds = bounds;
        }
        return viewOptions;
      };

      MapStateModel.prototype._widenViewMinimally = function(units, viewOptions) {
        var UNIT_COUNT, center, countLeft, mapBounds, service, sortedUnits, topLatLngs, unit, unitsFound, _i, _len, _ref;
        UNIT_COUNT = 2;
        mapBounds = this.map.getBounds();
        center = viewOptions.center || this.map.getCenter();
        sortedUnits = units.chain().filter((function(_this) {
          return function(unit) {
            return unit.has('location');
          };
        })(this)).sortBy((function(_this) {
          return function(unit) {
            return center.distanceTo(MapUtils.latLngFromGeojson(unit));
          };
        })(this)).value();
        topLatLngs = [];
        unitsFound = {};
        if (this.opts.services.size()) {
          _.each(this.opts.services.pluck('id'), (function(_this) {
            return function(id) {
              return unitsFound[id] = UNIT_COUNT;
            };
          })(this));
          for (_i = 0, _len = sortedUnits.length; _i < _len; _i++) {
            unit = sortedUnits[_i];
            if (_.isEmpty(unitsFound)) {
              break;
            }
            service = (_ref = unit.collection.filters) != null ? _ref.service : void 0;
            if (service != null) {
              countLeft = unitsFound[service];
              if (countLeft != null) {
                unitsFound[service] -= 1;
                if (unitsFound[service] === 0) {
                  delete unitsFound[service];
                }
              }
              topLatLngs.push(MapUtils.latLngFromGeojson(unit));
            }
          }
        } else if (this.opts.searchResults.isSet()) {
          topLatLngs = _(sortedUnits).map((function(_this) {
            return function(unit) {
              return MapUtils.latLngFromGeojson(unit);
            };
          })(this));
        }
        if (sortedUnits != null ? sortedUnits.length : void 0) {
          viewOptions.bounds = L.latLngBounds(topLatLngs).extend(center);
          viewOptions.center = null;
          viewOptions.zoom = null;
        }
        return viewOptions;
      };

      MapStateModel.prototype.zoomIn = function() {
        this.wasAutomatic = true;
        return this.map.setZoom(this.map.getZoom() + 1);
      };

      return MapStateModel;

    })(Backbone.Model);
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['leaflet', 'backbone', 'backbone.marionette', 'leaflet.markercluster', 'leaflet.activearea', 'i18next', 'app/widgets', 'app/models', 'app/p13n', 'app/jade', 'app/map-base-view', 'app/transit-map', 'app/map', 'app/base', 'app/map-state-model', 'app/views/exporting', 'app/views/location-refresh-button'], function(leaflet, Backbone, Marionette, markercluster, leaflet_activearea, i18n, widgets, models, p13n, jade, MapBaseView, TransitMapMixin, map, _arg, MapStateModel, ExportingView, LocationRefreshButtonView) {
    var DEFAULT_CENTER, ICON_SIZE, MARKER_POINT_VARIANT, MapView, mixOf;
    mixOf = _arg.mixOf;
    ICON_SIZE = 40;
    if (getIeVersion() && getIeVersion() < 9) {
      ICON_SIZE *= .8;
    }
    MARKER_POINT_VARIANT = false;
    DEFAULT_CENTER = [60.171944, 24.941389];
    MapView = (function(_super) {
      __extends(MapView, _super);

      function MapView() {
        this.preAdapt = __bind(this.preAdapt, this);
        return MapView.__super__.constructor.apply(this, arguments);
      }

      MapView.prototype.tagName = 'div';

      MapView.prototype.initialize = function(opts, mapOpts) {
        this.opts = opts;
        this.mapOpts = mapOpts;
        MapView.__super__.initialize.call(this, this.opts, this.mapOpts);
        this.selectedServices = this.opts.services;
        this.searchResults = this.opts.searchResults;
        this.selectedDivision = this.opts.selectedDivision;
        this.userPositionMarkers = {
          accuracy: null,
          position: null,
          clicked: null
        };
        this.listenTo(this.selectedServices, 'add', (function(_this) {
          return function(service, collection) {
            if (collection.size() === 1) {
              return _this.markers = {};
            }
          };
        })(this));
        this.listenTo(this.selectedServices, 'remove', (function(_this) {
          return function(model, collection) {
            if (collection.size() === 0) {
              return _this.markers = {};
            }
          };
        })(this));
        this.listenTo(this.selectedDivision, 'change:value', (function(_this) {
          return function(model) {
            _this.divisionLayer.clearLayers();
            return _this.drawDivision(model.value());
          };
        })(this));
        this.listenTo(this.units, 'unit:highlight', this.highlightUnselectedUnit);
        this.listenTo(this.units, 'batch-remove', this.removeUnits);
        this.listenTo(this.units, 'remove', this.removeUnit);
        this.listenTo(this.selectedUnits, 'reset', this.handleSelectedUnit);
        this.listenTo(p13n, 'position', this.handlePosition);
        if (this.selectedPosition.isSet()) {
          this.listenTo(this.selectedPosition.value(), 'change:radiusFilter', this.radiusFilterChanged);
        }
        this.listenTo(this.selectedPosition, 'change:value', (function(_this) {
          return function(wrapper, value) {
            var previous;
            previous = wrapper.previous('value');
            if (previous != null) {
              _this.stopListening(previous);
            }
            if (value != null) {
              _this.listenTo(value, 'change:radiusFilter', _this.radiusFilterChanged);
            }
            return _this.handlePosition(value, {
              center: true
            });
          };
        })(this));
        MapView.setMapActiveAreaMaxHeight({
          maximize: this.selectedPosition.isEmpty() && this.selectedUnits.isEmpty()
        });
        return this.initializeTransitMap({
          route: this.opts.route,
          selectedUnits: this.selectedUnits,
          selectedPosition: this.selectedPosition
        });
      };

      MapView.prototype.onMapClicked = function(ev) {
        var position;
        if (this.hasClickedPosition == null) {
          this.hasClickedPosition = false;
        }
        if (this.hasClickedPosition) {
          this.infoPopups.clearLayers();
          this.map.removeLayer(this.userPositionMarkers['clicked']);
          return this.hasClickedPosition = false;
        } else {
          if (this.pendingPosition != null) {
            position = this.pendingPosition;
          } else {
            position = new models.CoordinatePosition({
              isDetected: false
            });
          }
          position.set('location', {
            coordinates: [ev.latlng.lng, ev.latlng.lat],
            accuracy: 0,
            type: 'Point'
          });
          if (this.pendingPosition != null) {
            this.pendingPosition = null;
            $('#map').css('cursor', 'auto');
          } else {
            position.set('name', null);
            this.hasClickedPosition = true;
          }
          return this.handlePosition(position, {
            initial: true
          });
        }
      };

      MapView.prototype.requestLocation = function(position) {
        $('#map').css('cursor', 'crosshair');
        return this.pendingPosition = position;
      };

      MapView.prototype.radiusFilterChanged = function(position, radius) {
        var latLng, poly;
        this.divisionLayer.clearLayers();
        if (radius == null) {
          return;
        }
        latLng = L.GeoJSON.geometryToLayer(position.get('location'));
        poly = new widgets.CirclePolygon(latLng.getLatLng(), radius, {
          invert: true,
          stroke: false
        });
        poly.circle.options.fill = false;
        poly.addTo(this.divisionLayer);
        return poly.circle.addTo(this.divisionLayer);
      };

      MapView.prototype.handleSelectedUnit = function(units, options) {
        var latLng, unit, _ref;
        if (units.isEmpty()) {
          this._removeBboxMarkers(this.map.getZoom(), map.MapUtils.getZoomlevelToShowAllMarkers());
          MapView.setMapActiveAreaMaxHeight({
            maximize: true
          });
          return;
        }
        unit = units.first();
        latLng = (_ref = unit.marker) != null ? _ref.getLatLng() : void 0;
        if (latLng != null) {
          this.map.adaptToLatLngs([latLng]);
        }
        if (!unit.hasBboxFilter()) {
          this._removeBboxMarkers();
          this._skipBboxDrawing = false;
        }
        return _.defer((function(_this) {
          return function() {
            return _this.highlightSelectedUnit(unit);
          };
        })(this));
      };

      MapView.prototype.handlePosition = function(positionObject, opts) {
        var accuracy, accuracyMarker, isSelected, key, latLng, layer, location, marker, pop, popup, prev, _i, _len, _ref;
        if (positionObject == null) {
          _ref = ['clicked', 'address'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            key = _ref[_i];
            layer = this.userPositionMarkers[key];
            if (layer) {
              this.map.removeLayer(layer);
            }
          }
        }
        isSelected = positionObject === this.selectedPosition.value();
        key = positionObject != null ? positionObject.origin() : void 0;
        if (key !== 'detected') {
          this.infoPopups.clearLayers();
        }
        prev = this.userPositionMarkers[key];
        if (prev) {
          this.map.removeLayer(prev);
        }
        if ((key === 'address') && (this.userPositionMarkers.clicked != null)) {
          this.map.removeLayer(this.userPositionMarkers.clicked);
        }
        if ((key === 'clicked') && isSelected && (this.userPositionMarkers.address != null)) {
          this.map.removeLayer(this.userPositionMarkers.address);
        }
        location = positionObject != null ? positionObject.get('location') : void 0;
        if (!location) {
          return;
        }
        accuracy = location.accuracy;
        accuracyMarker = L.circle(latLng, accuracy, {
          weight: 0
        });
        latLng = map.MapUtils.latLngFromGeojson(positionObject);
        marker = map.MapUtils.createPositionMarker(latLng, accuracy, positionObject.origin());
        marker.position = positionObject;
        marker.on('click', (function(_this) {
          return function() {
            return app.commands.execute('selectPosition', positionObject);
          };
        })(this));
        if (isSelected || (opts != null ? opts.center : void 0)) {
          this.map.refitAndAddMarker(marker);
        } else {
          marker.addTo(this.map);
        }
        this.userPositionMarkers[key] = marker;
        if (isSelected) {
          this.infoPopups.clearLayers();
        }
        popup = this.createPositionPopup(positionObject, marker);
        if (!(positionObject != null ? positionObject.isDetectedLocation() : void 0) || this.selectedUnits.isEmpty() && (this.selectedPosition.isEmpty() || this.selectedPosition.value() === positionObject)) {
          pop = (function(_this) {
            return function() {
              return _this.infoPopups.addLayer(popup);
            };
          })(this);
          if (!positionObject.get('preventPopup')) {
            if (isSelected || ((opts != null ? opts.initial : void 0) && !positionObject.get('preventPopup'))) {
              pop();
              if (isSelected) {
                $(popup._wrapper).addClass('selected');
              }
            }
          }
        }
        return positionObject.popup = popup;
      };

      MapView.prototype.width = function() {
        return this.$el.width();
      };

      MapView.prototype.height = function() {
        return this.$el.height();
      };

      MapView.prototype.removeUnits = function(options) {
        this.allMarkers.clearLayers();
        this.drawUnits(this.units);
        if (!this.selectedUnits.isEmpty()) {
          this.highlightSelectedUnit(this.selectedUnits.first());
        }
        if (this.units.isEmpty()) {
          return this.showAllUnitsAtHighZoom();
        }
      };

      MapView.prototype.removeUnit = function(unit, units, options) {
        if (unit.marker != null) {
          this.allMarkers.removeLayer(unit.marker);
          return delete unit.marker;
        }
      };

      MapView.prototype.getServices = function() {
        return this.selectedServices;
      };

      MapView.prototype.createPositionPopup = function(positionObject, marker) {
        var address, latLng, offset, offsetY, popup, popupContents, popupOpts;
        latLng = map.MapUtils.latLngFromGeojson(positionObject);
        address = positionObject.humanAddress();
        if (!address) {
          address = i18n.t('map.retrieving_address');
        }
        if (positionObject === this.selectedPosition.value()) {
          popupContents = (function(_this) {
            return function(ctx) {
              return "<div class=\"unit-name\">" + ctx.name + "</div>";
            };
          })(this);
          offsetY = (function() {
            switch (positionObject.origin()) {
              case 'detected':
                return 10;
              case 'address':
                return 10;
              default:
                return 38;
            }
          })();
          popup = this.createPopup(null, null, L.point(0, offsetY)).setContent(popupContents({
            name: address
          })).setLatLng(latLng);
        } else {
          popupContents = (function(_this) {
            return function(ctx) {
              var $popupEl;
              ctx.detected = positionObject != null ? positionObject.isDetectedLocation() : void 0;
              $popupEl = $(jade.template('position-popup', ctx));
              $popupEl.on('click', function(e) {
                if (positionObject !== _this.selectedPosition.value()) {
                  e.stopPropagation();
                  _this.listenTo(positionObject, 'reverse-geocode', function() {
                    return app.commands.execute('selectPosition', positionObject);
                  });
                  marker.closePopup();
                  _this.infoPopups.clearLayers();
                  _this.map.removeLayer(positionObject.popup);
                  if (positionObject.isReverseGeocoded()) {
                    return positionObject.trigger('reverse-geocode');
                  }
                }
              });
              return $popupEl[0];
            };
          })(this);
          offsetY = (function() {
            switch (positionObject.origin()) {
              case 'detected':
                return -53;
              case 'clicked':
                return -15;
              case 'address':
                return -50;
            }
          })();
          offset = L.point(0, offsetY);
          popupOpts = {
            closeButton: false,
            className: 'position',
            autoPan: false,
            offset: offset,
            autoPanPaddingTopLeft: L.point(30, 80),
            autoPanPaddingBottomRight: L.point(30, 80)
          };
          popup = L.popup(popupOpts).setLatLng(latLng).setContent(popupContents({
            name: address
          }));
        }
        if (typeof positionObject.reverseGeocode === "function") {
          positionObject.reverseGeocode().done((function(_this) {
            return function() {
              return popup.setContent(popupContents({
                name: positionObject.humanAddress()
              }));
            };
          })(this));
        }
        return popup;
      };

      MapView.prototype.highlightSelectedUnit = function(unit) {
        var marker, popup;
        if (unit == null) {
          return;
        }
        marker = unit.marker;
        popup = marker != null ? marker.popup : void 0;
        if (!popup) {
          return;
        }
        popup.selected = true;
        this._clearOtherPopups(popup, {
          clearSelected: true
        });
        if (!this.popups.hasLayer(popup)) {
          popup.setLatLng(marker.getLatLng());
          this.popups.addLayer(popup);
        }
        this.listenToOnce(unit, 'change:selected', (function(_this) {
          return function(unit) {
            $(marker != null ? marker._icon : void 0).removeClass('selected');
            $(marker != null ? marker.popup._wrapper : void 0).removeClass('selected');
            return _this.popups.removeLayer(marker != null ? marker.popup : void 0);
          };
        })(this));
        $(marker != null ? marker._icon : void 0).addClass('selected');
        return $(marker != null ? marker.popup._wrapper : void 0).addClass('selected');
      };

      MapView.prototype.selectMarker = function(event) {
        var marker, unit;
        marker = event.target;
        unit = marker.unit;
        return app.commands.execute('selectUnit', unit);
      };

      MapView.prototype.drawUnit = function(unit, units, options) {
        var location, marker;
        location = unit.get('location');
        if (location != null) {
          marker = this.createMarker(unit);
          return this.allMarkers.addLayer(marker);
        }
      };

      MapView.prototype.getCenteredView = function() {
        if (this.selectedPosition.isSet()) {
          return {
            center: map.MapUtils.latLngFromGeojson(this.selectedPosition.value()),
            zoom: map.MapUtils.getZoomlevelToShowAllMarkers()
          };
        } else if (this.selectedUnits.isSet()) {
          return {
            center: map.MapUtils.latLngFromGeojson(this.selectedUnits.first()),
            zoom: Math.max(this.getMaxAutoZoom(), this.map.getZoom())
          };
        } else {
          return null;
        }
      };

      MapView.prototype.resetMap = function() {
        return window.location.reload(true);
      };

      MapView.prototype.handleP13nChange = function(path, newVal) {
        var mapStyle, newCrs, newLayer, oldCrs, oldLayer, _ref;
        if (path[0] !== 'map_background_layer') {
          return;
        }
        oldLayer = this.map._baseLayer;
        oldCrs = this.map.crs;
        mapStyle = p13n.get('map_background_layer');
        _ref = map.MapMaker.makeBackgroundLayer({
          style: mapStyle
        }), newLayer = _ref.layer, newCrs = _ref.crs;
        if (newCrs.code !== oldCrs.code) {
          this.resetMap();
          return;
        }
        this.map.addLayer(newLayer);
        this.map.removeLayer(oldLayer);
        return this.map._baseLayer = newLayer;
      };

      MapView.prototype.addMapActiveArea = function() {
        this.map.setActiveArea('active-area');
        return MapView.setMapActiveAreaMaxHeight({
          maximize: this.selectedUnits.isEmpty() && this.selectedPosition.isEmpty()
        });
      };

      MapView.prototype.initializeMap = function() {
        this.setInitialView();
        window.debugMap = map;
        this.listenTo(p13n, 'change', this.handleP13nChange);
        this.popups = L.layerGroup();
        this.infoPopups = L.layerGroup();
        L.control.zoom({
          position: 'bottomright',
          zoomInText: "<span class=\"icon-icon-zoom-in\"></span><span class=\"sr-only\">" + (i18n.t('assistive.zoom_in')) + "</span>",
          zoomOutText: "<span class=\"icon-icon-zoom-out\"></span><span class=\"sr-only\">" + (i18n.t('assistive.zoom_out')) + "</span>"
        }).addTo(this.map);
        new widgets.ControlWrapper(new LocationRefreshButtonView(), {
          position: 'bottomright'
        }).addTo(this.map);
        new widgets.ControlWrapper(new ExportingView(), {
          position: 'bottomright'
        }).addTo(this.map);
        this.popups.addTo(this.map);
        this.infoPopups.addTo(this.map);
        this.debugGrid = L.layerGroup().addTo(this.map);
        this.debugCircles = {};
        this._addMapMoveListeners();
        if (p13n.getLocationRequested()) {
          p13n.requestLocation();
        }
        this.previousZoomlevel = this.map.getZoom();
        return this.drawInitialState();
      };

      MapView.prototype._removeBboxMarkers = function(zoom, zoomLimit) {
        var toRemove;
        if (this.markers == null) {
          return;
        }
        if (this.markers.length === 0) {
          return;
        }
        if ((zoom != null) && (zoomLimit != null)) {
          if (zoom >= zoomLimit) {
            return;
          }
        }
        this._skipBboxDrawing = true;
        if (this.selectedServices.isSet()) {
          return;
        }
        toRemove = _.filter(this.markers, (function(_this) {
          return function(m) {
            var ret, unit, _ref;
            unit = m != null ? m.unit : void 0;
            return ret = (unit != null ? (_ref = unit.collection) != null ? _ref.hasReducedPriority() : void 0 : void 0) && !(unit != null ? unit.get('selected') : void 0);
          };
        })(this));
        app.commands.execute('clearFilters');
        this.allMarkers.removeLayers(toRemove);
        return this._clearOtherPopups(null, null);
      };

      MapView.prototype._addMapMoveListeners = function() {
        var zoomLimit;
        zoomLimit = map.MapUtils.getZoomlevelToShowAllMarkers();
        this.map.on('zoomanim', (function(_this) {
          return function(data) {
            _this._skipBboxDrawing = false;
            return _this._removeBboxMarkers(data.zoom, zoomLimit);
          };
        })(this));
        this.map.on('zoomend', (function(_this) {
          return function() {
            return _this._removeBboxMarkers(_this.map.getZoom(), zoomLimit);
          };
        })(this));
        return this.map.on('moveend', (function(_this) {
          return function() {
            if (_this.skipMoveend) {
              _this.skipMoveend = false;
              return;
            }
            return _this.showAllUnitsAtHighZoom();
          };
        })(this));
      };

      MapView.prototype.postInitialize = function() {
        this.addMapActiveArea();
        this.initializeMap();
        return this._addMouseoverListeners(this.allMarkers);
      };

      MapView.mapActiveAreaMaxHeight = function() {
        var screenHeight, screenWidth;
        screenWidth = $(window).innerWidth();
        screenHeight = $(window).innerHeight();
        return Math.min(screenWidth * 0.4, screenHeight * 0.3);
      };

      MapView.prototype.preAdapt = function() {
        return MapView.setMapActiveAreaMaxHeight();
      };

      MapView.setMapActiveAreaMaxHeight = function(options) {
        var $activeArea, defaults, height;
        defaults = {
          maximize: false
        };
        options = options || {};
        _.extend(defaults, options);
        options = defaults;
        if ($(window).innerWidth() <= appSettings.mobile_ui_breakpoint) {
          height = MapView.mapActiveAreaMaxHeight();
          $activeArea = $('.active-area');
          if (options.maximize) {
            $activeArea.css('height', 'auto');
            return $activeArea.css('bottom', 0);
          } else {
            $activeArea.css('height', height);
            return $activeArea.css('bottom', 'auto');
          }
        } else {
          $('.active-area').css('height', 'auto');
          return $('.active-area').css('bottom', 0);
        }
      };

      MapView.prototype.recenter = function() {
        var view;
        view = this.getCenteredView();
        if (view == null) {
          return;
        }
        return this.map.setView(view.center, view.zoom, {
          pan: {
            duration: 0.5
          }
        });
      };

      MapView.prototype.refitBounds = function() {
        this.skipMoveend = true;
        return this.map.fitBounds(this.allMarkers.getBounds(), {
          maxZoom: this.getMaxAutoZoom(),
          animate: true
        });
      };

      MapView.prototype.fitItinerary = function(layer) {
        return this.map.fitBounds(layer.getBounds(), {
          paddingTopLeft: [20, 20],
          paddingBottomRight: [20, 20]
        });
      };

      MapView.prototype.showAllUnitsAtHighZoom = function() {
        var bbox, bboxes, level, transformedBounds, _i, _len, _ref, _ref1;
        if ($(window).innerWidth() <= appSettings.mobile_ui_breakpoint) {
          return;
        }
        if (this.map.getZoom() >= map.MapUtils.getZoomlevelToShowAllMarkers()) {
          if (this.selectedUnits.isSet() && (((_ref = this.selectedUnits.first().collection) != null ? (_ref1 = _ref.filters) != null ? _ref1.bbox : void 0 : void 0) == null)) {
            return;
          }
          if (this.selectedServices.isSet()) {
            return;
          }
          if (this.searchResults.isSet()) {
            return;
          }
          transformedBounds = map.MapUtils.overlappingBoundingBoxes(this.map);
          bboxes = [];
          for (_i = 0, _len = transformedBounds.length; _i < _len; _i++) {
            bbox = transformedBounds[_i];
            bboxes.push("" + bbox[0][0] + "," + bbox[0][1] + "," + bbox[1][0] + "," + bbox[1][1]);
          }
          if (this.mapOpts.level != null) {
            level = this.mapOpts.level;
            delete this.mapOpts.level;
          }
          return app.commands.execute('addUnitsWithinBoundingBoxes', bboxes, level);
        }
      };

      return MapView;

    })(mixOf(MapBaseView, TransitMapMixin));
    return MapView;
  });

}).call(this);

//

(function() {
  define(['leaflet', 'proj4leaflet', 'underscore', 'app/base'], function(leaflet, p4j, _, sm) {
    var MapMaker, MapUtils, RETINA_MODE, SMap, getMaxBounds, makeDistanceComparator, makeLayer, wmtsPath;
    RETINA_MODE = window.devicePixelRatio > 1;
    getMaxBounds = function(layer) {
      return L.latLngBounds(L.latLng(59.5, 24.2), L.latLng(60.5, 25.5));
    };
    wmtsPath = function(style, language) {
      var path, stylePath;
      stylePath = style === 'accessible_map' ? language === 'sv' ? "osm-sm-visual-sv/etrs_tm35fin" : "osm-sm-visual/etrs_tm35fin" : RETINA_MODE ? language === 'sv' ? "osm-sm-sv-hq/etrs_tm35fin_hq" : "osm-sm-hq/etrs_tm35fin_hq" : language === 'sv' ? "osm-sm-sv/etrs_tm35fin" : "osm-sm/etrs_tm35fin";
      path = ["http://geoserver.hel.fi/mapproxy/wmts", stylePath, "{z}/{x}/{y}.png"];
      return path.join('/');
    };
    makeLayer = {
      tm35: {
        crs: function() {
          var bounds, crsName, crsOpts, originNw, projDef;
          crsName = 'EPSG:3067';
          projDef = '+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs';
          bounds = L.bounds(L.point(-548576, 6291456), L.point(1548576, 8388608));
          originNw = [bounds.min.x, bounds.max.y];
          crsOpts = {
            resolutions: [8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125],
            bounds: bounds,
            transformation: new L.Transformation(1, -originNw[0], -1, originNw[1])
          };
          return new L.Proj.CRS(crsName, projDef, crsOpts);
        },
        layer: function(opts) {
          return L.tileLayer(wmtsPath(opts.style, opts.language), {
            maxZoom: 15,
            minZoom: 6,
            continuousWorld: true,
            tms: false
          });
        }
      },
      gk25: {
        crs: function() {
          var bounds, crsName, projDef;
          crsName = 'EPSG:3879';
          projDef = '+proj=tmerc +lat_0=0 +lon_0=25 +k=1 +x_0=25500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs';
          bounds = [25440000, 6630000, 25571072, 6761072];
          return new L.Proj.CRS.TMS(crsName, projDef, bounds, {
            resolutions: [256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5, 0.25, 0.125, 0.0625, 0.03125]
          });
        },
        layer: function(opts) {
          var geoserverUrl, guideMapOptions, guideMapUrl;
          geoserverUrl = function(layerName, layerFmt) {
            return "http://geoserver.hel.fi/geoserver/gwc/service/tms/1.0.0/" + layerName + "@ETRS-GK25@" + layerFmt + "/{z}/{x}/{y}." + layerFmt;
          };
          if (opts.style === 'ortographic') {
            return new L.Proj.TileLayer.TMS(geoserverUrl("hel:orto2013", "jpg"), opts.crs, {
              maxZoom: 10,
              minZoom: 2,
              continuousWorld: true,
              tms: false
            });
          } else {
            guideMapUrl = geoserverUrl("hel:Karttasarja", "gif");
            guideMapOptions = {
              maxZoom: 12,
              minZoom: 2,
              continuousWorld: true,
              tms: false
            };
            return (new L.Proj.TileLayer.TMS(guideMapUrl, opts.crs, guideMapOptions)).setOpacity(0.8);
          }
        }
      }
    };
    SMap = L.Map.extend({
      refitAndAddLayer: function(layer) {
        this.mapState.adaptToLayer(layer);
        return this.addLayer(layer);
      },
      refitAndAddMarker: function(marker) {
        this.mapState.adaptToLatLngs([marker.getLatLng()]);
        return this.addLayer(marker);
      },
      adaptToLatLngs: function(latLngs) {
        return this.mapState.adaptToLatLngs(latLngs);
      },
      adapt: function() {
        return this.mapState.adaptToBounds(null);
      }
    });
    MapMaker = (function() {
      function MapMaker() {}

      MapMaker.makeBackgroundLayer = function(options) {
        var coordinateSystem, crs, layerMaker, tileLayer;
        coordinateSystem = (function() {
          switch (options.style) {
            case 'guidemap':
              return 'gk25';
            case 'ortographic':
              return 'gk25';
            default:
              return 'tm35';
          }
        })();
        layerMaker = makeLayer[coordinateSystem];
        crs = layerMaker.crs();
        options.crs = crs;
        tileLayer = layerMaker.layer(options);
        tileLayer.on('tileload', (function(_this) {
          return function(e) {
            return e.tile.setAttribute('alt', '');
          };
        })(this));
        return {
          layer: tileLayer,
          crs: crs
        };
      };

      MapMaker.createMap = function(domElement, options, mapOptions, mapState) {
        var crs, defaultMapOptions, layer, map, _ref;
        _ref = MapMaker.makeBackgroundLayer(options), layer = _ref.layer, crs = _ref.crs;
        defaultMapOptions = {
          crs: crs,
          continuusWorld: true,
          worldCopyJump: false,
          zoomControl: false,
          closePopupOnClick: false,
          maxBounds: getMaxBounds(options.style),
          layers: [layer]
        };
        _.extend(defaultMapOptions, mapOptions);
        map = new SMap(domElement, defaultMapOptions);
        if (mapState != null) {
          mapState.setMap(map);
        }
        map.crs = crs;
        map._baseLayer = layer;
        return map;
      };

      return MapMaker;

    })();
    MapUtils = (function() {
      function MapUtils() {}

      MapUtils.createPositionMarker = function(latLng, accuracy, type, opts) {
        var Z_INDEX, marker;
        Z_INDEX = -1000;
        switch (type) {
          case 'detected':
            opts = {
              icon: L.divIcon({
                iconSize: L.point(40, 40),
                iconAnchor: L.point(20, 39),
                className: 'servicemap-div-icon',
                html: '<span class="icon-icon-you-are-here"></span'
              }),
              zIndexOffset: Z_INDEX
            };
            marker = L.marker(latLng, opts);
            break;
          case 'clicked':
            marker = L.circleMarker(latLng, {
              color: '#666',
              weight: 2,
              opacity: 1,
              fill: false,
              clickable: (opts != null ? opts.clickable : void 0) != null ? opts.clickable : false,
              zIndexOffset: Z_INDEX
            });
            marker.setRadius(6);
            break;
          case 'address':
            opts = {
              zIndexOffset: Z_INDEX,
              icon: L.divIcon({
                iconSize: L.point(40, 40),
                iconAnchor: L.point(20, 39),
                className: 'servicemap-div-icon',
                html: '<span class="icon-icon-address"></span'
              })
            };
            marker = L.marker(latLng, opts);
        }
        return marker;
      };

      MapUtils.overlappingBoundingBoxes = function(map) {
        var DEBUG_GRID, METER_GRID, bbox, bboxes, coordinates, crs, dim, latLngBounds, max, min, ne, nes, pairs, snapToGrid, sw, sws, value, x, y, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2;
        crs = map.crs;
        if (map._originalGetBounds != null) {
          latLngBounds = map._originalGetBounds();
        } else {
          latLngBounds = map.getBounds();
        }
        METER_GRID = 1000;
        DEBUG_GRID = false;
        ne = crs.project(latLngBounds.getNorthEast());
        sw = crs.project(latLngBounds.getSouthWest());
        min = {
          x: ne.x,
          y: sw.y
        };
        max = {
          y: ne.y,
          x: sw.x
        };
        snapToGrid = function(coord) {
          return parseInt(coord / METER_GRID) * METER_GRID;
        };
        coordinates = {};
        _ref = ['x', 'y'];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dim = _ref[_i];
          coordinates[dim] = coordinates[dim] || {};
          for (value = _j = _ref1 = min[dim], _ref2 = max[dim]; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; value = _ref1 <= _ref2 ? ++_j : --_j) {
            coordinates[dim][parseInt(snapToGrid(value))] = true;
          }
        }
        pairs = _.flatten((function() {
          var _k, _len1, _ref3, _results;
          _ref3 = _.keys(coordinates.y);
          _results = [];
          for (_k = 0, _len1 = _ref3.length; _k < _len1; _k++) {
            y = _ref3[_k];
            _results.push((function() {
              var _l, _len2, _ref4, _results1;
              _ref4 = _.keys(coordinates.x);
              _results1 = [];
              for (_l = 0, _len2 = _ref4.length; _l < _len2; _l++) {
                x = _ref4[_l];
                _results1.push([parseInt(x), parseInt(y)]);
              }
              return _results1;
            })());
          }
          return _results;
        })(), true);
        bboxes = _.map(pairs, function(_arg) {
          var x, y;
          x = _arg[0], y = _arg[1];
          return [[x, y], [x + METER_GRID, y + METER_GRID]];
        });
        if (DEBUG_GRID) {
          this.debugGrid.clearLayers();
          for (_k = 0, _len1 = bboxes.length; _k < _len1; _k++) {
            bbox = bboxes[_k];
            sw = crs.projection.unproject(L.point.apply(L, bbox[0]));
            ne = crs.projection.unproject(L.point.apply(L, bbox[1]));
            sws = [sw.lat, sw.lng].join();
            nes = [ne.lat, ne.lng].join();
            if (!this.debugCircles[sws]) {
              this.debugGrid.addLayer(L.circle(sw, 10));
              this.debugCircles[sws] = true;
            }
            if (!this.debugCircles[nes]) {
              this.debugGrid.addLayer(L.circle(ne, 10));
              this.debugCircles[nes] = true;
            }
          }
        }
        return bboxes;
      };

      MapUtils.latLngFromGeojson = function(object) {
        var _ref, _ref1;
        return L.latLng(object != null ? (_ref = object.get('location')) != null ? (_ref1 = _ref.coordinates) != null ? _ref1.slice(0).reverse() : void 0 : void 0 : void 0);
      };

      MapUtils.getZoomlevelToShowAllMarkers = function() {
        var layer;
        layer = p13n.get('map_background_layer');
        if (layer === 'guidemap') {
          return 8;
        } else if (layer === 'ortographic') {
          return 8;
        } else {
          return 14;
        }
      };

      return MapUtils;

    })();
    makeDistanceComparator = (function(_this) {
      return function(p13n) {
        var createFrom, position;
        createFrom = function(position) {
          return function(obj) {
            var a, b, result, _ref;
            _ref = [MapUtils.latLngFromGeojson(position), MapUtils.latLngFromGeojson(obj)], a = _ref[0], b = _ref[1];
            result = a.distanceTo(b);
            return result;
          };
        };
        position = p13n.getLastPosition();
        if (position != null) {
          return createFrom(position);
        }
      };
    })(this);
    return {
      MapMaker: MapMaker,
      MapUtils: MapUtils,
      makeDistanceComparator: makeDistanceComparator
    };
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['moment', 'underscore', 'raven', 'backbone', 'i18next', 'app/base', 'app/settings', 'app/spinner', 'app/alphabet', 'app/accessibility'], function(moment, _, Raven, Backbone, i18n, _arg, settings, SMSpinner, alphabet, accessibility) {
    var AddressList, AddressPosition, AdministrativeDivision, AdministrativeDivisionList, AdministrativeDivisionType, AdministrativeDivisionTypeList, BACKEND_BASE, CoordinatePosition, Department, DepartmentList, Event, EventList, FeedbackItem, FeedbackItemType, FeedbackList, FeedbackMessage, FilterableCollection, GeoModel, LINKEDEVENTS_BASE, Language, LanguageList, LinkedEventsCollection, LinkedEventsModel, MUNICIPALITIES, MUNICIPALITY_IDS, OPEN311_BASE, OPEN311_WRITE_BASE, Open311Model, Organization, OrganizationList, Position, PositionList, RESTFrameworkCollection, RoutingParameters, SMCollection, SMModel, SearchList, Service, ServiceList, Street, StreetList, Unit, UnitList, WrappedModel, exports, mixOf, pad, withDeferred;
    mixOf = _arg.mixOf, pad = _arg.pad, withDeferred = _arg.withDeferred;
    BACKEND_BASE = appSettings.service_map_backend;
    LINKEDEVENTS_BASE = appSettings.linkedevents_backend;
    OPEN311_BASE = appSettings.open311_backend;
    OPEN311_WRITE_BASE = appSettings.open311_write_backend + '/';
    MUNICIPALITIES = {
      49: 'espoo',
      91: 'helsinki',
      92: 'vantaa',
      235: 'kauniainen'
    };
    MUNICIPALITY_IDS = _.invert(MUNICIPALITIES);
    Backbone.ajax = function(request) {
      request = settings.applyAjaxDefaults(request);
      return Backbone.$.ajax.call(Backbone.$, request);
    };
    FilterableCollection = (function(_super) {
      __extends(FilterableCollection, _super);

      function FilterableCollection() {
        return FilterableCollection.__super__.constructor.apply(this, arguments);
      }

      FilterableCollection.prototype.initialize = function(options) {
        return this.filters = {};
      };

      FilterableCollection.prototype.setFilter = function(key, val) {
        if (!val) {
          if (key in this.filters) {
            delete this.filters[key];
          }
        } else {
          this.filters[key] = val;
        }
        return this;
      };

      FilterableCollection.prototype.clearFilters = function() {
        return this.filters = {};
      };

      FilterableCollection.prototype.fetch = function(options) {
        var data;
        data = _.clone(this.filters);
        if (options.data != null) {
          data = _.extend(data, options.data);
        }
        options.data = data;
        return FilterableCollection.__super__.fetch.call(this, options);
      };

      return FilterableCollection;

    })(Backbone.Collection);
    RESTFrameworkCollection = (function(_super) {
      __extends(RESTFrameworkCollection, _super);

      function RESTFrameworkCollection() {
        return RESTFrameworkCollection.__super__.constructor.apply(this, arguments);
      }

      RESTFrameworkCollection.prototype.parse = function(resp, options) {
        this.fetchState = {
          count: resp.count,
          next: resp.next,
          previous: resp.previous
        };
        return RESTFrameworkCollection.__super__.parse.call(this, resp.results, options);
      };

      return RESTFrameworkCollection;

    })(FilterableCollection);
    WrappedModel = (function(_super) {
      __extends(WrappedModel, _super);

      function WrappedModel() {
        return WrappedModel.__super__.constructor.apply(this, arguments);
      }

      WrappedModel.prototype.initialize = function(model) {
        WrappedModel.__super__.initialize.call(this);
        return this.wrap(model);
      };

      WrappedModel.prototype.wrap = function(model) {
        return this.set('value', model || null);
      };

      WrappedModel.prototype.value = function() {
        return this.get('value');
      };

      WrappedModel.prototype.isEmpty = function() {
        return !this.has('value');
      };

      WrappedModel.prototype.isSet = function() {
        return !this.isEmpty();
      };

      return WrappedModel;

    })(Backbone.Model);
    GeoModel = (function() {
      function GeoModel() {}

      GeoModel.prototype.getLatLng = function() {
        var coords, _ref;
        if (this.latLng != null) {
          this.latLng;
        }
        coords = (_ref = this.get('location')) != null ? _ref.coordinates : void 0;
        if (coords != null) {
          return this.latLng = L.GeoJSON.coordsToLatLng(coords);
        } else {
          return null;
        }
      };

      GeoModel.prototype.getDistanceToLastPosition = function() {
        var latLng, position;
        position = p13n.getLastPosition();
        if (position != null) {
          latLng = this.getLatLng();
          if (latLng != null) {
            return position.getLatLng().distanceTo(latLng);
          } else {
            return Number.MAX_VALUE;
          }
        }
      };

      return GeoModel;

    })();
    SMModel = (function(_super) {
      __extends(SMModel, _super);

      function SMModel() {
        return SMModel.__super__.constructor.apply(this, arguments);
      }

      SMModel.prototype.getText = function(attr) {
        var val;
        val = this.get(attr);
        if (__indexOf.call(this.translatedAttrs, attr) >= 0) {
          return p13n.getTranslatedAttr(val);
        }
        return val;
      };

      SMModel.prototype.toJSON = function(options) {
        var attr, data, _i, _len, _ref;
        data = SMModel.__super__.toJSON.call(this);
        if (!this.translatedAttrs) {
          return data;
        }
        _ref = this.translatedAttrs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attr = _ref[_i];
          if (!(attr in data)) {
            continue;
          }
          data[attr] = p13n.getTranslatedAttr(data[attr]);
        }
        return data;
      };

      SMModel.prototype.url = function() {
        var ret;
        ret = SMModel.__super__.url.apply(this, arguments);
        if (ret.substr(-1 !== '/')) {
          ret = ret + '/';
        }
        return ret;
      };

      SMModel.prototype.urlRoot = function() {
        return "" + BACKEND_BASE + "/" + this.resourceName + "/";
      };

      return SMModel;

    })(Backbone.Model);
    SMCollection = (function(_super) {
      __extends(SMCollection, _super);

      function SMCollection() {
        this.comparatorWrapper = __bind(this.comparatorWrapper, this);
        this.getComparator = __bind(this.getComparator, this);
        return SMCollection.__super__.constructor.apply(this, arguments);
      }

      SMCollection.prototype.initialize = function(models, options) {
        this.filters = {};
        this.currentPage = 1;
        if (options != null) {
          this.pageSize = options.pageSize || 25;
          if (options.setComparator) {
            this.setDefaultComparator();
          }
        }
        return SMCollection.__super__.initialize.call(this, options);
      };

      SMCollection.prototype.url = function() {
        var obj;
        obj = new this.model;
        return "" + BACKEND_BASE + "/" + obj.resourceName + "/";
      };

      SMCollection.prototype.isSet = function() {
        return !this.isEmpty();
      };

      SMCollection.prototype.setFilter = function(key, val) {
        if (!val) {
          if (key in this.filters) {
            delete this.filters[key];
          }
        } else {
          this.filters[key] = val;
        }
        return this;
      };

      SMCollection.prototype.clearFilters = function() {
        return this.filters = {};
      };

      SMCollection.prototype.fetchNext = function(options) {
        var defaults;
        if ((this.fetchState != null) && !this.fetchState.next) {
          return false;
        }
        this.currentPage++;
        defaults = {
          reset: false,
          remove: false
        };
        if (options != null) {
          options = _.extend(options, defaults);
        } else {
          options = defaults;
        }
        return this.fetch(options);
      };

      SMCollection.prototype.fetch = function(options) {
        var error, spinner, success, _ref;
        if (options != null) {
          options = _.clone(options);
        } else {
          options = {};
        }
        if (options.data == null) {
          options.data = {};
        }
        options.data.page = this.currentPage;
        options.data.page_size = this.pageSize;
        if ((_ref = options.spinnerOptions) != null ? _ref.container : void 0) {
          spinner = new SMSpinner(options.spinnerOptions);
          spinner.start();
          success = options.success;
          error = options.error;
          options.success = function(collection, response, options) {
            spinner.stop();
            return typeof success === "function" ? success(collection, response, options) : void 0;
          };
          options.error = function(collection, response, options) {
            spinner.stop();
            return typeof error === "function" ? error(collection, response, options) : void 0;
          };
        }
        delete options.spinnerOptions;
        return SMCollection.__super__.fetch.call(this, options);
      };

      SMCollection.prototype.fetchFields = function(start, end, fields) {
        var filtered, idsToFetch;
        if (!fields) {
          return $.Deferred().resolve().promise();
        }
        filtered = _(this.slice(start, end)).filter((function(_this) {
          return function(m) {
            var field, _i, _len;
            for (_i = 0, _len = fields.length; _i < _len; _i++) {
              field = fields[_i];
              if (m.get(field) === void 0) {
                return true;
              }
            }
            return false;
          };
        })(this));
        idsToFetch = _.pluck(filtered, 'id');
        if (!idsToFetch.length) {
          return $.Deferred().resolve().promise();
        }
        return this.fetch({
          remove: false,
          data: {
            page_size: idsToFetch.length,
            id: idsToFetch.join(','),
            include: fields.join(',')
          }
        });
      };

      SMCollection.prototype.getComparatorKeys = function() {
        return ['default', 'alphabetic', 'alphabetic_reverse'];
      };

      SMCollection.prototype.getComparator = function(key, direction) {
        switch (key) {
          case 'alphabetic':
            return alphabet.makeComparator(direction);
          case 'alphabetic_reverse':
            return alphabet.makeComparator(-1);
          case 'distance':
            return (function(_this) {
              return function(x) {
                return x.getDistanceToLastPosition();
              };
            })(this);
          case 'distance_precalculated':
            return (function(_this) {
              return function(x) {
                return x.get('distance');
              };
            })(this);
          case 'default':
            return (function(_this) {
              return function(x) {
                return -x.get('score');
              };
            })(this);
          case 'accessibility':
            return (function(_this) {
              return function(x) {
                return x.getShortcomingCount();
              };
            })(this);
          default:
            return null;
        }
      };

      SMCollection.prototype.comparatorWrapper = function(fn) {
        if (!fn) {
          return fn;
        }
        if (fn.length === 2) {
          return (function(_this) {
            return function(a, b) {
              return fn(a.getComparisonKey(), b.getComparisonKey());
            };
          })(this);
        } else {
          return fn;
        }
      };

      SMCollection.prototype.setDefaultComparator = function() {
        return this.setComparator(this.getComparatorKeys()[0]);
      };

      SMCollection.prototype.setComparator = function(key, direction) {
        var index;
        index = this.getComparatorKeys().indexOf(key);
        if (index !== -1) {
          this.currentComparator = index;
          this.currentComparatorKey = key;
          return this.comparator = this.comparatorWrapper(this.getComparator(key, direction));
        }
      };

      SMCollection.prototype.cycleComparator = function() {
        if (this.currentComparator == null) {
          this.currentComparator = 0;
        }
        this.currentComparator += 1;
        this.currentComparator %= this.getComparatorKeys().length;
        return this.reSort(this.getComparatorKeys()[this.currentComparator]);
      };

      SMCollection.prototype.reSort = function(key, direction) {
        this.setComparator(key, direction);
        if (this.comparator != null) {
          this.sort();
        }
        return key;
      };

      SMCollection.prototype.getComparatorKey = function() {
        return this.currentComparatorKey;
      };

      SMCollection.prototype.hasReducedPriority = function() {
        return false;
      };

      return SMCollection;

    })(RESTFrameworkCollection);
    Unit = (function(_super) {
      __extends(Unit, _super);

      function Unit() {
        return Unit.__super__.constructor.apply(this, arguments);
      }

      Unit.prototype.resourceName = 'unit';

      Unit.prototype.translatedAttrs = ['name', 'description', 'street_address'];

      Unit.prototype.initialize = function(options) {
        Unit.__super__.initialize.call(this, options);
        this.eventList = new EventList();
        return this.feedbackList = new FeedbackList();
      };

      Unit.prototype.getEvents = function(filters, options) {
        if (filters == null) {
          filters = {};
        }
        if (!('start' in filters)) {
          filters.start = 'today';
        }
        if (!('sort' in filters)) {
          filters.sort = 'start_time';
        }
        filters.location = "tprek:" + (this.get('id'));
        this.eventList.filters = filters;
        if (options == null) {
          options = {
            reset: true
          };
        } else if (!options.reset) {
          options.reset = true;
        }
        return this.eventList.fetch(options);
      };

      Unit.prototype.getFeedback = function(options) {
        this.feedbackList.setFilter('service_object_id', this.id);
        options = options || {};
        _.extend(options, {
          reset: true
        });
        return this.feedbackList.fetch(options);
      };

      Unit.prototype.isDetectedLocation = function() {
        return false;
      };

      Unit.prototype.isPending = function() {
        return false;
      };

      Unit.prototype.otpSerializeLocation = function(opts) {
        var coords;
        if (opts.forceCoordinates) {
          coords = this.get('location').coordinates;
          return "" + coords[1] + "," + coords[0];
        } else {
          return "poi:tprek:" + (this.get('id'));
        }
      };

      Unit.prototype.getSpecifierText = function() {
        var level, service, specifierText, _i, _len, _ref;
        specifierText = '';
        if (this.get('services') == null) {
          return specifierText;
        }
        level = null;
        _ref = this.get('services');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          service = _ref[_i];
          if (!level || service.level < level) {
            specifierText = service.name[p13n.getLanguage()];
            level = service.level;
          }
        }
        return specifierText;
      };

      Unit.prototype.getComparisonKey = function() {
        return p13n.getTranslatedAttr(this.get('name'));
      };

      Unit.prototype.toJSON = function(options) {
        var data, highlights, lang, links, openingHours;
        data = Unit.__super__.toJSON.call(this);
        openingHours = _.filter(this.get('connections'), function(c) {
          return c.section === 'opening_hours' && p13n.getLanguage() in c.name;
        });
        lang = p13n.getLanguage();
        if (openingHours.length > 0) {
          data.opening_hours = _(openingHours).chain().sortBy('type').map((function(_this) {
            return function(hours) {
              var _ref;
              return {
                content: hours.name[lang],
                url: (_ref = hours.www_url) != null ? _ref[lang] : void 0
              };
            };
          })(this)).value();
        }
        highlights = _.filter(this.get('connections'), function(c) {
          return c.section === 'miscellaneous' && p13n.getLanguage() in c.name;
        });
        data.highlights = _.sortBy(highlights, function(c) {
          return c.type;
        });
        links = _.filter(this.get('connections'), function(c) {
          return c.section === 'links' && p13n.getLanguage() in c.name;
        });
        data.links = _.sortBy(links, function(c) {
          return c.type;
        });
        return data;
      };

      Unit.prototype.hasBboxFilter = function() {
        var _ref, _ref1;
        return ((_ref = this.collection) != null ? (_ref1 = _ref.filters) != null ? _ref1.bbox : void 0 : void 0) != null;
      };

      Unit.prototype.hasAccessibilityData = function() {
        var blacklistHits, fn, _ref;
        fn = function(x) {
          var _ref;
          return (_ref = x.id) === 33467 || _ref === 33399;
        };
        blacklistHits = _(this.get('services')).filter(fn).length;
        return ((_ref = this.get('accessibility_properties')) != null ? _ref.length : void 0) && blacklistHits === 0;
      };

      Unit.prototype.getTranslatedShortcomings = function() {
        var profiles, shortcomings, status, _ref;
        profiles = p13n.getAccessibilityProfileIds();
        return _ref = accessibility.getTranslatedShortcomings(profiles, this), status = _ref.status, shortcomings = _ref.results, _ref;
      };

      Unit.prototype.getShortcomingCount = function() {
        var group, shortcomings, __, _ref;
        if (!this.hasAccessibilityData()) {
          return Number.MAX_VALUE;
        }
        shortcomings = this.getTranslatedShortcomings();
        this.shortcomingCount = 0;
        _ref = shortcomings.results;
        for (__ in _ref) {
          group = _ref[__];
          this.shortcomingCount += _.values(group).length;
        }
        return this.shortcomingCount;
      };

      return Unit;

    })(mixOf(SMModel, GeoModel));
    UnitList = (function(_super) {
      __extends(UnitList, _super);

      function UnitList() {
        return UnitList.__super__.constructor.apply(this, arguments);
      }

      UnitList.prototype.model = Unit;

      UnitList.prototype.comparator = null;

      UnitList.prototype.initialize = function(models, opts) {
        UnitList.__super__.initialize.call(this, models, opts);
        return this.forcedPriority = opts != null ? opts.forcedPriority : void 0;
      };

      UnitList.prototype.getComparatorKeys = function() {
        var keys;
        keys = [];
        if (p13n.hasAccessibilityIssues()) {
          keys.push('accessibility');
        }
        if (this.overrideComparatorKeys != null) {
          return _(this.overrideComparatorKeys).union(keys);
        }
        return _(keys).union(['default', 'distance', 'alphabetic', 'alphabetic_reverse']);
      };

      UnitList.prototype.hasReducedPriority = function() {
        var ret, _ref;
        ret = this.forcedPriority ? false : ((_ref = this.filters) != null ? _ref.bbox : void 0) != null;
        return ret;
      };

      return UnitList;

    })(SMCollection);
    Department = (function(_super) {
      __extends(Department, _super);

      function Department() {
        return Department.__super__.constructor.apply(this, arguments);
      }

      Department.prototype.resourceName = 'department';

      Department.prototype.translatedAttrs = ['name'];

      return Department;

    })(SMModel);
    DepartmentList = (function(_super) {
      __extends(DepartmentList, _super);

      function DepartmentList() {
        return DepartmentList.__super__.constructor.apply(this, arguments);
      }

      DepartmentList.prototype.model = Department;

      return DepartmentList;

    })(SMCollection);
    Organization = (function(_super) {
      __extends(Organization, _super);

      function Organization() {
        return Organization.__super__.constructor.apply(this, arguments);
      }

      Organization.prototype.resourceName = 'organization';

      Organization.prototype.translatedAttrs = ['name'];

      return Organization;

    })(SMModel);
    OrganizationList = (function(_super) {
      __extends(OrganizationList, _super);

      function OrganizationList() {
        return OrganizationList.__super__.constructor.apply(this, arguments);
      }

      OrganizationList.prototype.model = Organization;

      return OrganizationList;

    })(SMCollection);
    AdministrativeDivision = (function(_super) {
      __extends(AdministrativeDivision, _super);

      function AdministrativeDivision() {
        return AdministrativeDivision.__super__.constructor.apply(this, arguments);
      }

      AdministrativeDivision.prototype.resourceName = 'administrative_division';

      AdministrativeDivision.prototype.translatedAttrs = ['name'];

      AdministrativeDivision.prototype.getEmergencyCareUnit = function() {
        if (this.get('type') === 'emergency_care_district') {
          switch (this.get('ocd_id')) {
            case 'ocd-division/country:fi/kunta:helsinki/päivystysalue:haartmanin_päivystysalue':
              return 11828;
            case 'ocd-division/country:fi/kunta:helsinki/päivystysalue:marian_päivystysalue':
              return 4060;
            case 'ocd-division/country:fi/kunta:helsinki/päivystysalue:malmin_päivystysalue':
              return 4060;
          }
        }
        return null;
      };

      return AdministrativeDivision;

    })(SMModel);
    AdministrativeDivisionList = (function(_super) {
      __extends(AdministrativeDivisionList, _super);

      function AdministrativeDivisionList() {
        return AdministrativeDivisionList.__super__.constructor.apply(this, arguments);
      }

      AdministrativeDivisionList.prototype.model = AdministrativeDivision;

      return AdministrativeDivisionList;

    })(SMCollection);
    AdministrativeDivisionType = (function(_super) {
      __extends(AdministrativeDivisionType, _super);

      function AdministrativeDivisionType() {
        return AdministrativeDivisionType.__super__.constructor.apply(this, arguments);
      }

      AdministrativeDivisionType.prototype.resourceName = 'administrative_division_type';

      return AdministrativeDivisionType;

    })(SMModel);
    AdministrativeDivisionTypeList = (function(_super) {
      __extends(AdministrativeDivisionTypeList, _super);

      function AdministrativeDivisionTypeList() {
        return AdministrativeDivisionTypeList.__super__.constructor.apply(this, arguments);
      }

      AdministrativeDivisionTypeList.prototype.model = AdministrativeDivision;

      return AdministrativeDivisionTypeList;

    })(SMCollection);
    Service = (function(_super) {
      __extends(Service, _super);

      function Service() {
        return Service.__super__.constructor.apply(this, arguments);
      }

      Service.prototype.resourceName = 'service';

      Service.prototype.translatedAttrs = ['name'];

      Service.prototype.initialize = function() {
        var units;
        this.set('units', new models.UnitList(null, {
          setComparator: true
        }));
        units = this.get('units');
        units.overrideComparatorKeys = ['alphabetic', 'alphabetic_reverse', 'distance'];
        return units.setDefaultComparator();
      };

      Service.prototype.getSpecifierText = function() {
        var ancestor, index, specifierText, _i, _len, _ref;
        specifierText = '';
        if (this.get('ancestors') == null) {
          return specifierText;
        }
        _ref = this.get('ancestors');
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          ancestor = _ref[index];
          if (index > 0) {
            specifierText += ' • ';
          }
          specifierText += ancestor.name[p13n.getLanguage()];
        }
        return specifierText;
      };

      Service.prototype.getComparisonKey = function() {
        return p13n.getTranslatedAttr(this.get('name'));
      };

      return Service;

    })(SMModel);
    Street = (function(_super) {
      __extends(Street, _super);

      function Street() {
        return Street.__super__.constructor.apply(this, arguments);
      }

      Street.prototype.resourceName = 'street';

      Street.prototype.humanAddress = function() {
        var name;
        name = p13n.getTranslatedAttr(this.get('name'));
        return "" + name + ", " + (this.getMunicipalityName());
      };

      Street.prototype.getMunicipalityName = function() {
        return i18n.t("municipality." + (this.get('municipality')));
      };

      return Street;

    })(SMModel);
    StreetList = (function(_super) {
      __extends(StreetList, _super);

      function StreetList() {
        return StreetList.__super__.constructor.apply(this, arguments);
      }

      StreetList.prototype.model = Street;

      return StreetList;

    })(SMCollection);
    Position = (function(_super) {
      __extends(Position, _super);

      function Position() {
        return Position.__super__.constructor.apply(this, arguments);
      }

      Position.prototype.resourceName = 'address';

      Position.prototype.origin = function() {
        return 'clicked';
      };

      Position.prototype.isPending = function() {
        return false;
      };

      Position.prototype.urlRoot = function() {
        return "" + BACKEND_BASE + "/" + this.resourceName;
      };

      Position.prototype.parse = function(response, options) {
        var data, street;
        data = Position.__super__.parse.call(this, response, options);
        street = data.street;
        if (street) {
          data.street = new Street(street);
        }
        return data;
      };

      Position.prototype.isDetectedLocation = function() {
        return false;
      };

      Position.prototype.isReverseGeocoded = function() {
        return this.get('street') != null;
      };

      Position.prototype.getSpecifierText = function() {
        return this.getMunicipalityName();
      };

      Position.prototype.slugifyAddress = function() {
        var SEPARATOR, add, letter, municipality, numberEnd, slug, street;
        SEPARATOR = '-';
        municipality = this.get('street').get('municipality');
        slug = [];
        add = function(x) {
          return slug.push(x);
        };
        street = this.get('street').get('name').fi.toLowerCase().replace(/\ /g, SEPARATOR);
        add(this.get('number'));
        numberEnd = this.get('number_end');
        letter = this.get('letter');
        if (numberEnd) {
          add("" + SEPARATOR + numberEnd);
        }
        if (letter) {
          slug[slug.length - 1] += SEPARATOR + letter;
        }
        this.slug = "" + municipality + "/" + street + "/" + (slug.join(SEPARATOR));
        return this.slug;
      };

      Position.prototype.humanAddress = function(opts) {
        var last, result, street, _ref;
        street = this.get('street');
        result = [];
        if (street != null) {
          result.push(p13n.getTranslatedAttr(street.get('name')));
          result.push(this.humanNumber());
          if (!(opts != null ? (_ref = opts.exclude) != null ? _ref.municipality : void 0 : void 0) && street.get('municipality')) {
            last = result.pop();
            last += ',';
            result.push(last);
            result.push(this.getMunicipalityName());
          }
          return result.join(' ');
        } else {
          return null;
        }
      };

      Position.prototype.getMunicipalityName = function() {
        return this.get('street').getMunicipalityName();
      };

      Position.prototype.getComparisonKey = function(model) {
        var letter, number, result, street, _ref;
        street = this.get('street');
        result = [];
        if (street != null) {
          result.push(i18n.t("municipality." + (street.get('municipality'))));
          _ref = [this.get('number'), this.get('letter')], number = _ref[0], letter = _ref[1];
          result.push(pad(number));
          result.push(letter);
        }
        return result.join('');
      };

      Position.prototype._humanNumber = function() {
        var result;
        result = [];
        if (this.get('number')) {
          result.push(this.get('number'));
        }
        if (this.get('number_end')) {
          result.push('-');
          result.push(this.get('number_end'));
        }
        if (this.get('letter')) {
          result.push(this.get('letter'));
        }
        return result;
      };

      Position.prototype.humanNumber = function() {
        return this._humanNumber().join('');
      };

      Position.prototype.otpSerializeLocation = function(opts) {
        var coords;
        coords = this.get('location').coordinates;
        return "" + coords[1] + "," + coords[0];
      };

      return Position;

    })(mixOf(SMModel, GeoModel));
    AddressList = (function(_super) {
      __extends(AddressList, _super);

      function AddressList() {
        return AddressList.__super__.constructor.apply(this, arguments);
      }

      AddressList.prototype.model = Position;

      return AddressList;

    })(SMCollection);
    CoordinatePosition = (function(_super) {
      __extends(CoordinatePosition, _super);

      function CoordinatePosition() {
        return CoordinatePosition.__super__.constructor.apply(this, arguments);
      }

      CoordinatePosition.prototype.origin = function() {
        if (this.isDetectedLocation()) {
          return 'detected';
        } else {
          return CoordinatePosition.__super__.origin.call(this);
        }
      };

      CoordinatePosition.prototype.initialize = function(attrs) {
        return this.isDetected = (attrs != null ? attrs.isDetected : void 0) != null ? attrs.isDetected : false;
      };

      CoordinatePosition.prototype.isDetectedLocation = function() {
        return this.isDetected;
      };

      CoordinatePosition.prototype.reverseGeocode = function() {
        return withDeferred((function(_this) {
          return function(deferred) {
            var posList;
            if (_this.get('street') == null) {
              posList = models.PositionList.fromPosition(_this);
              return _this.listenTo(posList, 'sync', function() {
                var bestMatch;
                bestMatch = posList.first();
                if (bestMatch.get('distance') > 500) {
                  bestMatch.set('name', i18n.t('map.unknown_address'));
                }
                _this.set(bestMatch.toJSON());
                deferred.resolve();
                return _this.trigger('reverse-geocode');
              });
            }
          };
        })(this));
      };

      CoordinatePosition.prototype.isPending = function() {
        return this.get('location') == null;
      };

      return CoordinatePosition;

    })(Position);
    AddressPosition = (function(_super) {
      __extends(AddressPosition, _super);

      function AddressPosition() {
        return AddressPosition.__super__.constructor.apply(this, arguments);
      }

      AddressPosition.prototype.origin = function() {
        return 'address';
      };

      AddressPosition.prototype.initialize = function(data) {
        if (data == null) {
          return;
        }
        AddressPosition.__super__.initialize.apply(this, arguments);
        return this.set('location', {
          coordinates: data.location.coordinates,
          type: 'Point'
        });
      };

      AddressPosition.prototype.isDetectedLocation = function() {
        return false;
      };

      return AddressPosition;

    })(Position);
    PositionList = (function(_super) {
      __extends(PositionList, _super);

      function PositionList() {
        return PositionList.__super__.constructor.apply(this, arguments);
      }

      PositionList.prototype.resourceName = 'address';

      PositionList.fromPosition = function(position) {
        var instance, location, name, opts, _ref;
        instance = new PositionList();
        name = (_ref = position.get('street')) != null ? _ref.get('name') : void 0;
        location = position.get('location');
        instance.model = Position;
        if (location && !name) {
          instance.fetch({
            data: {
              lat: location.coordinates[1],
              lon: location.coordinates[0]
            }
          });
        } else if (name && !location) {
          opts = {
            data: {
              municipality: position.get('street').get('municipality'),
              number: position.get('number'),
              street: name
            }
          };
          instance.fetch(opts);
        }
        return instance;
      };

      PositionList.fromSlug = function(municipality, streetName, numberPart) {
        var SEPARATOR, number, numberParts, street;
        SEPARATOR = /-/g;
        numberParts = numberPart.split(SEPARATOR);
        number = numberParts[0];
        number = numberPart.replace(/-.*$/, '');
        street = new Street({
          name: streetName.replace(SEPARATOR, ' '),
          municipality: municipality
        });
        return this.fromPosition(new Position({
          street: street,
          number: number
        }));
      };

      PositionList.prototype.getComparatorKeys = function() {
        return ['alphabetic'];
      };

      PositionList.prototype.url = function() {
        return "" + BACKEND_BASE + "/" + this.resourceName + "/";
      };

      return PositionList;

    })(SMCollection);
    RoutingParameters = (function(_super) {
      __extends(RoutingParameters, _super);

      function RoutingParameters() {
        return RoutingParameters.__super__.constructor.apply(this, arguments);
      }

      RoutingParameters.prototype.initialize = function(attributes) {
        this.set('endpoints', (attributes != null ? attributes.endpoints.slice(0) : void 0) || [null, null]);
        this.set('origin_index', (attributes != null ? attributes.origin_index : void 0) || 0);
        this.set('time_mode', (attributes != null ? attributes.time_mode : void 0) || 'depart');
        this.pendingPosition = new CoordinatePosition({
          isDetected: false,
          preventPopup: true
        });
        return this.listenTo(this, 'change:time_mode', function() {
          return this.triggerComplete();
        });
      };

      RoutingParameters.prototype.swapEndpoints = function(opts) {
        this.set('origin_index', this._getDestinationIndex());
        if (!(opts != null ? opts.silent : void 0)) {
          this.trigger('change');
          return this.triggerComplete();
        }
      };

      RoutingParameters.prototype.setOrigin = function(object, opts) {
        var index;
        index = this.get('origin_index');
        this.get('endpoints')[index] = object;
        this.trigger('change');
        if (!(opts != null ? opts.silent : void 0)) {
          return this.triggerComplete();
        }
      };

      RoutingParameters.prototype.setDestination = function(object) {
        this.get('endpoints')[this._getDestinationIndex()] = object;
        this.trigger('change');
        return this.triggerComplete();
      };

      RoutingParameters.prototype.getDestination = function() {
        return this.get('endpoints')[this._getDestinationIndex()];
      };

      RoutingParameters.prototype.getOrigin = function() {
        return this.get('endpoints')[this._getOriginIndex()];
      };

      RoutingParameters.prototype.getEndpointName = function(object) {
        if (object == null) {
          return '';
        } else if (object.isDetectedLocation()) {
          if (object.isPending()) {
            return i18n.t('transit.location_pending');
          } else {
            return i18n.t('transit.current_location');
          }
        } else if (object instanceof CoordinatePosition) {
          return i18n.t('transit.user_picked_location');
        } else if (object instanceof Unit) {
          return object.getText('name');
        } else if (object instanceof Position) {
          return object.humanAddress();
        }
      };

      RoutingParameters.prototype.getEndpointLocking = function(object) {
        return object instanceof models.Unit;
      };

      RoutingParameters.prototype.isComplete = function() {
        var endpoint, _i, _len, _ref;
        _ref = this.get('endpoints');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          endpoint = _ref[_i];
          if (endpoint == null) {
            return false;
          }
          if (endpoint instanceof Position) {
            if (endpoint.isPending()) {
              return false;
            }
          }
        }
        return true;
      };

      RoutingParameters.prototype.ensureUnitDestination = function() {
        if (this.getOrigin() instanceof Unit) {
          return this.swapEndpoints({
            silent: true
          });
        }
      };

      RoutingParameters.prototype.triggerComplete = function() {
        if (this.isComplete()) {
          return this.trigger('complete');
        }
      };

      RoutingParameters.prototype.setTime = function(time, opts) {
        var datetime, m, mt;
        datetime = this.getDatetime();
        mt = moment(time);
        m = moment(datetime);
        m.hours(mt.hours());
        m.minutes(mt.minutes());
        datetime = m.toDate();
        this.set('time', datetime, opts);
        return this.triggerComplete();
      };

      RoutingParameters.prototype.setDate = function(date, opts) {
        var datetime, md;
        datetime = this.getDatetime();
        md = moment(date);
        datetime.setDate(md.date());
        datetime.setMonth(md.month());
        datetime.setYear(md.year());
        this.set('time', datetime, opts);
        return this.triggerComplete();
      };

      RoutingParameters.prototype.setTimeAndDate = function(date) {
        this.setTime(date);
        return this.setDate(date);
      };

      RoutingParameters.prototype.setDefaultDatetime = function() {
        this.set('time', this.getDefaultDatetime());
        return this.triggerComplete();
      };

      RoutingParameters.prototype.clearTime = function() {
        return this.set('time', null);
      };

      RoutingParameters.prototype.getDefaultDatetime = function(currentDatetime) {
        var minutes, mode, time;
        time = moment(new Date());
        mode = this.get('time_mode');
        if (mode === 'depart') {
          return time.toDate();
        }
        time.add(60, 'minutes');
        minutes = time.minutes();
        time.minutes(minutes - minutes % 10 + 10);
        return time.toDate();
      };

      RoutingParameters.prototype.getDatetime = function() {
        var time;
        time = this.get('time');
        if (time == null) {
          time = this.getDefaultDatetime();
        }
        return time;
      };

      RoutingParameters.prototype.isTimeSet = function() {
        return this.get('time') != null;
      };

      RoutingParameters.prototype.setTimeMode = function(timeMode) {
        this.set('time_mode', timeMode);
        return this.triggerComplete();
      };

      RoutingParameters.prototype._getOriginIndex = function() {
        return this.get('origin_index');
      };

      RoutingParameters.prototype._getDestinationIndex = function() {
        return (this._getOriginIndex() + 1) % 2;
      };

      return RoutingParameters;

    })(Backbone.Model);
    Language = (function(_super) {
      __extends(Language, _super);

      function Language() {
        return Language.__super__.constructor.apply(this, arguments);
      }

      return Language;

    })(Backbone.Model);
    LanguageList = (function(_super) {
      __extends(LanguageList, _super);

      function LanguageList() {
        return LanguageList.__super__.constructor.apply(this, arguments);
      }

      LanguageList.prototype.model = Language;

      return LanguageList;

    })(Backbone.Collection);
    ServiceList = (function(_super) {
      __extends(ServiceList, _super);

      function ServiceList() {
        return ServiceList.__super__.constructor.apply(this, arguments);
      }

      ServiceList.prototype.model = Service;

      ServiceList.prototype.initialize = function() {
        ServiceList.__super__.initialize.apply(this, arguments);
        return this.chosenService = null;
      };

      ServiceList.prototype.expand = function(id, spinnerOptions) {
        if (spinnerOptions == null) {
          spinnerOptions = {};
        }
        if (!id) {
          this.chosenService = null;
          return this.fetch({
            data: {
              level: 0
            },
            spinnerOptions: spinnerOptions,
            success: (function(_this) {
              return function() {
                return _this.trigger('finished');
              };
            })(this)
          });
        } else {
          this.chosenService = new Service({
            id: id
          });
          return this.chosenService.fetch({
            success: (function(_this) {
              return function() {
                return _this.fetch({
                  data: {
                    parent: id
                  },
                  spinnerOptions: spinnerOptions,
                  success: function() {
                    return _this.trigger('finished');
                  }
                });
              };
            })(this)
          });
        }
      };

      return ServiceList;

    })(SMCollection);
    SearchList = (function(_super) {
      __extends(SearchList, _super);

      function SearchList() {
        return SearchList.__super__.constructor.apply(this, arguments);
      }

      SearchList.prototype.model = function(attrs, options) {
        var type, typeToModel;
        typeToModel = {
          service: Service,
          unit: Unit,
          address: Position
        };
        type = attrs.object_type;
        if (type in typeToModel) {
          return new typeToModel[type](attrs, options);
        } else {
          Raven.captureException(new Error("Unknown search result type '" + type + "', " + attrs.object_type));
          return new Backbone.Model(attrs, options);
        }
      };

      SearchList.prototype.search = function(query, options) {
        var city, opts;
        this.currentPage = 1;
        this.query = query;
        opts = _.extend({}, options);
        opts.data = {
          q: query,
          language: p13n.getLanguage(),
          only: 'unit.name,service.name,unit.location,unit.root_services',
          include: 'unit.accessibility_properties,service.ancestors,unit.services'
        };
        city = p13n.get('city');
        if (city) {
          opts.data.municipality = city;
        }
        this.fetch(opts);
        return opts;
      };

      SearchList.prototype.url = function() {
        return "" + BACKEND_BASE + "/search/";
      };

      return SearchList;

    })(SMCollection);
    LinkedEventsModel = (function(_super) {
      __extends(LinkedEventsModel, _super);

      function LinkedEventsModel() {
        return LinkedEventsModel.__super__.constructor.apply(this, arguments);
      }

      LinkedEventsModel.prototype.urlRoot = function() {
        return "" + LINKEDEVENTS_BASE + "/" + this.resourceName + "/";
      };

      return LinkedEventsModel;

    })(SMModel);
    LinkedEventsCollection = (function(_super) {
      __extends(LinkedEventsCollection, _super);

      function LinkedEventsCollection() {
        return LinkedEventsCollection.__super__.constructor.apply(this, arguments);
      }

      LinkedEventsCollection.prototype.url = function() {
        var obj;
        obj = new this.model;
        return "" + LINKEDEVENTS_BASE + "/" + obj.resourceName + "/";
      };

      LinkedEventsCollection.prototype.parse = function(resp, options) {
        this.fetchState = {
          count: resp.meta.count,
          next: resp.meta.next,
          previous: resp.meta.previous
        };
        return RESTFrameworkCollection.__super__.parse.call(this, resp.data, options);
      };

      return LinkedEventsCollection;

    })(SMCollection);
    Event = (function(_super) {
      __extends(Event, _super);

      function Event() {
        return Event.__super__.constructor.apply(this, arguments);
      }

      Event.prototype.resourceName = 'event';

      Event.prototype.translatedAttrs = ['name', 'info_url', 'description', 'short_description', 'location_extra_info'];

      Event.prototype.toJSON = function(options) {
        var data;
        data = Event.__super__.toJSON.call(this);
        data.links = _.filter(this.get('external_links'), function(link) {
          return link.language === p13n.getLanguage();
        });
        return data;
      };

      Event.prototype.getUnit = function() {
        var unitId;
        unitId = this.get('location')['@id'].match(/^.*tprek%3A(\d+)/);
        if (unitId == null) {
          return null;
        }
        return new models.Unit({
          id: unitId[1]
        });
      };

      return Event;

    })(LinkedEventsModel);
    EventList = (function(_super) {
      __extends(EventList, _super);

      function EventList() {
        return EventList.__super__.constructor.apply(this, arguments);
      }

      EventList.prototype.model = Event;

      return EventList;

    })(LinkedEventsCollection);
    Open311Model = (function(_super) {
      __extends(Open311Model, _super);

      function Open311Model() {
        return Open311Model.__super__.constructor.apply(this, arguments);
      }

      Open311Model.prototype.sync = function(method, model, options) {
        _.defaults(options, {
          emulateJSON: true,
          data: {
            extensions: true
          }
        });
        return Open311Model.__super__.sync.call(this, method, model, options);
      };

      Open311Model.prototype.resourceNamePlural = function() {
        return "" + this.resourceName + "s";
      };

      Open311Model.prototype.urlRoot = function() {
        return "" + OPEN311_BASE + "/" + (this.resourceNamePlural());
      };

      return Open311Model;

    })(SMModel);
    FeedbackItem = (function(_super) {
      __extends(FeedbackItem, _super);

      function FeedbackItem() {
        return FeedbackItem.__super__.constructor.apply(this, arguments);
      }

      FeedbackItem.prototype.resourceName = 'request';

      FeedbackItem.prototype.url = function() {
        return "" + (this.urlRoot()) + "/" + this.id + ".json";
      };

      FeedbackItem.prototype.parse = function(resp, options) {
        if (resp.length === 1) {
          return FeedbackItem.__super__.parse.call(this, resp[0], options);
        }
        return FeedbackItem.__super__.parse.call(this, resp, options);
      };

      return FeedbackItem;

    })(Open311Model);
    FeedbackItemType = (function(_super) {
      __extends(FeedbackItemType, _super);

      function FeedbackItemType() {
        return FeedbackItemType.__super__.constructor.apply(this, arguments);
      }

      return FeedbackItemType;

    })(Open311Model);
    FeedbackList = (function(_super) {
      __extends(FeedbackList, _super);

      function FeedbackList() {
        return FeedbackList.__super__.constructor.apply(this, arguments);
      }

      FeedbackList.prototype.fetch = function(options) {
        options = options || {};
        _.defaults(options, {
          emulateJSON: true,
          data: {
            extensions: true
          }
        });
        return FeedbackList.__super__.fetch.call(this, options);
      };

      FeedbackList.prototype.model = FeedbackItem;

      FeedbackList.prototype.url = function() {
        var obj;
        obj = new this.model;
        return "" + OPEN311_BASE + "/" + (obj.resourceNamePlural()) + ".json";
      };

      return FeedbackList;

    })(FilterableCollection);
    FeedbackMessage = (function(_super) {
      __extends(FeedbackMessage, _super);

      function FeedbackMessage() {
        return FeedbackMessage.__super__.constructor.apply(this, arguments);
      }

      FeedbackMessage.prototype.initialize = function() {
        this.set('can_be_published', true);
        this.set('service_request_type', 'OTHER');
        return this.set('description', '');
      };

      FeedbackMessage.prototype._serviceCodeFromPersonalisation = function(type) {
        switch (type) {
          case 'hearing_aid':
            return 128;
          case 'visually_impaired':
            return 126;
          case 'wheelchair':
            return 121;
          case 'reduced_mobility':
            return 123;
          case 'rollator':
            return 124;
          case 'stroller':
            return 125;
          default:
            return 11;
        }
      };

      FeedbackMessage.prototype.validate = function(attrs, options) {
        if (attrs.description === '') {
          return {
            description: 'description_required'
          };
        } else if (attrs.description.trim().length < 10) {
          this.set('description', attrs.description);
          return {
            description: 'description_length'
          };
        }
      };

      FeedbackMessage.prototype.serialize = function() {
        var json, service_code, viewpoints;
        json = _.pick(this.toJSON(), 'title', 'first_name', 'description', 'email', 'service_request_type', 'can_be_published');
        viewpoints = this.get('accessibility_viewpoints');
        if (viewpoints != null ? viewpoints.length : void 0) {
          service_code = this._serviceCodeFromPersonalisation(viewpoints[0]);
        } else {
          if (this.get('accessibility_enabled')) {
            service_code = 11;
          } else {
            service_code = 1363;
          }
        }
        json.service_code = service_code;
        json.service_object_id = this.get('unit').get('id');
        json.service_object_type = 'http://www.hel.fi/servicemap/v2';
        return json;
      };

      FeedbackMessage.prototype.sync = function(method, model, options) {
        var json;
        json = this.serialize();
        if (!this.validationError) {
          if (method === 'create') {
            return $.post(this.urlRoot(), this.serialize(), (function(_this) {
              return function() {
                return _this.trigger('sent');
              };
            })(this));
          }
        }
      };

      FeedbackMessage.prototype.urlRoot = function() {
        return OPEN311_WRITE_BASE;
      };

      return FeedbackMessage;

    })(SMModel);
    exports = {
      Unit: Unit,
      Service: Service,
      UnitList: UnitList,
      Department: Department,
      DepartmentList: DepartmentList,
      Organization: Organization,
      OrganizationList: OrganizationList,
      ServiceList: ServiceList,
      AdministrativeDivision: AdministrativeDivision,
      AdministrativeDivisionList: AdministrativeDivisionList,
      AdministrativeDivisionType: AdministrativeDivisionType,
      AdministrativeDivisionTypeList: AdministrativeDivisionTypeList,
      SearchList: SearchList,
      Language: Language,
      LanguageList: LanguageList,
      Event: Event,
      WrappedModel: WrappedModel,
      EventList: EventList,
      RoutingParameters: RoutingParameters,
      Position: Position,
      CoordinatePosition: CoordinatePosition,
      AddressPosition: AddressPosition,
      PositionList: PositionList,
      AddressList: AddressList,
      FeedbackItem: FeedbackItem,
      FeedbackList: FeedbackList,
      FeedbackMessage: FeedbackMessage,
      Street: Street,
      StreetList: StreetList
    };
    window.models = exports;
    return exports;
  });

}).call(this);

//

(function() {
  var SUPPORTED_LANGUAGES, lang, makeMomentLang, momentDeps, p13nDeps,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  SUPPORTED_LANGUAGES = ['fi', 'en', 'sv'];

  makeMomentLang = function(lang) {
    if (lang === 'en') {
      return 'en-gb';
    }
    return lang;
  };

  momentDeps = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = SUPPORTED_LANGUAGES.length; _i < _len; _i++) {
      lang = SUPPORTED_LANGUAGES[_i];
      _results.push("moment/" + (makeMomentLang(lang)));
    }
    return _results;
  })();

  p13nDeps = ['module', 'app/models', 'underscore', 'backbone', 'i18next', 'moment'].concat(momentDeps);

  define(p13nDeps, function(module, models, _, Backbone, i18n, moment) {
    var ACCESSIBILITY_GROUPS, ALLOWED_VALUES, CURRENT_VERSION, DEFAULTS, FALLBACK_LANGUAGES, LANGUAGE_NAMES, LOCALSTORAGE_KEY, PROFILE_IDS, ServiceMapPersonalization, deepExtend;
    LOCALSTORAGE_KEY = 'servicemap_p13n';
    CURRENT_VERSION = 1;
    LANGUAGE_NAMES = {
      fi: 'suomi',
      sv: 'svenska',
      en: 'English'
    };
    FALLBACK_LANGUAGES = ['en', 'fi'];
    ACCESSIBILITY_GROUPS = {
      senses: ['hearing_aid', 'visually_impaired', 'colour_blind'],
      mobility: ['wheelchair', 'reduced_mobility', 'rollator', 'stroller']
    };
    ALLOWED_VALUES = {
      accessibility: {
        mobility: [null, 'wheelchair', 'reduced_mobility', 'rollator', 'stroller']
      },
      transport: ['by_foot', 'bicycle', 'public_transport', 'car'],
      transport_detailed_choices: {
        "public": ['bus', 'tram', 'metro', 'train', 'ferry'],
        bicycle: ['bicycle_parked', 'bicycle_with']
      },
      language: SUPPORTED_LANGUAGES,
      map_background_layer: ['servicemap', 'ortographic', 'guidemap', 'accessible_map'],
      city: [null, 'helsinki', 'espoo', 'vantaa', 'kauniainen']
    };
    PROFILE_IDS = {
      'wheelchair': 1,
      'reduced_mobility': 2,
      'rollator': 3,
      'stroller': 4,
      'visually_impaired': 5,
      'hearing_aid': 6
    };
    DEFAULTS = {
      language: appSettings.default_language,
      first_visit: true,
      skip_tour: false,
      hide_tour: false,
      location_requested: false,
      map_background_layer: 'servicemap',
      accessibility: {
        hearing_aid: false,
        visually_impaired: false,
        colour_blind: false,
        mobility: null
      },
      city: null,
      transport: {
        by_foot: false,
        bicycle: false,
        public_transport: true,
        car: false
      },
      transport_detailed_choices: {
        "public": {
          bus: true,
          tram: true,
          metro: true,
          train: true,
          ferry: true
        },
        bicycle: {
          bicycle_parked: true,
          bicycle_with: false
        }
      }
    };
    deepExtend = function(target, source, allowedValues) {
      var prop, sourceIsObject, targetIsObject, _ref, _results;
      _results = [];
      for (prop in target) {
        if (!(prop in source)) {
          continue;
        }
        sourceIsObject = !!source[prop] && typeof source[prop] === 'object';
        targetIsObject = !!target[prop] && typeof target[prop] === 'object';
        if (targetIsObject !== sourceIsObject) {
          console.error("Value mismatch for " + prop + ": " + (typeof source[prop]) + " vs. " + (typeof target[prop]));
          continue;
        }
        if (targetIsObject) {
          deepExtend(target[prop], source[prop], allowedValues[prop] || {});
          continue;
        }
        if (prop in allowedValues) {
          if (_ref = target[prop], __indexOf.call(allowedValues[prop], _ref) < 0) {
            console.error("Invalid value for " + prop + ": " + target[prop]);
            continue;
          }
        }
        _results.push(target[prop] = source[prop]);
      }
      return _results;
    };
    ServiceMapPersonalization = (function() {
      function ServiceMapPersonalization() {
        this._handleLocationError = __bind(this._handleLocationError, this);
        this._handleLocation = __bind(this._handleLocation, this);
        this.testLocalStorageEnabled = __bind(this.testLocalStorageEnabled, this);
        _.extend(this, Backbone.Events);
        this.attributes = _.clone(DEFAULTS);
        if (module.config().localStorageEnabled === false) {
          this.localStorageEnabled = false;
        } else {
          this.localStorageEnabled = this.testLocalStorageEnabled();
        }
        this._fetch();
        this.deferred = i18n.init({
          lng: this.getLanguage(),
          resGetPath: appSettings.static_path + 'locales/__lng__.json',
          fallbackLng: FALLBACK_LANGUAGES
        });
        i18n.addPostProcessor("fixFinnishStreetNames", function(value, key, options) {
          var REPLACEMENTS, grammaticalCase, replacement, rules, _i, _len;
          REPLACEMENTS = {
            "_allatiivi_": [[/katu$/, "kadulle"], [/polku$/, "polulle"], [/ranta$/, "rannalle"], [/ramppia$/, "rampille"], [/$/, "lle"]],
            "_partitiivi_": [[/tie$/, "tietä"], [/Kehä I/, "Kehä I:tä"], [/Kehä III/, "Kehä III:a"], [/ä$/, "ää"], [/$/, "a"]]
          };
          for (grammaticalCase in REPLACEMENTS) {
            rules = REPLACEMENTS[grammaticalCase];
            if (value.indexOf(grammaticalCase) > -1) {
              for (_i = 0, _len = rules.length; _i < _len; _i++) {
                replacement = rules[_i];
                if (options.street.match(replacement[0])) {
                  options.street = options.street.replace(replacement[0], replacement[1]);
                  return value.replace(grammaticalCase, options.street);
                }
              }
            }
          }
        });
        moment.locale(makeMomentLang(this.getLanguage()));
        window.i18nDebug = i18n;
      }

      ServiceMapPersonalization.prototype.testLocalStorageEnabled = function() {
        var e, val;
        val = '_test';
        try {
          localStorage.setItem(val, val);
          localStorage.removeItem(val);
          return true;
        } catch (_error) {
          e = _error;
          return false;
        }
      };

      ServiceMapPersonalization.prototype._handleLocation = function(pos, positionObject) {
        var cb;
        if (pos.coords.accuracy > 10000) {
          this.trigger('position_error');
          return;
        }
        if (positionObject == null) {
          positionObject = new models.CoordinatePosition({
            isDetected: true
          });
        }
        cb = (function(_this) {
          return function() {
            var coords;
            coords = pos['coords'];
            positionObject.set('location', {
              coordinates: [coords.longitude, coords.latitude]
            });
            positionObject.set('accuracy', pos.coords.accuracy);
            _this.lastPosition = positionObject;
            _this.trigger('position', positionObject);
            if (!_this.get('location_requested')) {
              return _this.set('location_requested', true);
            }
          };
        })(this);
        if (appSettings.user_location_delayed) {
          return setTimeout(cb, 3000);
        } else {
          return cb();
        }
      };

      ServiceMapPersonalization.prototype._handleLocationError = function(error) {
        this.trigger('position_error');
        return this.set('location_requested', false);
      };

      ServiceMapPersonalization.prototype.setVisited = function() {
        return this._setValue(['first_visit'], false);
      };

      ServiceMapPersonalization.prototype.getLastPosition = function() {
        return this.lastPosition;
      };

      ServiceMapPersonalization.prototype.getLocationRequested = function() {
        return this.get('location_requested');
      };

      ServiceMapPersonalization.prototype._setValue = function(path, val) {
        var allowed, dirs, name, oldVal, pathStr, propName, vars, _i, _len;
        pathStr = path.join('.');
        vars = this.attributes;
        allowed = ALLOWED_VALUES;
        dirs = path.slice(0);
        propName = dirs.pop();
        for (_i = 0, _len = dirs.length; _i < _len; _i++) {
          name = dirs[_i];
          if (!(name in vars)) {
            throw new Error("Attempting to set invalid variable name: " + pathStr);
          }
          vars = vars[name];
          if (!allowed) {
            continue;
          }
          if (!(name in allowed)) {
            allowed = null;
            continue;
          }
          allowed = allowed[name];
        }
        if (allowed && propName in allowed) {
          if (__indexOf.call(allowed[propName], val) < 0) {
            throw new Error("Invalid value for " + pathStr + ": " + val);
          }
        } else if (typeof val !== 'boolean') {
          throw new Error("Invalid value for " + pathStr + ": " + val + " (should be boolean)");
        }
        oldVal = vars[propName];
        if (oldVal === val) {
          return;
        }
        vars[propName] = val;
        this._save();
        this.trigger('change', path, val);
        if (path[0] === 'accessibility') {
          this.trigger('accessibility-change');
        }
        return val;
      };

      ServiceMapPersonalization.prototype.toggleMobility = function(val) {
        var oldVal;
        oldVal = this.getAccessibilityMode('mobility');
        if (val === oldVal) {
          return this._setValue(['accessibility', 'mobility'], null);
        } else {
          return this._setValue(['accessibility', 'mobility'], val);
        }
      };

      ServiceMapPersonalization.prototype.toggleAccessibilityMode = function(modeName) {
        var oldVal;
        oldVal = this.getAccessibilityMode(modeName);
        return this._setValue(['accessibility', modeName], !oldVal);
      };

      ServiceMapPersonalization.prototype.setAccessibilityMode = function(modeName, val) {
        return this._setValue(['accessibility', modeName], val);
      };

      ServiceMapPersonalization.prototype.getAccessibilityMode = function(modeName) {
        var accVars;
        accVars = this.get('accessibility');
        if (!modeName in accVars) {
          throw new Error("Attempting to get invalid accessibility mode: " + modeName);
        }
        return accVars[modeName];
      };

      ServiceMapPersonalization.prototype.toggleCity = function(val) {
        var oldVal;
        oldVal = this.get('city');
        if (val === oldVal) {
          val = null;
        }
        return this._setValue(['city'], val);
      };

      ServiceMapPersonalization.prototype.getAllAccessibilityProfileIds = function() {
        var ids, name, rawIds, rid, s, suffixes, _i, _len;
        rawIds = _.invert(PROFILE_IDS);
        ids = {};
        for (rid in rawIds) {
          name = rawIds[rid];
          suffixes = (function() {
            switch (false) {
              case !_.contains(["1", "2", "3"], rid):
                return ['A', 'B', 'C'];
              case !_.contains(["4", "6"], rid):
                return ['A'];
              case "5" !== rid:
                return ['A', 'B'];
            }
          })();
          for (_i = 0, _len = suffixes.length; _i < _len; _i++) {
            s = suffixes[_i];
            ids[rid + s] = name;
          }
        }
        return ids;
      };

      ServiceMapPersonalization.prototype.getAccessibilityProfileIds = function(filterTransit) {
        var accVars, disabilities, disability, ids, key, mobility, transport, val, _i, _len;
        ids = {};
        accVars = this.get('accessibility');
        transport = this.get('transport');
        mobility = accVars['mobility'];
        key = PROFILE_IDS[mobility];
        if (key) {
          if (key === 1 || key === 2 || key === 3 || key === 5) {
            key += transport.car ? 'B' : 'A';
          } else {
            key += 'A';
          }
          ids[key] = mobility;
        }
        disabilities = ['visually_impaired'];
        if (!filterTransit) {
          disabilities.push('hearing_aid');
        }
        for (_i = 0, _len = disabilities.length; _i < _len; _i++) {
          disability = disabilities[_i];
          val = this.getAccessibilityMode(disability);
          if (val) {
            key = PROFILE_IDS[disability];
            if (disability === 'visually_impaired') {
              key += transport.car ? 'B' : 'A';
            } else {
              key += 'A';
            }
            ids[key] = disability;
          }
        }
        return ids;
      };

      ServiceMapPersonalization.prototype.hasAccessibilityIssues = function() {
        var ids;
        ids = this.getAccessibilityProfileIds();
        return _.size(ids) > 0;
      };

      ServiceMapPersonalization.prototype.setTransport = function(modeName, val) {
        var m, modes, otherActive;
        modes = this.get('transport');
        if (val) {
          if (modeName === 'by_foot') {
            for (m in modes) {
              modes[m] = false;
            }
          } else if (modeName === 'car' || modeName === 'bicycle') {
            for (m in modes) {
              if (m === 'public_transport') {
                continue;
              }
              modes[m] = false;
            }
          } else if (modeName === 'public_transport') {
            modes.by_foot = false;
          }
        } else {
          otherActive = false;
          for (m in modes) {
            if (m === modeName) {
              continue;
            }
            if (modes[m]) {
              otherActive = true;
              break;
            }
          }
          if (!otherActive) {
            return;
          }
        }
        return this._setValue(['transport', modeName], val);
      };

      ServiceMapPersonalization.prototype.getTransport = function(modeName) {
        var modes;
        modes = this.get('transport');
        if (!modeName in modes) {
          throw new Error("Attempting to get invalid transport mode: " + modeName);
        }
        return modes[modeName];
      };

      ServiceMapPersonalization.prototype.toggleTransport = function(modeName) {
        var oldVal;
        oldVal = this.getTransport(modeName);
        return this.setTransport(modeName, !oldVal);
      };

      ServiceMapPersonalization.prototype.toggleTransportDetails = function(group, modeName) {
        var oldVal;
        oldVal = this.get('transport_detailed_choices')[group][modeName];
        if (!oldVal) {
          if (modeName === 'bicycle_parked') {
            this.get('transport_detailed_choices')[group].bicycle_with = false;
          }
          if (modeName === 'bicycle_with') {
            this.get('transport_detailed_choices')[group].bicycle_parked = false;
          }
        }
        return this._setValue(['transport_detailed_choices', group, modeName], !oldVal);
      };

      ServiceMapPersonalization.prototype.requestLocation = function(positionModel) {
        var coords, override, posOpts;
        if (appSettings.user_location_override) {
          override = appSettings.user_location_override;
          coords = {
            latitude: override[0],
            longitude: override[1],
            accuracy: 10
          };
          this._handleLocation({
            coords: coords
          });
          return;
        }
        if (!('geolocation' in navigator)) {
          return;
        }
        posOpts = {
          enableHighAccuracy: false,
          timeout: 30000
        };
        return navigator.geolocation.getCurrentPosition(((function(_this) {
          return function(pos) {
            return _this._handleLocation(pos, positionModel);
          };
        })(this)), this._handleLocationError, posOpts);
      };

      ServiceMapPersonalization.prototype.set = function(attr, val) {
        if (!attr in this.attributes) {
          throw new Error("attempting to set invalid attribute: " + attr);
        }
        this.attributes[attr] = val;
        this.trigger('change', attr, val);
        return this._save();
      };

      ServiceMapPersonalization.prototype.get = function(attr) {
        if (!attr in this.attributes) {
          return void 0;
        }
        return this.attributes[attr];
      };

      ServiceMapPersonalization.prototype._verifyValidState = function() {
        var transportModesCount;
        transportModesCount = _.filter(this.get('transport'), _.identity).length;
        if (transportModesCount === 0) {
          return this.setTransport('public_transport', true);
        }
      };

      ServiceMapPersonalization.prototype._fetch = function() {
        var storedAttrs, str;
        if (!this.localStorageEnabled) {
          return;
        }
        str = localStorage.getItem(LOCALSTORAGE_KEY);
        if (!str) {
          return;
        }
        storedAttrs = JSON.parse(str);
        deepExtend(this.attributes, storedAttrs, ALLOWED_VALUES);
        return this._verifyValidState();
      };

      ServiceMapPersonalization.prototype._save = function() {
        var data, str;
        if (!this.localStorageEnabled) {
          return;
        }
        data = _.extend(this.attributes, {
          version: CURRENT_VERSION
        });
        str = JSON.stringify(data);
        return localStorage.setItem(LOCALSTORAGE_KEY, str);
      };

      ServiceMapPersonalization.prototype.getProfileElement = function(name) {
        return {
          icon: "icon-icon-" + (name.replace('_', '-')),
          text: i18n.t("personalisation." + name)
        };
      };

      ServiceMapPersonalization.prototype.getProfileElements = function(profiles) {
        return _.map(profiles, this.getProfileElement);
      };

      ServiceMapPersonalization.prototype.getLanguage = function() {
        return appSettings.default_language;
      };

      ServiceMapPersonalization.prototype.getTranslatedAttr = function(attr) {
        var languages, _i, _len;
        if (!attr) {
          return attr;
        }
        if (!attr instanceof Object) {
          console.error("translated attribute didn't get a translation object", attr);
          return attr;
        }
        languages = [this.getLanguage()].concat(SUPPORTED_LANGUAGES);
        for (_i = 0, _len = languages.length; _i < _len; _i++) {
          lang = languages[_i];
          if (lang in attr) {
            return attr[lang];
          }
        }
        console.error("no supported languages found", attr);
        return null;
      };

      ServiceMapPersonalization.prototype.getSupportedLanguages = function() {
        return _.map(SUPPORTED_LANGUAGES, function(l) {
          return {
            code: l,
            name: LANGUAGE_NAMES[l]
          };
        });
      };

      ServiceMapPersonalization.prototype.getHumanizedDate = function(time) {
        var diff, format, humanize, m, now, s, sod;
        m = moment(time);
        now = moment();
        sod = now.startOf('day');
        diff = m.diff(sod, 'days', true);
        if (diff < -6 || diff >= 7) {
          humanize = false;
        } else {
          humanize = true;
        }
        if (humanize) {
          s = m.calendar();
          s = s.replace(/( (klo|at))* \d{1,2}[:.]\d{1,2}$/, '');
        } else {
          if (now.year() !== m.year()) {
            format = 'L';
          } else {
            format = (function() {
              switch (this.getLanguage()) {
                case 'fi':
                  return 'Do MMMM[ta]';
                case 'en':
                  return 'D MMMM';
                case 'sv':
                  return 'D MMMM';
              }
            }).call(this);
          }
          s = m.format(format);
        }
        return s;
      };

      ServiceMapPersonalization.prototype.setMapBackgroundLayer = function(layerName) {
        return this._setValue(['map_background_layer'], layerName);
      };

      ServiceMapPersonalization.prototype.getMapBackgroundLayers = function() {
        var a;
        return a = _(ALLOWED_VALUES.map_background_layer).chain().union(['accessible_map']).map((function(_this) {
          return function(layerName) {
            return {
              name: layerName,
              selected: _this.get('map_background_layer') === layerName
            };
          };
        })(this)).value();
      };

      return ServiceMapPersonalization;

    })();
    window.p13n = new ServiceMapPersonalization;
    return window.p13n;
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['backbone.marionette', 'URI'], function(Marionette, URI) {
    var BaseRouter;
    return BaseRouter = (function(_super) {
      __extends(BaseRouter, _super);

      function BaseRouter() {
        return BaseRouter.__super__.constructor.apply(this, arguments);
      }

      BaseRouter.prototype.initialize = function(options) {
        BaseRouter.__super__.initialize.call(this, options);
        this.controller = options.controller;
        this.makeMapView = options.makeMapView;
        this.appRoute(/^\/?([^\/]*)$/, 'renderHome');
        this.appRoute(/^unit\/?([^\/]*)$/, 'renderUnit');
        this.appRoute(/^division\/?(.*?)$/, 'renderDivision');
        this.appRoute(/^address\/(.*?)$/, 'renderAddress');
        this.appRoute(/^search(\?[^\/]*)$/, 'renderSearch');
        return this.appRoute(/^division(\?.*?)$/, 'renderMultipleDivisions');
      };

      BaseRouter.prototype.onPostRouteExecute = function() {};

      BaseRouter.prototype.executeRoute = function(callback, args, context) {
        var _ref;
        return callback != null ? (_ref = callback.apply(this, args)) != null ? _ref.done((function(_this) {
          return function(opts) {
            var mapOpts;
            mapOpts = {};
            if (context.query != null) {
              mapOpts.bbox = context.query.bbox;
              mapOpts.level = context.query.level;
            }
            _this.makeMapView(mapOpts);
            if (opts != null) {
              if (typeof opts.afterMapInit === "function") {
                opts.afterMapInit();
              }
            }
            return _this.onPostRouteExecute();
          };
        })(this)) : void 0 : void 0;
      };

      BaseRouter.prototype.processQuery = function(q) {
        if ((q.bbox != null) && q.bbox.match(/([0-9]+\.?[0-9+],)+[0-9]+\.?[0-9+]/)) {
          q.bbox = q.bbox.split(',');
        }
        if ((q.ocd_id != null) && q.ocd_id.match(/([^,]+,)*[^,]+/)) {
          q.ocdId = q.ocd_id.split(',');
          delete q.ocd_id;
        }
        return q;
      };

      BaseRouter.prototype.execute = function(callback, args) {
        var context, fullUri, lastArg, newArgs;
        context = {};
        lastArg = args[args.length - 1];
        fullUri = new URI(window.location.toString());
        if (!(args.length < 1 || lastArg === null)) {
          newArgs = URI(lastArg).segment();
        } else {
          newArgs = [];
        }
        if (fullUri.query()) {
          context.query = this.processQuery(fullUri.search(true));
          if (context.query.map != null) {
            p13n.setMapBackgroundLayer(context.query.map);
          }
          if (context.query.city != null) {
            p13n.set('city', context.query.city);
          }
          newArgs.push(context);
        }
        return this.executeRoute(callback, newArgs, context);
      };

      BaseRouter.prototype.routeEmbedded = function(uri) {
        var callback, path, relativeUri, resource;
        path = uri.segment();
        resource = path[0];
        callback = (function() {
          if (resource === 'division') {
            if ('ocd_id' in uri.search(true)) {
              return 'renderMultipleDivisions';
            } else {
              return 'renderDivision';
            }
          } else {
            switch (resource) {
              case '':
                return 'renderHome';
              case 'unit':
                return 'renderUnit';
              case 'search':
                return 'renderSearch';
              case 'address':
                return 'renderAddress';
            }
          }
        })();
        uri.segment(0, '');
        relativeUri = new URI(uri.pathname() + uri.search());
        callback = _.bind(this.controller[callback], this.controller);
        return this.execute(callback, [relativeUri.toString()]);
      };

      return BaseRouter;

    })(Backbone.Marionette.AppRouter);
  });

}).call(this);

//

(function() {
  define(['backbone', 'typeahead.bundle', 'app/p13n', 'app/settings'], function(Backbone, ta, p13n, settings) {
    var lang, linkedeventsEngine, servicemapEngine;
    lang = p13n.getLanguage();
    servicemapEngine = new Bloodhound({
      name: 'suggestions',
      remote: {
        url: appSettings.service_map_backend + ("/search/?language=" + lang + "&page_size=4&input="),
        replace: (function(_this) {
          return function(url, query) {
            var city;
            url += query;
            city = p13n.get('city');
            if (city) {
              url += "&municipality=" + city;
            }
            return url;
          };
        })(this),
        ajax: settings.applyAjaxDefaults({}),
        filter: function(parsedResponse) {
          return parsedResponse.results;
        },
        rateLimitWait: 50
      },
      datumTokenizer: function(datum) {
        return Bloodhound.tokenizers.whitespace(datum.name[lang]);
      },
      queryTokenizer: Bloodhound.tokenizers.whitespace
    });
    linkedeventsEngine = new Bloodhound({
      name: 'events_suggestions',
      remote: {
        url: appSettings.linkedevents_backend + ("/search/?language=" + lang + "&page_size=4&input=%QUERY"),
        ajax: settings.applyAjaxDefaults({}),
        filter: function(parsedResponse) {
          return parsedResponse.data;
        },
        rateLimitWait: 50
      },
      datumTokenizer: function(datum) {
        return Bloodhound.tokenizers.whitespace(datum.name[lang]);
      },
      queryTokenizer: Bloodhound.tokenizers.whitespace
    });
    servicemapEngine.initialize();
    linkedeventsEngine.initialize();
    return {
      linkedeventsEngine: linkedeventsEngine,
      servicemapEngine: servicemapEngine
    };
  });

}).call(this);

//

(function() {
  define(function() {
    var applyAjaxDefaults, ieVersion;
    ieVersion = getIeVersion();
    applyAjaxDefaults = function(settings) {
      settings.cache = true;
      if (!ieVersion) {
        return settings;
      }
      if (ieVersion >= 10) {
        return settings;
      }
      settings.dataType = 'jsonp';
      settings.data = settings.data || {};
      settings.data.format = 'jsonp';
      return settings;
    };
    return {
      applyAjaxDefaults: applyAjaxDefaults
    };
  });

}).call(this);

//

(function() {
  define(['underscore', 'spin'], function(_, Spinner) {
    var SMSpinner;
    SMSpinner = (function() {
      var DEFAULTS;

      DEFAULTS = {
        lines: 12,
        length: 7,
        width: 5,
        radius: 10,
        rotate: 0,
        corners: 1,
        color: '#000',
        direction: 1,
        speed: 1,
        trail: 100,
        opacity: 1 / 4,
        fps: 20,
        zIndex: 2e9,
        className: 'spinner',
        top: '50%',
        left: '50%',
        position: 'absolute',
        hideContainerContent: false
      };

      function SMSpinner(options) {
        this.options = _.extend(DEFAULTS, options);
        this.container = this.options.container;
        this.finished = false;
      }

      SMSpinner.prototype.start = function() {
        if (this.finished) {
          return;
        }
        if (this.container) {
          if (this.options.hideContainerContent) {
            $(this.container).children().css('visibility', 'hidden');
          }
          return this.spinner = new Spinner(this.options).spin(this.container);
        }
      };

      SMSpinner.prototype.stop = function() {
        this.finished = true;
        if (this.container && this.spinner) {
          this.spinner.stop();
          if (this.options.hideContainerContent) {
            return $(this.container).children().css('visibility', 'visible');
          }
        }
      };

      return SMSpinner;

    })();
    return SMSpinner;
  });

}).call(this);

//

(function() {
  define(['bootstrap-tour', 'i18next', 'app/jade', 'app/models'], function(_bst, _arg, jade, models) {
    var NUM_STEPS, STEPS, getExamples, t, unit;
    t = _arg.t;
    unit = new models.Unit({
      id: 8215
    });
    STEPS = [
      {
        orphan: true
      }, {
        element: '#navigation-header',
        placement: 'bottom',
        backdrop: true
      }, {
        element: '#search-region',
        placement: 'right',
        backdrop: true,
        onShow: function(tour) {
          var $container, $input;
          $container = $('#search-region');
          $input = $container.find('input');
          $input.typeahead('val', '');
          $input.typeahead('val', 'terve');
          $input.val('terve');
          return $input.click();
        },
        onHide: function() {
          var $container, $input;
          $container = $('#search-region');
          $input = $container.find('input');
          return $input.typeahead('val', '');
        }
      }, {
        element: '#browse-region',
        placement: 'right',
        backdrop: true,
        onShow: function(tour) {
          var $container;
          $container = $('#browse-region');
          return _.defer((function(_this) {
            return function() {
              return $container.click();
            };
          })(this));
        }
      }, {
        element: '.service-hover-color-50003',
        placement: 'right',
        backdrop: true
      }, {
        element: '.leaflet-marker-icon',
        placement: 'bottom',
        backdrop: false,
        onShow: function(tour) {
          return unit.fetch({
            data: {
              include: 'root_services,department,municipality,services'
            },
            success: function() {
              return app.commands.execute('selectUnit', unit);
            }
          });
        }
      }, {
        element: '.route-section',
        placement: 'right',
        backdrop: true,
        onNext: function() {
          return app.commands.execute('clearSelectedUnit');
        }
      }, {
        element: '#personalisation',
        placement: 'left',
        backdrop: true
      }, {
        element: '#personalisation',
        placement: 'left',
        backdrop: true,
        onShow: function() {
          return $('#personalisation .personalisation-button').click();
        },
        onHide: function() {
          return $('#personalisation .ok-button').click();
        }
      }, {
        element: '#service-cart',
        placement: 'left',
        backdrop: true
      }, {
        element: '#language-selector',
        placement: 'left',
        backdrop: true
      }, {
        element: '#persistent-logo .feedback-prompt',
        placement: 'left',
        backdrop: true
      }, {
        onShow: function(tour) {
          app.commands.execute('home');
          p13n.set('skip_tour', true);
          return $('#app-container').one('click', (function(_this) {
            return function() {
              return tour.end();
            };
          })(this));
        },
        onShown: function(tour) {
          var $container, $step;
          $container = $(tour.getStep(tour.getCurrentStep()).container);
          $step = $($container).children();
          $step.attr('tabindex', -1).focus();
          $('.tour-success', $container).on('click', (function(_this) {
            return function(ev) {
              return tour.end();
            };
          })(this));
          return $container.find('a.service').on('click', (function(_this) {
            return function(ev) {
              tour.end();
              return app.commands.execute('addService', new models.Service({
                id: $(ev.currentTarget).data('service')
              }));
            };
          })(this));
        },
        orphan: true
      }
    ];
    NUM_STEPS = STEPS.length;
    getExamples = (function(_this) {
      return function() {
        return [
          {
            key: 'health',
            name: t('tour.examples.health'),
            service: 25002
          }, {
            key: 'beach',
            name: t('tour.examples.beach'),
            service: 33467
          }, {
            key: 'art',
            name: t('tour.examples.art'),
            service: 25658
          }, {
            key: 'glass_recycling',
            name: t('tour.examples.glass_recycling'),
            service: 29475
          }
        ];
      };
    })(this);
    return {
      startTour: function() {
        var i, languages, selected, step, tour, _i, _len;
        selected = p13n.getLanguage();
        languages = _.chain(p13n.getSupportedLanguages()).map((function(_this) {
          return function(l) {
            return l.code;
          };
        })(this)).filter((function(_this) {
          return function(l) {
            return l !== selected;
          };
        })(this)).value();
        tour = new Tour({
          template: function(i, step) {
            step.length = NUM_STEPS - 2;
            step.languages = languages;
            step.first = step.next === 1;
            step.last = step.next === -1;
            if (step.last) {
              step.examples = getExamples();
            }
            return jade.template('tour', step);
          },
          storage: false,
          container: '#tour-region',
          onShown: function(tour) {
            var $step;
            $step = $('#' + this.id);
            return $step.attr('tabindex', -1).focus();
          },
          onEnd: function(tour) {
            p13n.set('skip_tour', true);
            return p13n.trigger('tour-skipped');
          }
        });
        for (i = _i = 0, _len = STEPS.length; _i < _len; i = ++_i) {
          step = STEPS[i];
          step.title = t("tour.steps." + i + ".title");
          step.content = t("tour.steps." + i + ".content");
          tour.addStep(step);
        }
        return tour.start(true);
      }
    };
  });

}).call(this);

//

(function() {
  define(function() {
    var TransitMapMixin, googleColors, hslColors;
    hslColors = {
      walk: '#7a7a7a',
      wait: '#999999',
      1: '#007ac9',
      2: '#00985f',
      3: '#007ac9',
      4: '#007ac9',
      5: '#007ac9',
      6: '#ff6319',
      7: '#00b9e4',
      8: '#007ac9',
      12: '#64be14',
      21: '#007ac9',
      22: '#007ac9',
      23: '#007ac9',
      24: '#007ac9',
      25: '#007ac9',
      36: '#007ac9',
      38: '#007ac9',
      39: '#007ac9'
    };
    googleColors = {
      WALK: hslColors.walk,
      CAR: hslColors.walk,
      BICYCLE: hslColors.walk,
      WAIT: hslColors.wait,
      0: hslColors[2],
      1: hslColors[6],
      2: hslColors[12],
      3: hslColors[5],
      4: hslColors[7],
      109: hslColors[12]
    };
    return TransitMapMixin = (function() {
      function TransitMapMixin() {}

      TransitMapMixin.prototype.initializeTransitMap = function(opts) {
        this.listenTo(opts.route, 'change:plan', (function(_this) {
          return function(route) {
            if (route.has('plan')) {
              return _this.drawItinerary(route);
            } else {
              return _this.clearItinerary();
            }
          };
        })(this));
        if (opts.selectedUnits != null) {
          this.listenTo(opts.selectedUnits, 'reset', this.clearItinerary);
        }
        if (opts.selectedPosition != null) {
          return this.listenTo(opts.selectedPosition, 'change:value', this.clearItinerary);
        }
      };

      TransitMapMixin.prototype.createRouteLayerFromItinerary = function(itinerary) {
        var alert, alertLayer, alertpoly, color, icon, label, lastStop, leg, legs, marker, mins, point, points, polyline, routeIncludesTransit, routeLayer, stop, style, sum, totalWalkingDistance, totalWalkingDuration, walkKms, walkMins, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        routeLayer = L.featureGroup();
        alertLayer = L.featureGroup();
        legs = itinerary.legs;
        sum = function(xs) {
          return _.reduce(xs, (function(x, y) {
            return x + y;
          }), 0);
        };
        totalWalkingDistance = sum((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = legs.length; _i < _len; _i++) {
            leg = legs[_i];
            if (leg.distance && (leg.routeType == null)) {
              _results.push(leg.distance);
            }
          }
          return _results;
        })());
        totalWalkingDuration = sum((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = legs.length; _i < _len; _i++) {
            leg = legs[_i];
            if (leg.distance && (leg.routeType == null)) {
              _results.push(leg.duration);
            }
          }
          return _results;
        })());
        routeIncludesTransit = _.any((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = legs.length; _i < _len; _i++) {
            leg = legs[_i];
            _results.push(leg.routeType != null);
          }
          return _results;
        })());
        mins = Math.ceil(itinerary.duration / 1000 / 60);
        walkMins = Math.ceil(totalWalkingDuration / 1000 / 60);
        walkKms = Math.ceil(totalWalkingDistance / 100) / 10;
        for (_i = 0, _len = legs.length; _i < _len; _i++) {
          leg = legs[_i];
          points = (function() {
            var _j, _len1, _ref, _results;
            _ref = leg.legGeometry.points;
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              point = _ref[_j];
              _results.push(new L.LatLng(point[0], point[1]));
            }
            return _results;
          })();
          color = googleColors[(_ref = leg.routeType) != null ? _ref : leg.mode];
          style = {
            color: color,
            stroke: true,
            fill: false,
            opacity: 0.8
          };
          polyline = new L.Polyline(points, style);
          polyline.on('click', function(e) {
            this._map.fitBounds(polyline.getBounds());
            if (typeof marker !== "undefined" && marker !== null) {
              return marker.openPopup();
            }
          });
          polyline.addTo(routeLayer);
          if (leg.alerts) {
            style = {
              color: '#ff3333',
              opacity: 0.2,
              fillOpacity: 0.4,
              weight: 5,
              clickable: true
            };
            _ref1 = leg.alerts;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              alert = _ref1[_j];
              if (alert.geometry) {
                alertpoly = new L.geoJson(alert.geometry, {
                  style: style
                });
                if (alert.alertDescriptionText) {
                  alertpoly.bindPopup(alert.alertDescriptionText.someTranslation, {
                    closeButton: false
                  });
                }
                alertpoly.addTo(alertLayer);
              }
            }
          }
          if (false) {
            stop = leg.from;
            lastStop = leg.to;
            point = {
              y: stop.lat,
              x: stop.lon
            };
            icon = L.divIcon({
              className: "navigator-div-icon"
            });
            label = "<span style='font-size: 24px;'><img src='static/images/" + google_icons[(_ref2 = leg.routeType) != null ? _ref2 : leg.mode] + "' style='vertical-align: sub; height: 24px'/><span>" + leg.route + "</span></span>";
            marker = L.marker(new L.LatLng(point.y, point.x), {
              icon: icon
            }).addTo(routeLayer).bindPopup("<b>Time: " + (moment(leg.startTime).format("HH:mm")) + "&mdash;" + (moment(leg.endTime).format("HH:mm")) + "</b><br /><b>From:</b> " + (stop.name || "") + "<br /><b>To:</b> " + (lastStop.name || ""));
          }
        }
        return {
          route: routeLayer,
          alerts: alertLayer
        };
      };

      TransitMapMixin.prototype.drawItinerary = function(route) {
        var _ref;
        if (this.routeLayer != null) {
          this.clearItinerary();
        }
        _ref = this.createRouteLayerFromItinerary(route.getSelectedItinerary()), this.routeLayer = _ref.route, this.alertLayer = _ref.alerts;
        this.skipMoveend = true;
        this.map.refitAndAddLayer(this.routeLayer);
        return this.map.addLayer(this.alertLayer);
      };

      TransitMapMixin.prototype.clearItinerary = function() {
        if (this.routeLayer) {
          this.map.removeLayer(this.routeLayer);
          this.map.adapt();
        }
        if (this.alertLayer) {
          this.map.removeLayer(this.alertLayer);
        }
        this.routeLayer = null;
        return this.alertLayer = null;
      };

      return TransitMapMixin;

    })();
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['backbone', 'leaflet'], function(Backbone, L) {
    var Route, createWaitLeg, decodePolyline, exports, modeMap, otpCleanup;
    modeMap = {
      tram: 'TRAM',
      bus: 'BUS',
      metro: 'SUBWAY',
      ferry: 'FERRY',
      train: 'RAIL'
    };
    decodePolyline = function(encoded, dims) {
      var b, dim, i, point, points, result, shift;
      point = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= dims ? _i < dims : _i > dims; i = 0 <= dims ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })();
      i = 0;
      points = (function() {
        var _i, _results;
        _results = [];
        while (i < encoded.length) {
          for (dim = _i = 0; 0 <= dims ? _i < dims : _i > dims; dim = 0 <= dims ? ++_i : --_i) {
            result = 0;
            shift = 0;
            while (true) {
              b = encoded.charCodeAt(i++) - 63;
              result |= (b & 0x1f) << shift;
              shift += 5;
              if (!(b >= 0x20)) {
                break;
              }
            }
            point[dim] += result & 1 ? ~(result >> 1) : result >> 1;
          }
          _results.push(point.slice(0));
        }
        return _results;
      })();
      return points;
    };
    otpCleanup = function(data) {
      var coords, itinerary, last, leg, legs, length, newLegs, points, time, waitTime, x, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      _ref1 = ((_ref = data.plan) != null ? _ref.itineraries : void 0) || [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        itinerary = _ref1[_i];
        legs = itinerary.legs;
        length = legs.length;
        last = length - 1;
        if (!legs[0].routeType && legs[0].startTime !== itinerary.startTime) {
          legs[0].startTime = itinerary.startTime;
          legs[0].duration = legs[0].endTime - legs[0].startTime;
        }
        if (!legs[last].routeType && legs[last].endTime !== itinerary.endTime) {
          legs[last].endTime = itinerary.endTime;
          legs[last].duration = legs[last].endTime - legs[last].startTime;
        }
        newLegs = [];
        time = itinerary.startTime;
        _ref2 = itinerary.legs;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          leg = _ref2[_j];
          points = decodePolyline(leg.legGeometry.points, 2);
          points = (function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = points.length; _k < _len2; _k++) {
              coords = points[_k];
              _results.push((function() {
                var _l, _len3, _results1;
                _results1 = [];
                for (_l = 0, _len3 = coords.length; _l < _len3; _l++) {
                  x = coords[_l];
                  _results1.push(x * 1e-5);
                }
                return _results1;
              })());
            }
            return _results;
          })();
          leg.legGeometry.points = points;
          if (leg.startTime - time > 1000 && leg.routeType === null) {
            waitTime = leg.startTime - time;
            time = leg.endTime;
            leg.startTime -= waitTime;
            leg.endTime -= waitTime;
            newLegs.push(leg);
            newLegs.push(createWaitLeg(leg.endTime, waitTime, _.last(leg.legGeometry.points), leg.to.name));
          } else if (leg.startTime - time > 1000) {
            waitTime = leg.startTime - time;
            time = leg.endTime;
            newLegs.push(createWaitLeg(leg.startTime - waitTime, waitTime, leg.legGeometry.points[0], leg.from.name));
            newLegs.push(leg);
          } else {
            newLegs.push(leg);
            time = leg.endTime;
          }
        }
        itinerary.legs = newLegs;
      }
      return data;
    };
    createWaitLeg = function(startTime, duration, point, placename) {
      var leg;
      leg = {
        mode: "WAIT",
        routeType: null,
        route: "",
        duration: duration,
        startTime: startTime,
        endTime: startTime + duration,
        legGeometry: {
          points: [point]
        },
        from: {
          lat: point[0],
          lon: point[1],
          name: placename
        }
      };
      leg.to = leg.from;
      return leg;
    };
    Route = (function(_super) {
      __extends(Route, _super);

      function Route() {
        return Route.__super__.constructor.apply(this, arguments);
      }

      Route.prototype.initialize = function() {
        this.set('selected_itinerary', 0);
        this.set('plan', null);
        return this.listenTo(this, 'change:selected_itinerary', (function(_this) {
          return function() {
            return _this.trigger('change:plan', _this);
          };
        })(this));
      };

      Route.prototype.abort = function() {
        if (!this.xhr) {
          return;
        }
        this.xhr.abort();
        return this.xhr = null;
      };

      Route.prototype.requestPlan = function(from, to, opts) {
        var args, data, modes;
        opts = opts || {};
        if (this.xhr) {
          this.xhr.abort();
          this.xhr = null;
        }
        modes = ['WALK'];
        if (opts.bicycle) {
          modes = ['BICYCLE'];
        }
        if (opts.car) {
          if (opts.transit) {
            modes = ['CAR_PARK', 'WALK'];
          } else {
            modes = ['CAR'];
          }
        }
        if (opts.transit) {
          modes.push('TRANSIT');
        } else {
          modes = _.union(modes, _(opts.modes).map((function(_this) {
            return function(m) {
              return modeMap[m];
            };
          })(this)));
        }
        data = {
          fromPlace: from,
          toPlace: to,
          mode: modes.join(','),
          numItineraries: 3,
          showIntermediateStops: 'true',
          locale: p13n.getLanguage()
        };
        if (opts.wheelchair) {
          data.wheelchair = true;
        }
        if (opts.walkReluctance) {
          data.walkReluctance = opts.walkReluctance;
        }
        if (opts.walkBoardCost) {
          data.walkBoardCost = opts.walkBoardCost;
        }
        if (opts.walkSpeed) {
          data.walkSpeed = opts.walkSpeed;
        }
        if (opts.minTransferTime) {
          data.minTransferTime = opts.minTransferTime;
        }
        if (opts.date && opts.time) {
          data.date = opts.date;
          data.time = opts.time;
        }
        if (opts.arriveBy) {
          data.arriveBy = true;
        }
        args = {
          dataType: 'json',
          url: appSettings.otp_backend,
          data: data,
          success: (function(_this) {
            return function(data) {
              _this.xhr = null;
              if ('error' in data) {
                _this.trigger('error');
                return;
              }
              data = otpCleanup(data);
              _this.set('selected_itinerary', 0);
              return _this.set('plan', data.plan);
            };
          })(this),
          error: (function(_this) {
            return function() {
              _this.clear();
              return _this.trigger('error');
            };
          })(this)
        };
        return this.xhr = $.ajax(args);
      };

      Route.prototype.getSelectedItinerary = function() {
        return this.get('plan').itineraries[this.get('selected_itinerary')];
      };

      Route.prototype.clear = function() {
        return this.set('plan', null);
      };

      return Route;

    })(Backbone.Model);
    return exports = {
      Route: Route
    };
  });

}).call(this);

//

(function() {
  define(function() {
    var init;
    init = function(locale) {
      var UserVoice;
      if (locale === 'sv') {
        locale = 'sv-SE';
      }
      UserVoice = window.UserVoice || [];
      window.UserVoice = UserVoice;
      (function() {
        var s, uv;
        uv = document.createElement("script");
        uv.type = "text/javascript";
        uv.async = true;
        uv.src = "//widget.uservoice.com/f5qbSk7oBie0rWE0W4ig.js";
        s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(uv, s);
      })();
      return UserVoice.push([
        "set", {
          locale: locale,
          accent_color: "#1964e6",
          trigger_color: "white",
          post_idea_enabled: false,
          smartvote_enabled: false,
          screenshot_enabled: false,
          trigger_background_color: "rgba(46, 49, 51, 0.6)"
        }
      ]);
    };
    return {
      init: init
    };
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/views/base'], function(base) {
    var AccessibilityPersonalisationView;
    return AccessibilityPersonalisationView = (function(_super) {
      __extends(AccessibilityPersonalisationView, _super);

      function AccessibilityPersonalisationView() {
        return AccessibilityPersonalisationView.__super__.constructor.apply(this, arguments);
      }

      AccessibilityPersonalisationView.prototype.className = 'accessibility-personalisation';

      AccessibilityPersonalisationView.prototype.template = 'accessibility-personalisation';

      AccessibilityPersonalisationView.prototype.initialize = function(activeModes) {
        this.activeModes = activeModes;
      };

      AccessibilityPersonalisationView.prototype.serializeData = function() {
        return {
          accessibility_viewpoints: this.activeModes
        };
      };

      return AccessibilityPersonalisationView;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'i18next', 'moment', 'app/accessibility', 'app/accessibility-sentences', 'app/p13n', 'app/views/base'], function(_, i18n, moment, accessibility, accessibilitySentences, p13n, base) {
    var AccessibilityDetailsView, AccessibilityViewpointView;
    AccessibilityViewpointView = (function(_super) {
      __extends(AccessibilityViewpointView, _super);

      function AccessibilityViewpointView() {
        return AccessibilityViewpointView.__super__.constructor.apply(this, arguments);
      }

      AccessibilityViewpointView.prototype.template = 'accessibility-viewpoint-summary';

      AccessibilityViewpointView.prototype.initialize = function(opts) {
        this.filterTransit = (opts != null ? opts.filterTransit : void 0) || false;
        return this.template = this.options.template || this.template;
      };

      AccessibilityViewpointView.prototype.serializeData = function() {
        var profiles;
        profiles = p13n.getAccessibilityProfileIds(this.filterTransit);
        return {
          profile_set: _.keys(profiles).length,
          profiles: p13n.getProfileElements(profiles)
        };
      };

      return AccessibilityViewpointView;

    })(base.SMItemView);
    AccessibilityDetailsView = (function(_super) {
      __extends(AccessibilityDetailsView, _super);

      function AccessibilityDetailsView() {
        return AccessibilityDetailsView.__super__.constructor.apply(this, arguments);
      }

      AccessibilityDetailsView.prototype.className = 'unit-accessibility-details';

      AccessibilityDetailsView.prototype.template = 'unit-accessibility-details';

      AccessibilityDetailsView.prototype.regions = {
        'viewpointRegion': '.accessibility-viewpoint'
      };

      AccessibilityDetailsView.prototype.events = {
        'click #accessibility-collapser': 'toggleCollapse'
      };

      AccessibilityDetailsView.prototype.toggleCollapse = function() {
        this.collapsed = !this.collapsed;
        return true;
      };

      AccessibilityDetailsView.prototype.initialize = function() {
        this.listenTo(p13n, 'change', this.render);
        this.listenTo(accessibility, 'change', this.render);
        this.collapsed = true;
        this.accessibilitySentences = {};
        return accessibilitySentences.fetch({
          id: this.model.id
        }, (function(_this) {
          return function(data) {
            _this.accessibilitySentences = data;
            return _this.render();
          };
        })(this));
      };

      AccessibilityDetailsView.prototype.onRender = function() {
        if (this.model.hasAccessibilityData()) {
          return this.viewpointRegion.show(new AccessibilityViewpointView());
        }
      };

      AccessibilityDetailsView.prototype._calculateSentences = function() {
        return _.object(_.map(this.accessibilitySentences.sentences, (function(_this) {
          return function(sentences, groupId) {
            return [
              p13n.getTranslatedAttr(_this.accessibilitySentences.groups[groupId]), _.map(sentences, function(sentence) {
                return p13n.getTranslatedAttr(sentence);
              })
            ];
          };
        })(this)));
      };

      AccessibilityDetailsView.prototype.serializeData = function() {
        var collapseClasses, details, group, groups, hasData, headerClasses, iconClass, profileSet, profiles, sentenceError, sentenceGroups, shortText, shortcomings, shortcomingsCount, shortcomingsPending, status, __, _ref;
        hasData = this.model.hasAccessibilityData();
        shortcomingsPending = false;
        profiles = p13n.getAccessibilityProfileIds();
        if (_.keys(profiles).length) {
          profileSet = true;
        } else {
          profileSet = false;
          profiles = p13n.getAllAccessibilityProfileIds();
        }
        if (hasData) {
          _ref = this.model.getTranslatedShortcomings(), status = _ref.status, shortcomings = _ref.results;
          shortcomingsPending = status === 'pending';
        } else {
          shortcomings = {};
        }
        shortcomingsCount = 0;
        for (__ in shortcomings) {
          group = shortcomings[__];
          shortcomingsCount += _.values(group).length;
        }
        sentenceGroups = [];
        details = [];
        if ('error' in this.accessibilitySentences) {
          details = null;
          sentenceGroups = null;
          sentenceError = true;
        } else {
          details = this._calculateSentences();
          sentenceGroups = _.map(_.values(this.accessibilitySentences.groups), function(v) {
            return p13n.getTranslatedAttr(v);
          });
          sentenceError = false;
        }
        collapseClasses = [];
        headerClasses = [];
        if (this.collapsed) {
          headerClasses.push('collapsed');
        } else {
          collapseClasses.push('in');
        }
        shortText = '';
        if (_.keys(profiles).length) {
          if (hasData) {
            if (shortcomingsCount) {
              if (profileSet) {
                headerClasses.push('has-shortcomings');
                shortText = i18n.t('accessibility.shortcoming_count', {
                  count: shortcomingsCount
                });
              }
            } else {
              if (shortcomingsPending) {
                headerClasses.push('shortcomings-pending');
                shortText = i18n.t('accessibility.pending');
              } else if (profileSet) {
                headerClasses.push('no-shortcomings');
                shortText = i18n.t('accessibility.no_shortcomings');
              }
            }
          } else {
            groups = this.accessibilitySentences.groups;
            if (!((groups != null) && _(groups).keys().length > 0)) {
              shortText = i18n.t('accessibility.no_data');
            }
          }
        }
        iconClass = profileSet ? p13n.getProfileElements(profiles).pop()['icon'] : 'icon-icon-wheelchair';
        return {
          has_data: hasData,
          profile_set: profileSet,
          icon_class: iconClass,
          shortcomings_pending: shortcomingsPending,
          shortcomings_count: shortcomingsCount,
          shortcomings: shortcomings,
          groups: sentenceGroups,
          details: details,
          sentence_error: sentenceError,
          header_classes: headerClasses.join(' '),
          collapse_classes: collapseClasses.join(' '),
          short_text: shortText,
          feedback: this.getDummyFeedback()
        };
      };

      AccessibilityDetailsView.prototype.getDummyFeedback = function() {
        var feedback, lastMonth, now, yesterday;
        now = new Date();
        yesterday = new Date(now.setDate(now.getDate() - 1));
        lastMonth = new Date(now.setMonth(now.getMonth() - 1));
        feedback = [];
        feedback.push({
          time: moment(yesterday).calendar(),
          profile: 'wheelchair user.',
          header: 'The ramp is too steep',
          content: "The ramp is just bad! It's not connected to the entrance stand out clearly. Outside the door there is sufficient room for moving e.g. with a wheelchair. The door opens easily manually."
        });
        feedback.push({
          time: moment(lastMonth).calendar(),
          profile: 'rollator user',
          header: 'Not accessible at all and the staff are unhelpful!!!!',
          content: "The ramp is just bad! It's not connected to the entrance stand out clearly. Outside the door there is sufficient room for moving e.g. with a wheelchair. The door opens easily manually."
        });
        return feedback;
      };

      AccessibilityDetailsView.prototype.leaveFeedbackOnAccessibility = function(event) {
        return event.preventDefault();
      };

      return AccessibilityDetailsView;

    })(base.SMLayout);
    return {
      AccessibilityDetailsView: AccessibilityDetailsView,
      AccessibilityViewpointView: AccessibilityViewpointView
    };
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['backbone.marionette', 'app/jade', 'app/base'], function(Marionette, jade, _arg) {
    var KeyboardHandlerMixin, SMCollectionView, SMItemView, SMLayout, SMTemplateMixin, mixOf;
    mixOf = _arg.mixOf;
    SMTemplateMixin = (function() {
      function SMTemplateMixin() {}

      SMTemplateMixin.prototype.mixinTemplateHelpers = function(data) {
        jade.mixinHelpers(data);
        return data;
      };

      SMTemplateMixin.prototype.getTemplate = function() {
        return jade.getTemplate(this.template);
      };

      return SMTemplateMixin;

    })();
    KeyboardHandlerMixin = (function() {
      function KeyboardHandlerMixin() {
        this.keyboardHandler = __bind(this.keyboardHandler, this);
      }

      KeyboardHandlerMixin.prototype.keyboardHandler = function(callback, keys) {
        var codes, handle;
        codes = _(keys).map((function(_this) {
          return function(key) {
            switch (key) {
              case 'enter':
                return 13;
              case 'space':
                return 32;
            }
          };
        })(this));
        handle = _.bind(callback, this);
        return (function(_this) {
          return function(event) {
            var _ref;
            event.stopPropagation();
            if (_ref = event.which, __indexOf.call(codes, _ref) >= 0) {
              return handle(event);
            }
          };
        })(this);
      };

      return KeyboardHandlerMixin;

    })();
    return {
      SMItemView: SMItemView = (function(_super) {
        __extends(SMItemView, _super);

        function SMItemView() {
          return SMItemView.__super__.constructor.apply(this, arguments);
        }

        return SMItemView;

      })(mixOf(Marionette.ItemView, SMTemplateMixin, KeyboardHandlerMixin)),
      SMCollectionView: SMCollectionView = (function(_super) {
        __extends(SMCollectionView, _super);

        function SMCollectionView() {
          return SMCollectionView.__super__.constructor.apply(this, arguments);
        }

        return SMCollectionView;

      })(mixOf(Marionette.CollectionView, SMTemplateMixin, KeyboardHandlerMixin)),
      SMLayout: SMLayout = (function(_super) {
        __extends(SMLayout, _super);

        function SMLayout() {
          return SMLayout.__super__.constructor.apply(this, arguments);
        }

        return SMLayout;

      })(mixOf(Marionette.Layout, SMTemplateMixin, KeyboardHandlerMixin))
    };
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/views/base'], function(base) {
    var ContextMenuCollectionView, ContextMenuView, ToolMenuItem;
    ToolMenuItem = (function(_super) {
      __extends(ToolMenuItem, _super);

      function ToolMenuItem() {
        return ToolMenuItem.__super__.constructor.apply(this, arguments);
      }

      ToolMenuItem.prototype.className = 'context-menu-item';

      ToolMenuItem.prototype.tagName = 'li';

      ToolMenuItem.prototype.template = 'context-menu-item';

      ToolMenuItem.prototype.initialize = function(opts) {
        ToolMenuItem.__super__.initialize.call(this, opts);
        return this.$el.on('click', this.model.get('action'));
      };

      return ToolMenuItem;

    })(base.SMItemView);
    ContextMenuCollectionView = (function(_super) {
      __extends(ContextMenuCollectionView, _super);

      function ContextMenuCollectionView() {
        return ContextMenuCollectionView.__super__.constructor.apply(this, arguments);
      }

      ContextMenuCollectionView.prototype.className = 'context-menu';

      ContextMenuCollectionView.prototype.tagName = 'ul';

      ContextMenuCollectionView.prototype.itemView = ToolMenuItem;

      return ContextMenuCollectionView;

    })(base.SMCollectionView);
    ContextMenuView = (function(_super) {
      __extends(ContextMenuView, _super);

      function ContextMenuView() {
        return ContextMenuView.__super__.constructor.apply(this, arguments);
      }

      ContextMenuView.prototype.className = 'context-menu-wrapper';

      ContextMenuView.prototype.template = 'context-menu-wrapper';

      ContextMenuView.prototype.initialize = function(opts) {
        this.opts = opts;
      };

      ContextMenuView.prototype.regions = {
        contents: '.contents'
      };

      ContextMenuView.prototype.onRender = function() {
        return this.contents.show(new ContextMenuCollectionView(this.opts));
      };

      return ContextMenuView;

    })(base.SMLayout);
    return ContextMenuView;
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/p13n', 'app/jade', 'app/views/base', 'URI'], function(p13n, jade, base, URI) {
    var TitleView;
    return TitleView = (function(_super) {
      __extends(TitleView, _super);

      function TitleView() {
        this.render = __bind(this.render, this);
        return TitleView.__super__.constructor.apply(this, arguments);
      }

      TitleView.prototype.initialize = function(_arg) {
        this.href = _arg.href;
      };

      TitleView.prototype.className = 'title-control';

      TitleView.prototype.render = function() {
        this.el.innerHTML = jade.template('embedded-title', {
          lang: p13n.getLanguage(),
          href: this.href
        });
        return this.el;
      };

      return TitleView;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/dateformat', 'app/views/base'], function(dateformat, base) {
    var EventDetailsView;
    return EventDetailsView = (function(_super) {
      __extends(EventDetailsView, _super);

      function EventDetailsView() {
        return EventDetailsView.__super__.constructor.apply(this, arguments);
      }

      EventDetailsView.prototype.id = 'event-view-container';

      EventDetailsView.prototype.className = 'navigation-element';

      EventDetailsView.prototype.template = 'event';

      EventDetailsView.prototype.events = {
        'click .back-button': 'goBack',
        'click .sp-name a': 'goBack'
      };

      EventDetailsView.prototype.type = 'event';

      EventDetailsView.prototype.initialize = function(options) {
        this.embedded = options.embedded;
        return this.servicePoint = this.model.get('unit');
      };

      EventDetailsView.prototype.serializeData = function() {
        var data, endTime, startTime;
        data = this.model.toJSON();
        data.embedded_mode = this.embedded;
        startTime = this.model.get('start_time');
        endTime = this.model.get('end_time');
        data.datetime = dateformat.humanizeEventDatetime(startTime, endTime, 'large');
        if (this.servicePoint != null) {
          data.sp_name = this.servicePoint.get('name');
          data.sp_url = this.servicePoint.get('www_url');
          data.sp_phone = this.servicePoint.get('phone');
        } else {
          data.sp_name = this.model.get('location_extra_info');
          data.prevent_back = true;
        }
        return data;
      };

      EventDetailsView.prototype.goBack = function(event) {
        event.preventDefault();
        app.commands.execute('clearSelectedEvent');
        return app.commands.execute('selectUnit', this.servicePoint);
      };

      return EventDetailsView;

    })(base.SMLayout);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'URI', 'backbone', 'app/views/base', 'app/views/context-menu', 'app/p13n', 'i18next'], function(_, URI, Backbone, base, ContextMenu, p13n, i18n) {
    var ExportingView;
    return ExportingView = (function(_super) {
      __extends(ExportingView, _super);

      function ExportingView() {
        return ExportingView.__super__.constructor.apply(this, arguments);
      }

      ExportingView.prototype.template = 'exporting';

      ExportingView.prototype.regions = {
        exportingContext: '#exporting-context'
      };

      ExportingView.prototype.events = {
        'click': 'openMenu'
      };

      ExportingView.prototype.openMenu = function(ev) {
        var menu, models;
        ev.preventDefault();
        ev.stopPropagation();
        if (this.exportingContext.currentView != null) {
          this.exportingContext.reset();
          return;
        }
        models = [
          new Backbone.Model({
            name: i18n.t('tools.embed_action'),
            action: _.bind(this.exportEmbed, this)
          })
        ];
        menu = new ContextMenu({
          collection: new Backbone.Collection(models)
        });
        this.exportingContext.show(menu);
        return $(document).one('click', (function(_this) {
          return function(ev) {
            return _this.exportingContext.reset();
          };
        })(this));
      };

      ExportingView.prototype.exportEmbed = function(ev) {
        var background, city, directory, query, url;
        url = URI(window.location.href);
        directory = url.directory();
        directory = '/embedder' + directory;
        url.directory(directory);
        url.port('');
        query = url.search(true);
        query.bbox = this.getMapBoundsBbox();
        city = p13n.get('city');
        if (city != null) {
          query.city = city;
        }
        background = p13n.get('map_background_layer');
        if (background !== 'servicemap' && background !== 'guidemap') {
          query.map = background;
        }
        query.ratio = parseInt(100 * window.innerHeight / window.innerWidth);
        url.search(query);
        return window.location.href = url.toString();
      };

      ExportingView.prototype.getMapBoundsBbox = function() {
        var rightBbox, wrongBbox, __you_shouldnt_access_me_like_this;
        __you_shouldnt_access_me_like_this = window.mapView.map;
        wrongBbox = __you_shouldnt_access_me_like_this._originalGetBounds().toBBoxString().split(',');
        rightBbox = _.map([1, 0, 3, 2], function(i) {
          return wrongBbox[i].slice(0, 8);
        });
        return rightBbox.join(',');
      };

      ExportingView.prototype.render = function() {
        ExportingView.__super__.render.call(this);
        return this.el;
      };

      return ExportingView;

    })(base.SMLayout);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/views/base', 'app/tour'], function(base, tour) {
    var TourStartButton;
    return TourStartButton = (function(_super) {
      __extends(TourStartButton, _super);

      function TourStartButton() {
        return TourStartButton.__super__.constructor.apply(this, arguments);
      }

      TourStartButton.prototype.className = 'feature-tour-start';

      TourStartButton.prototype.template = 'feature-tour-start';

      TourStartButton.prototype.events = {
        'click .close-button': 'hideTour',
        'click .prompt-button': 'showTour'
      };

      TourStartButton.prototype.hideTour = function(ev) {
        p13n.set('hide_tour', true);
        this.trigger('close');
        return ev.stopPropagation();
      };

      TourStartButton.prototype.showTour = function(ev) {
        tour.startTour();
        return this.trigger('close');
      };

      return TourStartButton;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/views/base'], function(base) {
    var FeedbackConfirmationView;
    return FeedbackConfirmationView = (function(_super) {
      __extends(FeedbackConfirmationView, _super);

      function FeedbackConfirmationView() {
        return FeedbackConfirmationView.__super__.constructor.apply(this, arguments);
      }

      FeedbackConfirmationView.prototype.template = 'feedback-confirmation';

      FeedbackConfirmationView.prototype.className = 'content modal-dialog';

      FeedbackConfirmationView.prototype.events = {
        'click .ok-button': '_close'
      };

      FeedbackConfirmationView.prototype.initialize = function(unit) {
        this.unit = unit;
      };

      FeedbackConfirmationView.prototype.serializeData = function() {
        return {
          unit: this.unit.toJSON()
        };
      };

      FeedbackConfirmationView.prototype._close = function() {
        return app.commands.execute('closeFeedback');
      };

      return FeedbackConfirmationView;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'app/views/base', 'app/views/accessibility-personalisation', 'i18next'], function(_, base, AccessibilityPersonalisationView, _arg) {
    var FeedbackFormView, t;
    t = _arg.t;
    return FeedbackFormView = (function(_super) {
      __extends(FeedbackFormView, _super);

      function FeedbackFormView() {
        return FeedbackFormView.__super__.constructor.apply(this, arguments);
      }

      FeedbackFormView.prototype.template = 'feedback-form';

      FeedbackFormView.prototype.className = 'content modal-dialog';

      FeedbackFormView.prototype.regions = {
        accessibility: '#accessibility-section'
      };

      FeedbackFormView.prototype.events = {
        'submit': '_submit',
        'change input[type=checkbox]': '_onCheckboxChanged',
        'change input[type=radio]': '_onRadioButtonChanged',
        'click .personalisations li': '_onPersonalisationClick',
        'blur input[type=text]': '_onFormInputBlur',
        'blur input[type=email]': '_onFormInputBlur',
        'blur textarea': '_onFormInputBlur'
      };

      FeedbackFormView.prototype.initialize = function(_arg1) {
        this.unit = _arg1.unit, this.model = _arg1.model;
      };

      FeedbackFormView.prototype.onRender = function() {
        this._adaptInputWidths(this.$el, 'input[type=text]');
        return this.accessibility.show(new AccessibilityPersonalisationView(this.model.get('accessibility_viewpoints') || []));
      };

      FeedbackFormView.prototype.serializeData = function() {
        var keys, value, values;
        keys = ['title', 'first_name', 'description', 'email', 'accessibility_viewpoints', 'can_be_published', 'service_request_type'];
        value = (function(_this) {
          return function(key) {
            return _this.model.get(key) || '';
          };
        })(this);
        values = _.object(keys, _(keys).map(value));
        values.accessibility_enabled = this.model.get('accessibility_enabled') || false;
        values.email_enabled = this.model.get('email_enabled') || false;
        values.unit = this.unit.toJSON();
        return values;
      };

      FeedbackFormView.prototype._adaptInputWidths = function($el, selector) {
        return _.defer((function(_this) {
          return function() {
            $el.find(selector).each(function() {
              var pos, width;
              pos = $(this).position().left;
              width = 440;
              width -= pos;
              return $(this).css('width', "" + width + "px");
            });
            return $el.find('textarea').each(function() {
              return $(this).css('width', "460px");
            });
          };
        })(this));
      };

      FeedbackFormView.prototype._submit = function(ev) {
        ev.preventDefault();
        this.model.set('unit', this.unit);
        return this.model.save();
      };

      FeedbackFormView.prototype._onCheckboxChanged = function(ev) {
        var $hiddenSection, checked, target;
        target = ev.currentTarget;
        checked = target.checked;
        $hiddenSection = $(target).closest('.form-section').find('.hidden-section');
        if (checked) {
          $hiddenSection.removeClass('hidden');
          this._adaptInputWidths($hiddenSection, 'input[type=email]');
        } else {
          $hiddenSection.addClass('hidden');
        }
        return this._setModelField(this._getModelFieldId($(target)), checked);
      };

      FeedbackFormView.prototype._onRadioButtonChanged = function(ev) {
        var $target, attrName, name, value;
        $target = $(ev.currentTarget);
        name = $target.attr('name');
        value = $target.val();
        return this.model.set(this._getModelFieldId($target, attrName = 'name'), value);
      };

      FeedbackFormView.prototype._onFormInputBlur = function(ev) {
        var $container, $target, contents, error, id, success;
        $target = $(ev.currentTarget);
        contents = $target.val();
        id = this._getModelFieldId($target);
        success = this._setModelField(id, contents);
        $container = $target.closest('.form-section').find('.validation-error');
        if (success) {
          return $container.addClass('hidden');
        } else {
          error = this.model.validationError;
          $container.html(t("feedback.form.validation." + error[id]));
          return $container.removeClass('hidden');
        }
      };

      FeedbackFormView.prototype._getModelFieldId = function($target, attrName) {
        var TypeError;
        if (attrName == null) {
          attrName = 'id';
        }
        try {
          return $target.attr(attrName).replace(/open311-/, '');
        } catch (_error) {
          TypeError = _error;
          return null;
        }
      };

      FeedbackFormView.prototype._setModelField = function(id, val) {
        return this.model.set(id, val, {
          validate: true
        });
      };

      FeedbackFormView.prototype._onPersonalisationClick = function(ev) {
        var $target, type;
        $target = $(ev.currentTarget);
        type = $target.data('type');
        $target.closest('#accessibility-section').find('li').removeClass('selected');
        $target.addClass('selected');
        return this.model.set('accessibility_viewpoints', [type]);
      };

      return FeedbackFormView;

    })(base.SMLayout);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'app/models', 'app/views/base'], function(_, models, base) {
    var LanguageSelectorView;
    return LanguageSelectorView = (function(_super) {
      __extends(LanguageSelectorView, _super);

      function LanguageSelectorView() {
        return LanguageSelectorView.__super__.constructor.apply(this, arguments);
      }

      LanguageSelectorView.prototype.template = 'language-selector';

      LanguageSelectorView.prototype.languageSubdomain = {
        fi: 'palvelukartta',
        sv: 'servicekarta',
        en: 'servicemap'
      };

      LanguageSelectorView.prototype.initialize = function(opts) {
        this.p13n = opts.p13n;
        this.languages = this.p13n.getSupportedLanguages();
        this.refreshCollection();
        return this.listenTo(p13n, 'url', (function(_this) {
          return function() {
            return _this.render();
          };
        })(this));
      };

      LanguageSelectorView.prototype.selectLanguage = function(ev) {
        var l;
        l = $(ev.currentTarget).data('language');
        return window.location.reload();
      };

      LanguageSelectorView.prototype._replaceUrl = function(withWhat) {
        var href;
        href = window.location.href;
        if (href.match(/^http[s]?:\/\/[^.]+\.hel\..*/)) {
          return href.replace(/\/\/[^.]+./, "//" + withWhat + ".");
        } else {
          return href;
        }
      };

      LanguageSelectorView.prototype.serializeData = function() {
        var data, i, val, _ref;
        data = LanguageSelectorView.__super__.serializeData.call(this);
        _ref = data.items;
        for (i in _ref) {
          val = _ref[i];
          val.link = this._replaceUrl(this.languageSubdomain[val.code]);
        }
        return data;
      };

      LanguageSelectorView.prototype.refreshCollection = function() {
        var languageModels, selected;
        selected = this.p13n.getLanguage();
        languageModels = _.map(this.languages, function(l) {
          return new models.Language({
            code: l.code,
            name: l.name,
            selected: l.code === selected
          });
        });
        return this.collection = new models.LanguageList(_.filter(languageModels, function(l) {
          return !l.get('selected');
        }));
      };

      return LanguageSelectorView;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/views/base'], function(base) {
    var LocationRefreshButtonView;
    return LocationRefreshButtonView = (function(_super) {
      __extends(LocationRefreshButtonView, _super);

      function LocationRefreshButtonView() {
        return LocationRefreshButtonView.__super__.constructor.apply(this, arguments);
      }

      LocationRefreshButtonView.prototype.template = 'location-refresh-button';

      LocationRefreshButtonView.prototype.events = {
        'click': 'resetPosition'
      };

      LocationRefreshButtonView.prototype.resetPosition = function(ev) {
        ev.stopPropagation();
        ev.preventDefault();
        return app.commands.execute('resetPosition');
      };

      LocationRefreshButtonView.prototype.render = function() {
        LocationRefreshButtonView.__super__.render.call(this);
        return this.el;
      };

      return LocationRefreshButtonView;

    })(base.SMLayout);
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/views/base', 'app/views/event-details', 'app/views/service-tree', 'app/views/position-details', 'app/views/unit-details', 'app/views/search-input', 'app/views/search-results', 'app/views/sidebar-region', 'app/map-view'], function(base, EventDetailsView, ServiceTreeView, PositionDetailsView, UnitDetailsView, SearchInputView, _arg, SidebarRegion, MapView) {
    var BrowseButtonView, NavigationHeaderView, NavigationLayout, SearchLayoutView, UnitListLayoutView;
    SearchLayoutView = _arg.SearchLayoutView, UnitListLayoutView = _arg.UnitListLayoutView;
    NavigationLayout = (function(_super) {
      __extends(NavigationLayout, _super);

      function NavigationLayout() {
        this.setMaxHeight = __bind(this.setMaxHeight, this);
        this.updateMaxHeights = __bind(this.updateMaxHeights, this);
        return NavigationLayout.__super__.constructor.apply(this, arguments);
      }

      NavigationLayout.prototype.className = 'service-sidebar';

      NavigationLayout.prototype.template = 'navigation-layout';

      NavigationLayout.prototype.regionType = SidebarRegion;

      NavigationLayout.prototype.regions = {
        header: '#navigation-header',
        contents: '#navigation-contents'
      };

      NavigationLayout.prototype.onShow = function() {
        return this.header.show(new NavigationHeaderView({
          layout: this,
          searchState: this.searchState,
          searchResults: this.searchResults,
          selectedUnits: this.selectedUnits
        }));
      };

      NavigationLayout.prototype.initialize = function(options) {
        this.serviceTreeCollection = options.serviceTreeCollection;
        this.selectedServices = options.selectedServices;
        this.searchResults = options.searchResults;
        this.selectedUnits = options.selectedUnits;
        this.units = options.units;
        this.selectedEvents = options.selectedEvents;
        this.selectedPosition = options.selectedPosition;
        this.searchState = options.searchState;
        this.routingParameters = options.routingParameters;
        this.route = options.route;
        this.breadcrumbs = [];
        this.openViewType = null;
        return this.addListeners();
      };

      NavigationLayout.prototype.addListeners = function() {
        this.listenTo(this.searchResults, 'ready', function() {
          return this.change('search');
        });
        this.listenTo(this.serviceTreeCollection, 'finished', function() {
          this.openViewType = null;
          return this.change('browse');
        });
        this.listenTo(this.selectedServices, 'reset', function(coll, opts) {
          if (!(opts != null ? opts.skip_navigate : void 0)) {
            return this.change('browse');
          }
        });
        this.listenTo(this.selectedPosition, 'change:value', function(w, value) {
          var previous;
          previous = this.selectedPosition.previous('value');
          if (previous != null) {
            this.stopListening(previous);
          }
          if (value != null) {
            this.listenTo(value, 'change:radiusFilter', this.radiusFilterChanged);
          }
          if (this.selectedPosition.isSet()) {
            return this.change('position');
          } else if (this.openViewType === 'position') {
            return this.closeContents();
          }
        });
        this.listenTo(this.selectedServices, 'add', function(service) {
          this.closeContents();
          this.service = service;
          return this.listenTo(this.service.get('units'), 'finished', (function(_this) {
            return function() {
              return _this.change('service-units');
            };
          })(this));
        });
        this.listenTo(this.selectedServices, 'remove', (function(_this) {
          return function(service, coll) {
            if (coll.isEmpty()) {
              if (_this.openViewType === 'service-units') {
                return _this.closeContents();
              }
            } else {
              return _this.change('service-units');
            }
          };
        })(this));
        this.listenTo(this.selectedUnits, 'reset', function(unit, coll, opts) {
          var currentViewType, _ref;
          currentViewType = (_ref = this.contents.currentView) != null ? _ref.type : void 0;
          if (currentViewType === 'details') {
            if (this.searchResults.isEmpty() && this.selectedUnits.isEmpty()) {
              this.closeContents();
            }
          }
          if (!this.selectedUnits.isEmpty()) {
            return this.change('details');
          }
        });
        this.listenTo(this.selectedUnits, 'remove', function(unit, coll, opts) {
          return this.change(null);
        });
        this.listenTo(this.selectedEvents, 'reset', function(unit, coll, opts) {
          if (!this.selectedEvents.isEmpty()) {
            return this.change('event');
          }
        });
        this.contents.on('show', this.updateMaxHeights);
        $(window).resize(this.updateMaxHeights);
        return this.listenTo(app.vent, 'landing-page-cleared', this.setMaxHeight);
      };

      NavigationLayout.prototype.updateMaxHeights = function() {
        var currentViewType, _ref;
        this.setMaxHeight();
        currentViewType = (_ref = this.contents.currentView) != null ? _ref.type : void 0;
        return MapView.setMapActiveAreaMaxHeight({
          maximize: !currentViewType || currentViewType === 'search'
        });
      };

      NavigationLayout.prototype.setMaxHeight = function() {
        var $limitedElement, maxHeight;
        $limitedElement = this.$el.find('.limit-max-height');
        if (!$limitedElement.length) {
          return;
        }
        maxHeight = $(window).innerHeight() - $limitedElement.offset().top;
        $limitedElement.css({
          'max-height': maxHeight
        });
        return this.$el.find('.map-active-area').css('padding-bottom', MapView.mapActiveAreaMaxHeight());
      };

      NavigationLayout.prototype.getAnimationType = function(newViewType) {
        var currentViewType, _ref;
        currentViewType = (_ref = this.contents.currentView) != null ? _ref.type : void 0;
        if (currentViewType) {
          switch (currentViewType) {
            case 'event':
              return 'right';
            case 'details':
              switch (newViewType) {
                case 'event':
                  return 'left';
                case 'details':
                  return 'up-and-down';
                default:
                  return 'right';
              }
              break;
            case 'service-tree':
              return this.contents.currentView.animationType || 'left';
          }
        }
        return null;
      };

      NavigationLayout.prototype.closeContents = function() {
        this.change(null);
        this.openViewType = null;
        this.header.currentView.updateClasses(null);
        return MapView.setMapActiveAreaMaxHeight({
          maximize: true
        });
      };

      NavigationLayout.prototype.radiusFilterChanged = function(value) {
        if (value.get('radiusFilter') > 0) {
          return this.listenToOnce(this.units, 'finished', (function(_this) {
            return function() {
              return _this.change('radius');
            };
          })(this));
        }
      };

      NavigationLayout.prototype.change = function(type) {
        var view;
        if (type === 'browse' && this.openViewType === 'browse') {
          return;
        }
        switch (type) {
          case 'browse':
            view = new ServiceTreeView({
              collection: this.serviceTreeCollection,
              selectedServices: this.selectedServices,
              breadcrumbs: this.breadcrumbs
            });
            break;
          case 'radius':
            view = new UnitListLayoutView({
              fullCollection: this.units,
              collectionType: 'radius',
              position: this.selectedPosition.value(),
              resultType: 'unit',
              onlyResultType: true
            });
            break;
          case 'search':
            view = new SearchLayoutView({
              collection: this.searchResults
            });
            break;
          case 'service-units':
            view = new UnitListLayoutView({
              fullCollection: this.units,
              collectionType: 'service',
              resultType: 'unit',
              onlyResultType: true
            });
            break;
          case 'details':
            view = new UnitDetailsView({
              model: this.selectedUnits.first(),
              route: this.route,
              parent: this,
              routingParameters: this.routingParameters,
              searchResults: this.searchResults,
              selectedUnits: this.selectedUnits,
              selectedPosition: this.selectedPosition
            });
            break;
          case 'event':
            view = new EventDetailsView({
              model: this.selectedEvents.first()
            });
            break;
          case 'position':
            view = new PositionDetailsView({
              model: this.selectedPosition.value(),
              route: this.route,
              selectedPosition: this.selectedPosition,
              routingParameters: this.routingParameters
            });
            break;
          default:
            this.opened = false;
            view = null;
            this.contents.reset();
        }
        this.updatePersonalisationButtonClass(type);
        if (view != null) {
          this.contents.show(view, {
            animationType: this.getAnimationType(type)
          });
          this.openViewType = type;
          this.opened = true;
          this.listenToOnce(view, 'user:close', (function(_this) {
            return function(ev) {
              if (type === 'details') {
                if (!_this.selectedServices.isEmpty()) {
                  return _this.change('service-units');
                } else if ('distance' in _this.units.filters) {
                  return _this.change('radius');
                }
              }
            };
          })(this));
        }
        if (type !== 'details') {
          return app.vent.trigger('site-title:change', null);
        }
      };

      NavigationLayout.prototype.updatePersonalisationButtonClass = function(type) {
        if (type === 'browse' || type === 'search' || type === 'details' || type === 'event' || type === 'position') {
          return $('#personalisation').addClass('hidden');
        } else {
          return $('#personalisation').removeClass('hidden');
        }
      };

      return NavigationLayout;

    })(base.SMLayout);
    NavigationHeaderView = (function(_super) {
      __extends(NavigationHeaderView, _super);

      function NavigationHeaderView() {
        return NavigationHeaderView.__super__.constructor.apply(this, arguments);
      }

      NavigationHeaderView.prototype.className = 'container';

      NavigationHeaderView.prototype.template = 'navigation-header';

      NavigationHeaderView.prototype.regions = {
        search: '#search-region',
        browse: '#browse-region'
      };

      NavigationHeaderView.prototype.events = {
        'click .header': 'open',
        'keypress .header': 'toggleOnKeypress',
        'click .action-button.close-button': 'close'
      };

      NavigationHeaderView.prototype.initialize = function(options) {
        this.navigationLayout = options.layout;
        this.searchState = options.searchState;
        this.searchResults = options.searchResults;
        return this.selectedUnits = options.selectedUnits;
      };

      NavigationHeaderView.prototype.onShow = function() {
        var searchInputView;
        searchInputView = new SearchInputView(this.searchState, this.searchResults);
        this.search.show(searchInputView);
        this.listenTo(searchInputView, 'open', (function(_this) {
          return function() {
            _this.updateClasses('search');
            return _this.navigationLayout.updatePersonalisationButtonClass('search');
          };
        })(this));
        return this.browse.show(new BrowseButtonView());
      };

      NavigationHeaderView.prototype._open = function(actionType) {
        this.updateClasses(actionType);
        return this.navigationLayout.change(actionType);
      };

      NavigationHeaderView.prototype.open = function(event) {
        return this._open($(event.currentTarget).data('type'));
      };

      NavigationHeaderView.prototype.toggleOnKeypress = function(event) {
        var isNavigationVisible, target;
        target = $(event.currentTarget).data('type');
        isNavigationVisible = !!$('#navigation-contents').children().length;
        if (event.keyCode !== 13) {
          return;
        }
        if (isNavigationVisible) {
          return this._close(target);
        } else {
          return this._open(target);
        }
      };

      NavigationHeaderView.prototype._close = function(headerType) {
        this.updateClasses(null);
        if (headerType === 'search') {
          this.$el.find('input').val('');
          app.commands.execute('closeSearch');
        }
        if (headerType === 'search' && !this.selectedUnits.isEmpty()) {
          return;
        }
        return this.navigationLayout.closeContents();
      };

      NavigationHeaderView.prototype.close = function(event) {
        var headerType;
        event.preventDefault();
        event.stopPropagation();
        if (!$(event.currentTarget).hasClass('close-button')) {
          return false;
        }
        headerType = $(event.target).closest('.header').data('type');
        return this._close(headerType);
      };

      NavigationHeaderView.prototype.updateClasses = function(opening) {
        var classname;
        classname = "" + opening + "-open";
        if (this.$el.hasClass(classname)) {
          return;
        }
        this.$el.removeClass().addClass('container');
        if (opening != null) {
          return this.$el.addClass(classname);
        }
      };

      return NavigationHeaderView;

    })(base.SMLayout);
    BrowseButtonView = (function(_super) {
      __extends(BrowseButtonView, _super);

      function BrowseButtonView() {
        return BrowseButtonView.__super__.constructor.apply(this, arguments);
      }

      BrowseButtonView.prototype.template = 'navigation-browse';

      return BrowseButtonView;

    })(base.SMItemView);
    return NavigationLayout;
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/p13n', 'app/views/base', 'app/views/accessibility-personalisation'], function(p13n, base, AccessibilityPersonalisationView) {
    var PersonalisationView;
    return PersonalisationView = (function(_super) {
      __extends(PersonalisationView, _super);

      function PersonalisationView() {
        this.setMaxHeight = __bind(this.setMaxHeight, this);
        return PersonalisationView.__super__.constructor.apply(this, arguments);
      }

      PersonalisationView.prototype.className = 'personalisation-container';

      PersonalisationView.prototype.template = 'personalisation';

      PersonalisationView.prototype.regions = {
        accessibility: '#accessibility-personalisation'
      };

      PersonalisationView.prototype.events = function() {
        return {
          'click .personalisation-button': 'personalisationButtonClick',
          'keydown .personalisation-button': this.keyboardHandler(this.personalisationButtonClick, ['space', 'enter']),
          'click .ok-button': 'toggleMenu',
          'keydown .ok-button': this.keyboardHandler(this.toggleMenu, ['space']),
          'click .select-on-map': 'selectOnMap',
          'click .personalisations a': 'switchPersonalisation',
          'keydown .personalisations a': this.keyboardHandler(this.switchPersonalisation, ['space']),
          'click .personalisation-message a': 'openMenuFromMessage',
          'click .personalisation-message .close-button': 'closeMessage'
        };
      };

      PersonalisationView.prototype.personalisationIcons = {
        'city': ['helsinki', 'espoo', 'vantaa', 'kauniainen'],
        'senses': ['hearing_aid', 'visually_impaired', 'colour_blind'],
        'mobility': ['wheelchair', 'reduced_mobility', 'rollator', 'stroller']
      };

      PersonalisationView.prototype.initialize = function() {
        $(window).resize(this.setMaxHeight);
        this.listenTo(p13n, 'change', function() {
          this.setActivations();
          return this.renderIconsForSelectedModes();
        });
        return this.listenTo(p13n, 'user:open', function() {
          return this.personalisationButtonClick();
        });
      };

      PersonalisationView.prototype.personalisationButtonClick = function(ev) {
        if (ev != null) {
          ev.preventDefault();
        }
        if (!$('#personalisation').hasClass('open')) {
          return this.toggleMenu(ev);
        }
      };

      PersonalisationView.prototype.toggleMenu = function(ev) {
        if (ev != null) {
          ev.preventDefault();
        }
        return $('#personalisation').toggleClass('open');
      };

      PersonalisationView.prototype.openMenuFromMessage = function(ev) {
        if (ev != null) {
          ev.preventDefault();
        }
        this.toggleMenu();
        return this.closeMessage();
      };

      PersonalisationView.prototype.closeMessage = function(ev) {
        return this.$('.personalisation-message').removeClass('open');
      };

      PersonalisationView.prototype.selectOnMap = function(ev) {
        return ev.preventDefault();
      };

      PersonalisationView.prototype.renderIconsForSelectedModes = function() {
        var $container, $icon, group, iconClass, type, types, _ref, _results;
        $container = this.$('.selected-personalisations').empty();
        _ref = this.personalisationIcons;
        _results = [];
        for (group in _ref) {
          types = _ref[group];
          _results.push((function() {
            var _i, _len, _results1;
            _results1 = [];
            for (_i = 0, _len = types.length; _i < _len; _i++) {
              type = types[_i];
              if (this.modeIsActivated(type, group)) {
                if (group === 'city') {
                  iconClass = 'icon-icon-coat-of-arms-' + type.split('_').join('-');
                } else {
                  iconClass = 'icon-icon-' + type.split('_').join('-');
                }
                $icon = $("<span class='" + iconClass + "'></span>");
                _results1.push($container.append($icon));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      };

      PersonalisationView.prototype.modeIsActivated = function(type, group) {
        var activated;
        activated = false;
        if (group === 'city') {
          activated = p13n.get('city') === type;
        } else if (group === 'mobility') {
          activated = p13n.getAccessibilityMode('mobility') === type;
        } else {
          activated = p13n.getAccessibilityMode(type);
        }
        return activated;
      };

      PersonalisationView.prototype.setActivations = function() {
        var $list;
        $list = this.$el.find('.personalisations');
        return $list.find('li').each((function(_this) {
          return function(idx, li) {
            var $button, $li, activated, group, type;
            $li = $(li);
            type = $li.data('type');
            group = $li.data('group');
            $button = $li.find('a[role="button"]');
            activated = _this.modeIsActivated(type, group);
            if (activated) {
              $li.addClass('selected');
            } else {
              $li.removeClass('selected');
            }
            return $button.attr('aria-pressed', activated);
          };
        })(this));
      };

      PersonalisationView.prototype.switchPersonalisation = function(ev) {
        var currentBackground, group, modeIsSet, newBackground, parentLi, type;
        ev.preventDefault();
        parentLi = $(ev.target).closest('li');
        group = parentLi.data('group');
        type = parentLi.data('type');
        if (group === 'mobility') {
          return p13n.toggleMobility(type);
        } else if (group === 'senses') {
          modeIsSet = p13n.toggleAccessibilityMode(type);
          currentBackground = p13n.get('map_background_layer');
          if (type === 'visually_impaired' || type === 'colour_blind') {
            newBackground = null;
            if (modeIsSet) {
              newBackground = 'accessible_map';
            } else if (currentBackground === 'accessible_map') {
              newBackground = 'servicemap';
            }
            if (newBackground) {
              return p13n.setMapBackgroundLayer(newBackground);
            }
          }
        } else if (group === 'city') {
          return p13n.toggleCity(type);
        }
      };

      PersonalisationView.prototype.render = function(opts) {
        PersonalisationView.__super__.render.call(this, opts);
        this.renderIconsForSelectedModes();
        return this.setActivations();
      };

      PersonalisationView.prototype.onRender = function() {
        this.accessibility.show(new AccessibilityPersonalisationView([]));
        return this.setMaxHeight();
      };

      PersonalisationView.prototype.setMaxHeight = function() {
        var maxHeight, offset, personalisationHeaderHeight, windowWidth;
        personalisationHeaderHeight = 56;
        windowWidth = $(window).width();
        offset = 0;
        if (windowWidth >= appSettings.mobile_ui_breakpoint) {
          offset = $('#personalisation').offset().top;
        }
        maxHeight = $(window).innerHeight() - personalisationHeaderHeight - offset;
        return this.$el.find('.personalisation-content').css({
          'max-height': maxHeight
        });
      };

      return PersonalisationView;

    })(base.SMLayout);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['underscore', 'app/models', 'app/map-view', 'app/views/base', 'app/views/route'], function(_, models, MapView, base, RouteView) {
    var DivisionListItemView, DivisionListView, PositionDetailsView, UnitListItemView, UnitListView;
    PositionDetailsView = (function(_super) {
      __extends(PositionDetailsView, _super);

      function PositionDetailsView() {
        return PositionDetailsView.__super__.constructor.apply(this, arguments);
      }

      PositionDetailsView.prototype.type = 'position';

      PositionDetailsView.prototype.id = 'details-view-container';

      PositionDetailsView.prototype.className = 'navigation-element limit-max-height';

      PositionDetailsView.prototype.template = 'position';

      PositionDetailsView.prototype.regions = {
        'areaServices': '.area-services-placeholder',
        'adminDivisions': '.admin-div-placeholder',
        'routeRegion': '.section.route-section'
      };

      PositionDetailsView.prototype.events = {
        'click .map-active-area': 'showMap',
        'click .mobile-header': 'showContent',
        'click .icon-icon-close': 'selfDestruct',
        'click #reset-location': 'resetLocation',
        'click #add-circle': 'addCircle'
      };

      PositionDetailsView.prototype.initialize = function(options) {
        this.selectedPosition = options.selectedPosition;
        this.route = options.route;
        this.parent = options.parent;
        this.routingParameters = options.routingParameters;
        this.sortedDivisions = ['postcode_area', 'neighborhood', 'rescue_district', 'health_station_district', 'maternity_clinic_district', 'income_support_district', 'lower_comprehensive_school_district_fi', 'lower_comprehensive_school_district_sv', 'upper_comprehensive_school_district_fi', 'upper_comprehensive_school_district_sv'];
        this.divList = new models.AdministrativeDivisionList();
        this.listenTo(this.model, 'reverse-geocode', (function(_this) {
          return function() {
            return _this.fetchDivisions().done(function() {
              return _this.render();
            });
          };
        })(this));
        this.divList.comparator = (function(_this) {
          return function(a, b) {
            var indexA, indexB;
            indexA = _.indexOf(_this.sortedDivisions, a.get('type'));
            indexB = _.indexOf(_this.sortedDivisions, b.get('type'));
            if (indexA < indexB) {
              return -1;
            }
            if (indexB < indexA) {
              return 1;
            }
            return 0;
          };
        })(this);
        this.listenTo(this.divList, 'reset', this.renderAdminDivs);
        return this.fetchDivisions().done((function(_this) {
          return function() {
            return _this.render();
          };
        })(this));
      };

      PositionDetailsView.prototype.fetchDivisions = function() {
        var coords;
        coords = this.model.get('location').coordinates;
        return this.divList.fetch({
          data: {
            lon: coords[0],
            lat: coords[1],
            unit_include: 'name,root_services,location',
            type: (_.union(this.sortedDivisions, ['emergency_care_district'])).join(','),
            geometry: 'true'
          },
          reset: true
        });
      };

      PositionDetailsView.prototype.serializeData = function() {
        var data;
        data = PositionDetailsView.__super__.serializeData.call(this);
        data.icon_class = (function() {
          switch (this.model.origin()) {
            case 'address':
              return 'icon-icon-address';
            case 'detected':
              return 'icon-icon-you-are-here';
            case 'clicked':
              return 'icon-icon-address';
          }
        }).call(this);
        data.origin = this.model.origin();
        data.neighborhood = this.divList.findWhere({
          type: 'neighborhood'
        });
        data.name = this.model.humanAddress();
        return data;
      };

      PositionDetailsView.prototype.resetLocation = function() {
        return app.commands.execute('resetPosition', this.model);
      };

      PositionDetailsView.prototype.addCircle = function() {
        return app.commands.execute('setRadiusFilter', 750);
      };

      PositionDetailsView.prototype.onRender = function() {
        this.renderAdminDivs();
        return this.routeRegion.show(new RouteView({
          model: this.model,
          route: this.route,
          parentView: this,
          routingParameters: this.routingParameters,
          selectedUnits: null,
          selectedPosition: this.selectedPosition
        }));
      };

      PositionDetailsView.prototype.renderAdminDivs = function() {
        var divsWithUnits, emergencyDiv, units;
        divsWithUnits = this.divList.filter(function(x) {
          return x.has('unit');
        });
        emergencyDiv = this.divList.find(function(x) {
          return x.get('type') === 'emergency_care_district';
        });
        if (divsWithUnits.length > 0) {
          units = new models.UnitList(divsWithUnits.map(function(x) {
            var unit;
            unit = new models.Unit(x.get('unit'));
            unit.set('area', x);
            if (x.get('type') === 'health_station_district') {
              unit.set('emergencyUnitId', emergencyDiv.getEmergencyCareUnit());
            }
            return unit;
          }));
          this.areaServices.show(new UnitListView({
            collection: units
          }));
          return this.adminDivisions.show(new DivisionListView({
            collection: new models.AdministrativeDivisionList(this.divList.filter((function(_this) {
              return function(x) {
                return x.get('type') !== 'emergency_care_district';
              };
            })(this)))
          }));
        }
      };

      PositionDetailsView.prototype.showMap = function(event) {
        event.preventDefault();
        this.$el.addClass('minimized');
        return MapView.setMapActiveAreaMaxHeight({
          maximize: true
        });
      };

      PositionDetailsView.prototype.showContent = function(event) {
        event.preventDefault();
        this.$el.removeClass('minimized');
        return MapView.setMapActiveAreaMaxHeight({
          maximize: false
        });
      };

      PositionDetailsView.prototype.selfDestruct = function(event) {
        event.stopPropagation();
        return app.commands.execute('clearSelectedPosition');
      };

      return PositionDetailsView;

    })(base.SMLayout);
    DivisionListItemView = (function(_super) {
      __extends(DivisionListItemView, _super);

      function DivisionListItemView() {
        this.initialize = __bind(this.initialize, this);
        this.handleClick = __bind(this.handleClick, this);
        return DivisionListItemView.__super__.constructor.apply(this, arguments);
      }

      DivisionListItemView.prototype.events = {
        'click': 'handleClick'
      };

      DivisionListItemView.prototype.tagName = 'li';

      DivisionListItemView.prototype.template = 'division-list-item';

      DivisionListItemView.prototype.handleClick = function() {
        return app.commands.execute('toggleDivision', this.model);
      };

      DivisionListItemView.prototype.initialize = function() {
        return this.listenTo(this.model, 'change:selected', this.render);
      };

      return DivisionListItemView;

    })(base.SMItemView);
    DivisionListView = (function(_super) {
      __extends(DivisionListView, _super);

      function DivisionListView() {
        return DivisionListView.__super__.constructor.apply(this, arguments);
      }

      DivisionListView.prototype.tagName = 'ul';

      DivisionListView.prototype.className = 'division-list sublist';

      DivisionListView.prototype.itemView = DivisionListItemView;

      return DivisionListView;

    })(base.SMCollectionView);
    UnitListItemView = (function(_super) {
      __extends(UnitListItemView, _super);

      function UnitListItemView() {
        this.handleClick = __bind(this.handleClick, this);
        this.handleInnerClick = __bind(this.handleInnerClick, this);
        return UnitListItemView.__super__.constructor.apply(this, arguments);
      }

      UnitListItemView.prototype.events = {
        'click a': 'handleInnerClick',
        'click': 'handleClick'
      };

      UnitListItemView.prototype.tagName = 'li';

      UnitListItemView.prototype.template = 'unit-list-item';

      UnitListItemView.prototype.serializeData = function() {
        var data;
        data = UnitListItemView.__super__.serializeData.call(this);
        return data;
      };

      UnitListItemView.prototype.handleInnerClick = function(ev) {
        return ev != null ? ev.stopPropagation() : void 0;
      };

      UnitListItemView.prototype.handleClick = function(ev) {
        if (ev != null) {
          ev.preventDefault();
        }
        app.commands.execute('setUnit', this.model);
        return app.commands.execute('selectUnit', this.model);
      };

      return UnitListItemView;

    })(base.SMItemView);
    UnitListView = (function(_super) {
      __extends(UnitListView, _super);

      function UnitListView() {
        return UnitListView.__super__.constructor.apply(this, arguments);
      }

      UnitListView.prototype.tagName = 'ul';

      UnitListView.prototype.className = 'unit-list sublist';

      UnitListView.prototype.itemView = UnitListItemView;

      return UnitListView;

    })(base.SMCollectionView);
    return PositionDetailsView;
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/views/base'], function(base) {
    var RadiusControlsView;
    return RadiusControlsView = (function(_super) {
      __extends(RadiusControlsView, _super);

      function RadiusControlsView() {
        return RadiusControlsView.__super__.constructor.apply(this, arguments);
      }

      RadiusControlsView.prototype.template = 'radius-controls';

      RadiusControlsView.prototype.className = 'radius-controls';

      RadiusControlsView.prototype.events = {
        'change': 'onChange'
      };

      RadiusControlsView.prototype.serializeData = function() {
        return {
          selected: this.selected || 750,
          values: [250, 500, 750, 1000, 2000, 3000, 4000]
        };
      };

      RadiusControlsView.prototype.initialize = function(_arg) {
        this.selected = _arg.radius;
      };

      RadiusControlsView.prototype.onChange = function(ev) {
        this.selected = $(ev.target).val();
        this.render();
        return app.commands.execute('setRadiusFilter', this.selected);
      };

      return RadiusControlsView;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['underscore', 'moment', 'bootstrap-datetimepicker', 'app/p13n', 'app/models', 'app/search', 'app/views/base', 'app/views/accessibility', 'app/geocoding', 'app/jade'], function(_, moment, datetimepicker, p13n, models, search, base, accessibilityViews, geocoding, jade) {
    var RouteControllersView, RouteSettingsHeaderView, RouteSettingsView, TransportModeControlsView;
    RouteSettingsView = (function(_super) {
      __extends(RouteSettingsView, _super);

      function RouteSettingsView() {
        return RouteSettingsView.__super__.constructor.apply(this, arguments);
      }

      RouteSettingsView.prototype.template = 'route-settings';

      RouteSettingsView.prototype.regions = {
        'headerRegion': '.route-settings-header',
        'routeControllersRegion': '.route-controllers',
        'accessibilitySummaryRegion': '.accessibility-viewpoint-part',
        'transportModeControlsRegion': '.transport_mode_controls'
      };

      RouteSettingsView.prototype.initialize = function(attrs) {
        this.unit = attrs.unit;
        return this.listenTo(this.model, 'change', this.updateRegions);
      };

      RouteSettingsView.prototype.onRender = function() {
        this.headerRegion.show(new RouteSettingsHeaderView({
          model: this.model
        }));
        this.routeControllersRegion.show(new RouteControllersView({
          model: this.model,
          unit: this.unit
        }));
        this.accessibilitySummaryRegion.show(new accessibilityViews.AccessibilityViewpointView({
          filterTransit: true,
          template: 'accessibility-viewpoint-oneline'
        }));
        return this.transportModeControlsRegion.show(new TransportModeControlsView);
      };

      RouteSettingsView.prototype.updateRegions = function() {
        this.headerRegion.currentView.render();
        this.accessibilitySummaryRegion.currentView.render();
        return this.transportModeControlsRegion.currentView.render();
      };

      return RouteSettingsView;

    })(base.SMLayout);
    RouteSettingsHeaderView = (function(_super) {
      __extends(RouteSettingsHeaderView, _super);

      function RouteSettingsHeaderView() {
        return RouteSettingsHeaderView.__super__.constructor.apply(this, arguments);
      }

      RouteSettingsHeaderView.prototype.template = 'route-settings-header';

      RouteSettingsHeaderView.prototype.events = {
        'click .settings-summary': 'toggleSettingsVisibility',
        'click .ok-button': 'toggleSettingsVisibility'
      };

      RouteSettingsHeaderView.prototype.serializeData = function() {
        var mode, origin, originName, profiles, transportIcons, value, _ref;
        profiles = p13n.getAccessibilityProfileIds(true);
        origin = this.model.getOrigin();
        originName = this.model.getEndpointName(origin);
        if (((origin != null ? origin.isDetectedLocation() : void 0) && !(origin != null ? origin.isPending() : void 0)) || ((origin != null) && origin instanceof models.CoordinatePosition)) {
          originName = originName.toLowerCase();
        }
        transportIcons = [];
        _ref = p13n.get('transport');
        for (mode in _ref) {
          value = _ref[mode];
          if (value) {
            transportIcons.push("icon-icon-" + (mode.replace('_', '-')));
          }
        }
        return {
          profile_set: _.keys(profiles).length,
          profiles: p13n.getProfileElements(profiles),
          origin_name: originName,
          origin_is_pending: this.model.getOrigin().isPending(),
          transport_icons: transportIcons
        };
      };

      RouteSettingsHeaderView.prototype.toggleSettingsVisibility = function(event) {
        event.preventDefault();
        $('#route-details').toggleClass('settings-open');
        $('.bootstrap-datetimepicker-widget').hide();
        return $('#route-details').trigger("shown");
      };

      return RouteSettingsHeaderView;

    })(base.SMItemView);
    TransportModeControlsView = (function(_super) {
      __extends(TransportModeControlsView, _super);

      function TransportModeControlsView() {
        this.onRender = __bind(this.onRender, this);
        return TransportModeControlsView.__super__.constructor.apply(this, arguments);
      }

      TransportModeControlsView.prototype.template = 'transport-mode-controls';

      TransportModeControlsView.prototype.events = {
        'click .transport-modes a': 'switchTransportMode'
      };

      TransportModeControlsView.prototype.onRender = function() {
        return _(['public', 'bicycle']).each((function(_this) {
          return function(group) {
            return _this.$el.find("." + group + "-details a").click(function(ev) {
              ev.preventDefault();
              return _this.switchTransportDetails(ev, group);
            });
          };
        })(this));
      };

      TransportModeControlsView.prototype.serializeData = function() {
        var bicycleDetailsClasses, publicModes, selectedValues, transportModes;
        transportModes = p13n.get('transport');
        bicycleDetailsClasses = '';
        if (transportModes.public_transport) {
          bicycleDetailsClasses += 'no-arrow ';
        }
        if (!transportModes.bicycle) {
          bicycleDetailsClasses += 'hidden';
        }
        selectedValues = (function(_this) {
          return function(modes) {
            return _(modes).chain().pairs().filter(function(v) {
              return v[1] === true;
            }).map(function(v) {
              return v[0];
            }).value();
          };
        })(this);
        transportModes = selectedValues(transportModes);
        publicModes = selectedValues(p13n.get('transport_detailed_choices')["public"]);
        return {
          transport_modes: transportModes,
          public_modes: publicModes,
          transport_detailed_choices: p13n.get('transport_detailed_choices'),
          bicycle_details_classes: bicycleDetailsClasses
        };
      };

      TransportModeControlsView.prototype.switchTransportMode = function(ev) {
        var type;
        ev.preventDefault();
        type = $(ev.target).closest('li').data('type');
        return p13n.toggleTransport(type);
      };

      TransportModeControlsView.prototype.switchTransportDetails = function(ev, group) {
        var type;
        ev.preventDefault();
        type = $(ev.target).closest('li').data('type');
        return p13n.toggleTransportDetails(group, type);
      };

      return TransportModeControlsView;

    })(base.SMItemView);
    RouteControllersView = (function(_super) {
      __extends(RouteControllersView, _super);

      function RouteControllersView() {
        return RouteControllersView.__super__.constructor.apply(this, arguments);
      }

      RouteControllersView.prototype.template = 'route-controllers';

      RouteControllersView.prototype.events = {
        'click .preset.unlocked': 'switchToLocationInput',
        'click .preset-current-time': 'switchToTimeInput',
        'click .preset-current-date': 'switchToDateInput',
        'click .time-mode': 'setTimeMode',
        'click .swap-endpoints': 'swapEndpoints',
        'click .tt-suggestion': function(e) {
          return e.stopPropagation();
        },
        'click': 'undoChanges',
        'click .time': function(ev) {
          return ev.stopPropagation();
        },
        'click .date': function(ev) {
          return ev.stopPropagation();
        }
      };

      RouteControllersView.prototype.initialize = function(attrs) {
        window.debugRoutingControls = this;
        this.permanentModel = this.model;
        this.pendingPosition = this.permanentModel.pendingPosition;
        this.currentUnit = attrs.unit;
        return this._reset();
      };

      RouteControllersView.prototype._reset = function() {
        this.stopListening(this.model);
        this.model = this.permanentModel.clone();
        this.listenTo(this.model, 'change', (function(_this) {
          return function(model, options) {
            var _ref, _ref1, _ref2, _ref3;
            if (!(options != null ? options.alreadyVisible : void 0)) {
              if ((_ref = _this.$el.find('input.time').data("DateTimePicker")) != null) {
                _ref.hide();
              }
              if ((_ref1 = _this.$el.find('input.time').data("DateTimePicker")) != null) {
                _ref1.destroy();
              }
              if ((_ref2 = _this.$el.find('input.date').data("DateTimePicker")) != null) {
                _ref2.hide();
              }
              if ((_ref3 = _this.$el.find('input.date').data("DateTimePicker")) != null) {
                _ref3.destroy();
              }
              return _this.render();
            }
          };
        })(this));
        this.listenTo(this.model.getOrigin(), 'change', this.render);
        return this.listenTo(this.model.getDestination(), 'change', this.render);
      };

      RouteControllersView.prototype.onRender = function() {
        this.enableTypeahead('.transit-end input');
        this.enableTypeahead('.transit-start input');
        return this.enableDatetimePicker();
      };

      RouteControllersView.prototype.enableDatetimePicker = function() {
        var closePicker, inputElement, keys, other, otherHider, valueSetter;
        keys = ['time', 'date'];
        other = (function(_this) {
          return function(key) {
            return keys[keys.indexOf(key) + 1 % keys.length];
          };
        })(this);
        inputElement = (function(_this) {
          return function(key) {
            return _this.$el.find("input." + key);
          };
        })(this);
        otherHider = (function(_this) {
          return function(key) {
            return function() {
              var _ref;
              return (_ref = inputElement(other(key)).data("DateTimePicker")) != null ? _ref.hide() : void 0;
            };
          };
        })(this);
        valueSetter = (function(_this) {
          return function(key) {
            return function(ev) {
              var keyUpper;
              keyUpper = key.charAt(0).toUpperCase() + key.slice(1);
              _this.model["set" + keyUpper].call(_this.model, ev.date.toDate(), {
                alreadyVisible: true
              });
              return _this.applyChanges();
            };
          };
        })(this);
        closePicker = true;
        _.each(keys, (function(_this) {
          return function(key) {
            var $input, dateTimePicker, disablePick, options;
            $input = inputElement(key);
            if ($input.length > 0) {
              options = {};
              disablePick = {
                time: 'pickDate',
                date: 'pickTime'
              }[key];
              options[disablePick] = false;
              $input.datetimepicker(options);
              $input.on('dp.show', function() {
                if (_this.activateOnRender !== 'date' && (_this.shown != null) && _this.shown !== key) {
                  closePicker = false;
                }
                otherHider(key)();
                return _this.shown = key;
              });
              $input.on('dp.change', valueSetter(key));
              dateTimePicker = $input.data("DateTimePicker");
              $input.on('click', function() {
                if (closePicker) {
                  _this._closeDatetimePicker($input);
                }
                return closePicker = !closePicker;
              });
              if (_this.activateOnRender === key) {
                dateTimePicker.show();
                return $input.attr('readonly', _this._isScreenHeightLow());
              }
            }
          };
        })(this));
        return this.activateOnRender = null;
      };

      RouteControllersView.prototype.applyChanges = function() {
        this.permanentModel.set(this.model.attributes);
        return this.permanentModel.triggerComplete();
      };

      RouteControllersView.prototype.undoChanges = function() {
        var destination, origin;
        this._reset();
        origin = this.model.getOrigin();
        destination = this.model.getDestination();
        return this.model.trigger('change');
      };

      RouteControllersView.prototype.enableTypeahead = function(selector) {
        var geocoderBackend, options, selectAddress;
        this.$searchEl = this.$el.find(selector);
        if (!this.$searchEl.length) {
          return;
        }
        geocoderBackend = new geocoding.GeocoderSourceBackend();
        options = geocoderBackend.getDatasetOptions();
        options.templates.empty = function(ctx) {
          return jade.template('typeahead-no-results', ctx);
        };
        this.$searchEl.typeahead(null, [options]);
        this.$searchEl.on('keyup', (function(_this) {
          return function(e) {
            if (e.keyCode === 13) {
              return $('.tt-suggestion:first-child').trigger('click');
            }
          };
        })(this));
        selectAddress = (function(_this) {
          return function(event, match) {
            _this.commit = true;
            switch ($(event.currentTarget).attr('data-endpoint')) {
              case 'origin':
                _this.model.setOrigin(match);
                break;
              case 'destination':
                _this.model.setDestination(match);
            }
            return _this.applyChanges();
          };
        })(this);
        geocoderBackend.setOptions({
          $inputEl: this.$searchEl,
          selectionCallback: selectAddress
        });
        return $('#route-details').on("shown", (function(_this) {
          return function() {
            return _this.$searchEl.attr('tabindex', -1).focus();
          };
        })(this));
      };

      RouteControllersView.prototype._locationNameAndLocking = function(object) {
        return {
          name: this.model.getEndpointName(object),
          lock: this.model.getEndpointLocking(object)
        };
      };

      RouteControllersView.prototype._isScreenHeightLow = function() {
        return $(window).innerHeight() < 700;
      };

      RouteControllersView.prototype.serializeData = function() {
        var datetime, today, tomorrow;
        datetime = moment(this.model.getDatetime());
        today = new Date();
        tomorrow = moment(today).add(1, 'days');
        return {
          disable_keyboard: this._isScreenHeightLow(),
          is_today: !this.forceDateInput && datetime.isSame(today, 'day'),
          is_tomorrow: datetime.isSame(tomorrow, 'day'),
          params: this.model,
          origin: this._locationNameAndLocking(this.model.getOrigin()),
          destination: this._locationNameAndLocking(this.model.getDestination()),
          time: datetime.format('LT'),
          date: datetime.format('L'),
          time_mode: this.model.get('time_mode')
        };
      };

      RouteControllersView.prototype.swapEndpoints = function(ev) {
        ev.stopPropagation();
        this.permanentModel.swapEndpoints({
          silent: true
        });
        this.model.swapEndpoints();
        if (this.model.isComplete()) {
          return this.applyChanges();
        }
      };

      RouteControllersView.prototype.switchToLocationInput = function(ev) {
        var position;
        ev.stopPropagation();
        this._reset();
        position = this.pendingPosition;
        position.clear();
        switch ($(ev.currentTarget).attr('data-route-node')) {
          case 'start':
            this.model.setOrigin(position);
            break;
          case 'end':
            this.model.setDestination(position);
        }
        this.listenToOnce(position, 'change', (function(_this) {
          return function() {
            _this.applyChanges();
            return _this.render();
          };
        })(this));
        return position.trigger('request');
      };

      RouteControllersView.prototype.setTimeMode = function(ev) {
        var timeMode;
        ev.stopPropagation();
        timeMode = $(ev.target).data('value');
        if (timeMode !== this.model.get('time_mode')) {
          this.model.setTimeMode(timeMode);
          return this.applyChanges();
        }
      };

      RouteControllersView.prototype._closeDatetimePicker = function($input) {
        return $input.data("DateTimePicker").hide();
      };

      RouteControllersView.prototype.switchToTimeInput = function(ev) {
        ev.stopPropagation();
        this.activateOnRender = 'time';
        return this.model.setDefaultDatetime();
      };

      RouteControllersView.prototype.switchToDateInput = function(ev) {
        ev.stopPropagation();
        this.activateOnRender = 'date';
        this.forceDateInput = true;
        return this.model.trigger('change');
      };

      return RouteControllersView;

    })(base.SMItemView);
    return RouteSettingsView;
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['underscore', 'moment', 'i18next', 'app/p13n', 'app/models', 'app/spinner', 'app/views/base', 'app/views/route-settings'], function(_, moment, i18n, p13n, models, SMSpinner, base, RouteSettingsView) {
    var RouteView, RoutingSummaryView;
    RouteView = (function(_super) {
      __extends(RouteView, _super);

      function RouteView() {
        return RouteView.__super__.constructor.apply(this, arguments);
      }

      RouteView.prototype.id = 'route-view-container';

      RouteView.prototype.className = 'route-view';

      RouteView.prototype.template = 'route';

      RouteView.prototype.regions = {
        'routeSettingsRegion': '.route-settings',
        'routeSummaryRegion': '.route-summary'
      };

      RouteView.prototype.events = {
        'click a.collapser.route': 'toggleRoute',
        'click .show-map': 'showMap'
      };

      RouteView.prototype.initialize = function(options) {
        this.parentView = options.parentView;
        this.selectedUnits = options.selectedUnits;
        this.selectedPosition = options.selectedPosition;
        this.route = options.route;
        this.routingParameters = options.routingParameters;
        this.listenTo(this.routingParameters, 'complete', _.debounce(_.bind(this.requestRoute, this), 300));
        this.listenTo(p13n, 'change', this.changeTransitIcon);
        this.listenTo(this.route, 'change:plan', (function(_this) {
          return function(route) {
            if (route.has('plan')) {
              _this.routingParameters.set('route', _this.route);
              return _this.showRouteSummary(_this.route);
            }
          };
        })(this));
        return this.listenTo(p13n, 'change', (function(_this) {
          return function(path, val) {
            return _this.requestRoute();
          };
        })(this));
      };

      RouteView.prototype.serializeData = function() {
        return {
          transit_icon: this.getTransitIcon()
        };
      };

      RouteView.prototype.getTransitIcon = function() {
        var mode, modeIconName, setModes;
        setModes = _.filter(_.pairs(p13n.get('transport')), function(_arg) {
          var k, v;
          k = _arg[0], v = _arg[1];
          return v === true;
        });
        mode = setModes.pop()[0];
        modeIconName = mode.replace('_', '-');
        return "icon-icon-" + modeIconName;
      };

      RouteView.prototype.changeTransitIcon = function() {
        var $iconEl;
        $iconEl = this.$el.find('#route-section-icon');
        return $iconEl.removeClass().addClass(this.getTransitIcon());
      };

      RouteView.prototype.toggleRoute = function(ev) {
        var $element;
        $element = $(ev.currentTarget);
        if ($element.hasClass('collapsed')) {
          return this.showRoute();
        } else {
          return this.hideRoute();
        }
      };

      RouteView.prototype.showMap = function(ev) {
        return this.parentView.showMap(ev);
      };

      RouteView.prototype.showRoute = function() {
        var lastPos, previousOrigin;
        lastPos = p13n.getLastPosition();
        this.routingParameters.ensureUnitDestination();
        this.routingParameters.setDestination(this.model);
        previousOrigin = this.routingParameters.getOrigin();
        if (lastPos) {
          if (!previousOrigin) {
            this.routingParameters.setOrigin(lastPos, {
              silent: true
            });
          }
          this.requestRoute();
        } else {
          this.listenTo(p13n, 'position', (function(_this) {
            return function(pos) {
              return _this.requestRoute();
            };
          })(this));
          this.listenTo(p13n, 'position_error', (function(_this) {
            return function() {
              return _this.showRouteSummary(null);
            };
          })(this));
          if (!previousOrigin) {
            this.routingParameters.setOrigin(new models.CoordinatePosition);
          }
          p13n.requestLocation(this.routingParameters.getOrigin());
        }
        this.routeSettingsRegion.show(new RouteSettingsView({
          model: this.routingParameters,
          unit: this.model
        }));
        return this.showRouteSummary(null);
      };

      RouteView.prototype.showRouteSummary = function(route) {
        return this.routeSummaryRegion.show(new RoutingSummaryView({
          model: this.routingParameters,
          noRoute: route == null
        }));
      };

      RouteView.prototype.requestRoute = function() {
        var datetime, from, opts, publicTransportChoices, selectedVehicles, spinner, to;
        if (!this.routingParameters.isComplete()) {
          return;
        }
        spinner = new SMSpinner({
          container: this.$el.find('#route-details .route-spinner').get(0)
        });
        spinner.start();
        this.listenTo(this.route, 'change:plan', (function(_this) {
          return function(plan) {
            return spinner.stop();
          };
        })(this));
        this.listenTo(this.route, 'error', (function(_this) {
          return function() {
            return spinner.stop();
          };
        })(this));
        this.routingParameters.unset('route');
        opts = {};
        if (p13n.getAccessibilityMode('mobility') === 'wheelchair') {
          opts.wheelchair = true;
          opts.walkReluctance = 5;
          opts.walkBoardCost = 12 * 60;
          opts.walkSpeed = 0.75;
          opts.minTransferTime = 3 * 60 + 1;
        }
        if (p13n.getAccessibilityMode('mobility') === 'reduced_mobility') {
          opts.walkReluctance = 5;
          opts.walkBoardCost = 10 * 60;
          opts.walkSpeed = 0.5;
        }
        if (p13n.getAccessibilityMode('mobility') === 'rollator') {
          opts.wheelchair = true;
          opts.walkReluctance = 5;
          opts.walkSpeed = 0.5;
          opts.walkBoardCost = 12 * 60;
        }
        if (p13n.getAccessibilityMode('mobility') === 'stroller') {
          opts.walkBoardCost = 10 * 60;
          opts.walkSpeed = 1;
        }
        if (p13n.getTransport('bicycle')) {
          opts.bicycle = true;
        }
        if (p13n.getTransport('car')) {
          opts.car = true;
        }
        if (p13n.getTransport('public_transport')) {
          publicTransportChoices = p13n.get('transport_detailed_choices')["public"];
          selectedVehicles = _(publicTransportChoices).chain().pairs().filter(_.last).map(_.first).value();
          if (selectedVehicles.length === _(publicTransportChoices).values().length) {
            opts.transit = true;
          } else {
            opts.transit = false;
            opts.modes = selectedVehicles;
          }
        }
        datetime = this.routingParameters.getDatetime();
        opts.date = moment(datetime).format('YYYY/MM/DD');
        opts.time = moment(datetime).format('HH:mm');
        opts.arriveBy = this.routingParameters.get('time_mode') === 'arrive';
        from = this.routingParameters.getOrigin().otpSerializeLocation({
          forceCoordinates: opts.car
        });
        to = this.routingParameters.getDestination().otpSerializeLocation({
          forceCoordinates: opts.car
        });
        return this.route.requestPlan(from, to, opts);
      };

      RouteView.prototype.hideRoute = function() {
        return this.route.clear();
      };

      return RouteView;

    })(base.SMLayout);
    RoutingSummaryView = (function(_super) {
      var LEG_MODES, MODES_WITH_STOPS, NUMBER_OF_CHOICES_SHOWN;

      __extends(RoutingSummaryView, _super);

      function RoutingSummaryView() {
        return RoutingSummaryView.__super__.constructor.apply(this, arguments);
      }

      RoutingSummaryView.prototype.template = 'routing-summary';

      RoutingSummaryView.prototype.className = 'route-summary';

      RoutingSummaryView.prototype.events = {
        'click .route-selector a': 'switchItinerary',
        'click .accessibility-viewpoint': 'setAccessibility'
      };

      RoutingSummaryView.prototype.initialize = function(options) {
        this.itineraryChoicesStartIndex = 0;
        this.detailsOpen = false;
        this.skipRoute = options.noRoute;
        return this.route = this.model.get('route');
      };

      NUMBER_OF_CHOICES_SHOWN = 3;

      LEG_MODES = {
        WALK: {
          icon: 'icon-icon-by-foot',
          colorClass: 'transit-walk',
          text: i18n.t('transit.walk')
        },
        BUS: {
          icon: 'icon-icon-bus',
          colorClass: 'transit-default',
          text: i18n.t('transit.bus')
        },
        BICYCLE: {
          icon: 'icon-icon-bicycle',
          colorClass: 'transit-bicycle',
          text: i18n.t('transit.bicycle')
        },
        CAR: {
          icon: 'icon-icon-car',
          colorClass: 'transit-car',
          text: i18n.t('transit.car')
        },
        TRAM: {
          icon: 'icon-icon-tram',
          colorClass: 'transit-tram',
          text: i18n.t('transit.tram')
        },
        SUBWAY: {
          icon: 'icon-icon-subway',
          colorClass: 'transit-subway',
          text: i18n.t('transit.subway')
        },
        RAIL: {
          icon: 'icon-icon-train',
          colorClass: 'transit-rail',
          text: i18n.t('transit.rail')
        },
        FERRY: {
          icon: 'icon-icon-ferry',
          colorClass: 'transit-ferry',
          text: i18n.t('transit.ferry')
        },
        WAIT: {
          icon: '',
          colorClass: 'transit-default',
          text: i18n.t('transit.wait')
        }
      };

      MODES_WITH_STOPS = ['BUS', 'FERRY', 'RAIL', 'SUBWAY', 'TRAM'];

      RoutingSummaryView.prototype.serializeData = function() {
        var choices, end, filteredLegs, itinerary, legs, mobilityAccessibilityMode, mobilityElement, route;
        if (this.skipRoute) {
          return {
            skip_route: true
          };
        }
        window.debugRoute = this.route;
        itinerary = this.route.getSelectedItinerary();
        filteredLegs = _.filter(itinerary.legs, function(leg) {
          return leg.mode !== 'WAIT';
        });
        mobilityAccessibilityMode = p13n.getAccessibilityMode('mobility');
        mobilityElement = null;
        if (mobilityAccessibilityMode) {
          mobilityElement = p13n.getProfileElement(mobilityAccessibilityMode);
        } else {
          mobilityElement = LEG_MODES['WALK'];
        }
        legs = _.map(filteredLegs, (function(_this) {
          return function(leg) {
            var icon, startLocation, steps, text;
            steps = _this.parseSteps(leg);
            if (leg.mode === 'WALK') {
              icon = mobilityElement.icon;
              if (mobilityAccessibilityMode === 'wheelchair') {
                text = i18n.t('transit.mobility_mode.wheelchair');
              } else {
                text = i18n.t('transit.walk');
              }
            } else {
              icon = LEG_MODES[leg.mode].icon;
              text = LEG_MODES[leg.mode].text;
            }
            if (leg.from.bogusName) {
              startLocation = i18n.t("otp.bogus_name." + (leg.from.name.replace(' ', '_')));
            }
            return {
              start_time: moment(leg.startTime).format('LT'),
              start_location: startLocation || p13n.getTranslatedAttr(leg.from.translatedName) || leg.from.name,
              distance: _this.getLegDistance(leg, steps),
              icon: icon,
              transit_color_class: LEG_MODES[leg.mode].colorClass,
              transit_mode: text,
              route: _this.getRouteText(leg),
              transit_destination: _this.getTransitDestination(leg),
              steps: steps,
              has_warnings: !!_.find(steps, function(step) {
                return step.warning;
              })
            };
          };
        })(this));
        end = {
          time: moment(itinerary.endTime).format('LT'),
          name: p13n.getTranslatedAttr(this.route.get('plan').to.translatedName) || this.route.get('plan').to.name,
          address: p13n.getTranslatedAttr(this.model.getDestination().get('street_address'))
        };
        route = {
          duration: Math.round(itinerary.duration / 60) + ' min',
          walk_distance: (itinerary.walkDistance / 1000).toFixed(1) + 'km',
          legs: legs,
          end: end
        };
        choices = this.getItineraryChoices();
        return {
          skip_route: false,
          profile_set: _.keys(p13n.getAccessibilityProfileIds(true)).length,
          itinerary: route,
          itinerary_choices: choices,
          selected_itinerary_index: this.route.get('selected_itinerary'),
          details_open: this.detailsOpen,
          current_time: moment(new Date()).format('YYYY-MM-DDTHH:mm')
        };
      };

      RoutingSummaryView.prototype.parseSteps = function(leg) {
        var alert, step, steps, stop, text, warning, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4;
        steps = [];
        if ((_ref = leg.mode) === 'WALK' || _ref === 'BICYCLE' || _ref === 'CAR') {
          _ref1 = leg.steps;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            step = _ref1[_i];
            warning = null;
            if (step.bogusName) {
              step.streetName = i18n.t("otp.bogus_name." + (step.streetName.replace(' ', '_')));
            } else if (p13n.getTranslatedAttr(step.translatedName)) {
              step.streetName = p13n.getTranslatedAttr(step.translatedName);
            }
            text = i18n.t("otp.step_directions." + step.relativeDirection, {
              street: step.streetName,
              postProcess: "fixFinnishStreetNames"
            });
            if ('alerts' in step && step.alerts.length) {
              warning = step.alerts[0].alertHeaderText.someTranslation;
            }
            steps.push({
              text: text,
              warning: warning
            });
          }
        } else if ((_ref2 = leg.mode, __indexOf.call(MODES_WITH_STOPS, _ref2) >= 0) && leg.intermediateStops) {
          if ('alerts' in leg && leg.alerts.length) {
            _ref3 = leg.alerts;
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              alert = _ref3[_j];
              steps.push({
                text: "",
                warning: alert.alertHeaderText.someTranslation
              });
            }
          }
          _ref4 = leg.intermediateStops;
          for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
            stop = _ref4[_k];
            steps.push({
              text: p13n.getTranslatedAttr(stop.translatedName) || stop.name,
              time: moment(stop.arrival).format('LT')
            });
          }
        } else {
          steps.push({
            text: 'No further info.'
          });
        }
        return steps;
      };

      RoutingSummaryView.prototype.getLegDistance = function(leg, steps) {
        var stops, _ref;
        if (_ref = leg.mode, __indexOf.call(MODES_WITH_STOPS, _ref) >= 0) {
          stops = _.reject(steps, function(step) {
            return 'warning' in step;
          });
          return "" + stops.length + " " + (i18n.t('transit.stops'));
        } else {
          return (leg.distance / 1000).toFixed(1) + 'km';
        }
      };

      RoutingSummaryView.prototype.getTransitDestination = function(leg) {
        var _ref;
        if (_ref = leg.mode, __indexOf.call(MODES_WITH_STOPS, _ref) >= 0) {
          return "" + (i18n.t('transit.toward')) + " " + leg.headsign;
        } else {
          return '';
        }
      };

      RoutingSummaryView.prototype.getRouteText = function(leg) {
        var route;
        route = leg.route.length < 5 ? leg.route : '';
        if (leg.mode === 'FERRY') {
          route = '';
        }
        return route;
      };

      RoutingSummaryView.prototype.getItineraryChoices = function() {
        var numberOfItineraries, start, stop;
        numberOfItineraries = this.route.get('plan').itineraries.length;
        start = this.itineraryChoicesStartIndex;
        stop = Math.min(start + NUMBER_OF_CHOICES_SHOWN, numberOfItineraries);
        return _.range(start, stop);
      };

      RoutingSummaryView.prototype.switchItinerary = function(event) {
        event.preventDefault();
        this.detailsOpen = true;
        this.route.set('selected_itinerary', $(event.currentTarget).data('index'));
        return this.render();
      };

      RoutingSummaryView.prototype.setAccessibility = function(event) {
        event.preventDefault();
        return p13n.trigger('user:open');
      };

      return RoutingSummaryView;

    })(base.SMItemView);
    return RouteView;
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['typeahead.bundle', 'app/models', 'app/jade', 'app/search', 'app/geocoding', 'app/views/base'], function(typeahead, models, jade, search, geocoding, base) {
    var SearchInputView;
    return SearchInputView = (function(_super) {
      __extends(SearchInputView, _super);

      function SearchInputView() {
        return SearchInputView.__super__.constructor.apply(this, arguments);
      }

      SearchInputView.prototype.classname = 'search-input-element';

      SearchInputView.prototype.template = 'navigation-search';

      SearchInputView.prototype.initialize = function(model, searchResults) {
        this.model = model;
        this.searchResults = searchResults;
        this.listenTo(this.searchResults, 'ready', this.adaptToQuery);
        return this.listenTo(this.searchResults, 'reset', (function(_this) {
          return function() {
            if (_this.searchResults.isEmpty()) {
              return _this.setInputText('');
            }
          };
        })(this));
      };

      SearchInputView.prototype.adaptToQuery = function(model, value, opts) {
        var $container, $icon, _ref;
        $container = this.$el.find('.action-button');
        $icon = $container.find('span');
        if (this.isEmpty()) {
          if ((_ref = this.searchResults.query) != null ? _ref.length : void 0) {
            this.setInputText(this.searchResults.query);
            this.trigger('open');
          }
        }
        if (this.isEmpty() || this.getInputText() === this.searchResults.query) {
          $icon.removeClass('icon-icon-forward-bold');
          $icon.addClass('icon-icon-close');
          $container.removeClass('search-button');
          return $container.addClass('close-button');
        } else {
          $icon.addClass('icon-icon-forward-bold');
          $icon.removeClass('icon-icon-close');
          $container.removeClass('close-button');
          return $container.addClass('search-button');
        }
      };

      SearchInputView.prototype.events = {
        'typeahead:selected': 'autosuggestShowDetails',
        'click .tt-suggestion': function(e) {
          return e.stopPropagation();
        },
        'click input': '_onInputClicked',
        'click .typeahead-suggestion.fulltext': 'executeQuery',
        'click .action-button.search-button': 'search',
        'submit .input-container': 'search',
        'input input': 'checkInputValue'
      };

      SearchInputView.prototype.checkInputValue = function() {
        if (this.isEmpty()) {
          this.$searchEl.typeahead('val', '');
          return app.commands.execute('clearSearchResults', {
            navigate: true
          });
        }
      };

      SearchInputView.prototype.search = function(e) {
        e.stopPropagation();
        if (!this.isEmpty()) {
          this.$searchEl.typeahead('close');
          this.executeQuery();
        }
        return e.preventDefault();
      };

      SearchInputView.prototype.isEmpty = function() {
        var query;
        query = this.getInputText();
        if ((query != null) && query.length > 0) {
          return false;
        }
        return true;
      };

      SearchInputView.prototype._onInputClicked = function(ev) {
        this.trigger('open');
        return ev.stopPropagation();
      };

      SearchInputView.prototype._getSearchEl = function() {
        if (this.$searchEl != null) {
          return this.$searchEl;
        } else {
          return this.$searchEl = this.$el.find('input.form-control[type=search]');
        }
      };

      SearchInputView.prototype.setInputText = function(query) {
        var $el;
        $el = this._getSearchEl();
        if ($el.length) {
          return $el.typeahead('val', query);
        }
      };

      SearchInputView.prototype.getInputText = function() {
        var $el;
        $el = this._getSearchEl();
        if ($el.length) {
          return $el.typeahead('val');
        } else {
          return null;
        }
      };

      SearchInputView.prototype.onRender = function() {
        this.enableTypeahead('input.form-control[type=search]');
        this.setTypeaheadWidth();
        return $(window).resize((function(_this) {
          return function() {
            return _this.setTypeaheadWidth();
          };
        })(this));
      };

      SearchInputView.prototype.setTypeaheadWidth = function() {
        var width, windowWidth;
        windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        if (windowWidth < appSettings.mobile_ui_breakpoint) {
          width = $('#navigation-header').width();
          return this.$el.find('.tt-dropdown-menu').css({
            'width': width
          });
        } else {
          return this.$el.find('.tt-dropdown-menu').css({
            'width': 'auto'
          });
        }
      };

      SearchInputView.prototype.enableTypeahead = function(selector) {
        var eventDataset, fullDataset, serviceDataset;
        this.$searchEl = this.$el.find(selector);
        serviceDataset = {
          name: 'service',
          source: search.servicemapEngine.ttAdapter(),
          displayKey: function(c) {
            return c.name[p13n.getLanguage()];
          },
          templates: {
            suggestion: function(ctx) {
              return jade.template('typeahead-suggestion', ctx);
            }
          }
        };
        eventDataset = {
          name: 'event',
          source: search.linkedeventsEngine.ttAdapter(),
          displayKey: function(c) {
            return c.name[p13n.getLanguage()];
          },
          templates: {
            suggestion: function(ctx) {
              return jade.template('typeahead-suggestion', ctx);
            }
          }
        };
        fullDataset = {
          name: 'header',
          source: function(q, c) {
            return c([
              {
                query: q,
                object_type: 'query'
              }
            ]);
          },
          displayKey: function(s) {
            return s.query;
          },
          name: 'full',
          templates: {
            suggestion: function(s) {
              return jade.template('typeahead-fulltext', s);
            }
          }
        };
        this.geocoderBackend = new geocoding.GeocoderSourceBackend();
        this.$searchEl.typeahead({
          hint: false
        }, [fullDataset, this.geocoderBackend.getDatasetOptions(), serviceDataset, eventDataset]);
        return this.geocoderBackend.setOptions({
          $inputEl: this.$searchEl,
          selectionCallback: function(ev, data) {
            return app.commands.execute('selectPosition', data);
          }
        });
      };

      SearchInputView.prototype.getQuery = function() {
        return $.trim(this.$searchEl.val());
      };

      SearchInputView.prototype.executeQuery = function() {
        this.geocoderBackend.street = null;
        this.$searchEl.typeahead('close');
        return app.commands.execute('search', this.getInputText());
      };

      SearchInputView.prototype.autosuggestShowDetails = function(ev, data, _) {
        var model, objectType;
        model = null;
        objectType = data.object_type;
        if (objectType === 'address') {
          return;
        }
        this.$searchEl.typeahead('val', '');
        app.commands.execute('clearSearchResults', {
          navigate: false
        });
        $('.search-container input').val('');
        this.$searchEl.typeahead('close');
        switch (objectType) {
          case 'unit':
            model = new models.Unit(data);
            return app.commands.execute('selectUnit', model, {
              replace: true
            });
          case 'service':
            return app.commands.execute('addService', new models.Service(data));
          case 'event':
            return app.commands.execute('selectEvent', new models.Event(data));
          case 'query':
            return app.commands.execute('search', data.query);
        }
      };

      return SearchInputView;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  define(['underscore', 'i18next', 'app/models', 'app/views/base', 'app/views/radius', 'app/spinner'], function(_, i18n, models, base, RadiusControlsView, SMSpinner) {
    var BaseListingLayoutView, EXPAND_CUTOFF, LocationPromptView, PAGE_SIZE, RESULT_TYPES, SearchLayoutView, SearchResultView, SearchResultsLayoutView, SearchResultsView, UnitListLayoutView, isElementInViewport;
    RESULT_TYPES = {
      unit: models.UnitList,
      service: models.ServiceList,
      address: models.PositionList
    };
    EXPAND_CUTOFF = 3;
    PAGE_SIZE = 20;
    isElementInViewport = function(el) {
      var rect;
      if (typeof jQuery === 'function' && el instanceof jQuery) {
        el = el[0];
      }
      rect = el.getBoundingClientRect();
      return rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) + (el.offsetHeight * 0);
    };
    SearchResultView = (function(_super) {
      __extends(SearchResultView, _super);

      function SearchResultView() {
        return SearchResultView.__super__.constructor.apply(this, arguments);
      }

      SearchResultView.prototype.template = 'search-result';

      SearchResultView.prototype.tagName = 'li';

      SearchResultView.prototype.events = function() {
        var keyhandler;
        keyhandler = this.keyboardHandler(this.selectResult, ['enter']);
        return {
          'click': 'selectResult',
          'keydown': keyhandler,
          'focus': 'highlightResult',
          'mouseenter': 'highlightResult'
        };
      };

      SearchResultView.prototype.initialize = function(opts) {
        return this.order = opts.order;
      };

      SearchResultView.prototype.selectResult = function(ev) {
        var object_type;
        object_type = this.model.get('object_type') || 'unit';
        switch (object_type) {
          case 'unit':
            return app.commands.execute('selectUnit', this.model);
          case 'service':
            return app.commands.execute('addService', this.model);
          case 'address':
            return app.commands.execute('selectPosition', this.model);
        }
      };

      SearchResultView.prototype.highlightResult = function(ev) {
        return app.commands.execute('highlightUnit', this.model);
      };

      SearchResultView.prototype.serializeData = function() {
        var data, fn;
        data = SearchResultView.__super__.serializeData.call(this);
        data.specifier_text = this.model.getSpecifierText();
        switch (this.order) {
          case 'distance':
            fn = this.model.getDistanceToLastPosition;
            if (fn != null) {
              data.distance = fn.apply(this.model);
            }
            break;
          case 'accessibility':
            fn = this.model.getShortcomingCount;
            if (fn != null) {
              data.shortcomings = fn.apply(this.model);
            }
        }
        if (this.model.get('object_type') === 'address') {
          data.name = this.model.humanAddress({
            exclude: {
              municipality: true
            }
          });
        }
        return data;
      };

      return SearchResultView;

    })(base.SMItemView);
    SearchResultsView = (function(_super) {
      __extends(SearchResultsView, _super);

      function SearchResultsView() {
        return SearchResultsView.__super__.constructor.apply(this, arguments);
      }

      SearchResultsView.prototype.tagName = 'ul';

      SearchResultsView.prototype.className = 'main-list';

      SearchResultsView.prototype.itemView = SearchResultView;

      SearchResultsView.prototype.itemViewOptions = function() {
        return {
          order: this.parent.getComparatorKey()
        };
      };

      SearchResultsView.prototype.initialize = function(opts) {
        SearchResultsView.__super__.initialize.call(this, opts);
        return this.parent = opts.parent;
      };

      return SearchResultsView;

    })(base.SMCollectionView);
    LocationPromptView = (function(_super) {
      __extends(LocationPromptView, _super);

      function LocationPromptView() {
        return LocationPromptView.__super__.constructor.apply(this, arguments);
      }

      LocationPromptView.prototype.tagName = 'ul';

      LocationPromptView.prototype.className = 'main-list';

      LocationPromptView.prototype.render = function() {
        this.$el.html("<li>" + (i18n.t('search.location_info')) + "</li>");
        return this;
      };

      return LocationPromptView;

    })(base.SMItemView);
    SearchResultsLayoutView = (function(_super) {
      __extends(SearchResultsLayoutView, _super);

      function SearchResultsLayoutView() {
        return SearchResultsLayoutView.__super__.constructor.apply(this, arguments);
      }

      SearchResultsLayoutView.prototype.template = 'search-results';

      SearchResultsLayoutView.prototype.regions = {
        results: '.result-contents',
        controls: '#list-controls'
      };

      SearchResultsLayoutView.prototype.className = 'search-results-container';

      SearchResultsLayoutView.prototype.events = {
        'click .back-button': 'goBack',
        'click .sorting': 'cycleSorting'
      };

      SearchResultsLayoutView.prototype.goBack = function(ev) {
        this.expansion = EXPAND_CUTOFF;
        this.requestedExpansion = 0;
        return this.parent.backToSummary();
      };

      SearchResultsLayoutView.prototype.cycleSorting = function(ev) {
        var key;
        this.fullCollection.cycleComparator();
        key = this.fullCollection.getComparatorKey();
        this.renderLocationPrompt = false;
        if (key === 'distance') {
          if (p13n.getLastPosition() == null) {
            this.renderLocationPrompt = true;
            this.listenTo(p13n, 'position', (function(_this) {
              return function() {
                _this.renderLocationPrompt = false;
                return _this.fullCollection.sort();
              };
            })(this));
            this.listenTo(p13n, 'position_error', (function(_this) {
              return function() {
                return _this.renderLocationPrompt = false;
              };
            })(this));
            p13n.requestLocation();
          }
        }
        this.expansion = 2 * PAGE_SIZE;
        return this.render();
      };

      SearchResultsLayoutView.prototype.onBeforeRender = function() {
        return this.collection = new this.fullCollection.constructor(this.fullCollection.slice(0, this.expansion));
      };

      SearchResultsLayoutView.prototype.nextPage = function(ev) {
        var delta, newExpansion;
        if (this.expansion === EXPAND_CUTOFF) {
          delta = 2 * PAGE_SIZE - EXPAND_CUTOFF;
        } else {
          delta = PAGE_SIZE;
        }
        newExpansion = this.expansion + delta;
        if (this.requestedExpansion === newExpansion) {
          return;
        }
        this.requestedExpansion = newExpansion;
        this.expansion = this.requestedExpansion;
        return this.render();
      };

      SearchResultsLayoutView.prototype.getDetailedFieldset = function() {
        switch (this.resultType) {
          case 'unit':
            return ['services'];
          case 'service':
            return ['ancestors'];
          default:
            return null;
        }
      };

      SearchResultsLayoutView.prototype.initialize = function(_arg) {
        var _ref;
        this.collectionType = _arg.collectionType, this.fullCollection = _arg.fullCollection, this.resultType = _arg.resultType, this.parent = _arg.parent, this.onlyResultType = _arg.onlyResultType, this.position = _arg.position;
        this.expansion = EXPAND_CUTOFF;
        this.$more = null;
        this.requestedExpansion = 0;
        this.ready = false;
        this.ready = true;
        if (this.onlyResultType) {
          this.expansion = 2 * PAGE_SIZE;
          if ((_ref = this.parent) != null) {
            _ref.expand(this.resultType);
          }
        }
        this.listenTo(this.fullCollection, 'hide', (function(_this) {
          return function() {
            _this.hidden = true;
            return _this.render();
          };
        })(this));
        this.listenTo(this.fullCollection, 'show-all', this.nextPage);
        this.listenTo(this.fullCollection, 'sort', this.render);
        this.listenTo(this.fullCollection, 'batch-remove', this.render);
        return this.listenTo(p13n, 'accessibility-change', (function(_this) {
          return function() {
            var key;
            key = _this.fullCollection.getComparatorKey();
            if (p13n.hasAccessibilityIssues()) {
              _this.fullCollection.setComparator('accessibility');
            } else if (key === 'accessibility') {
              _this.fullCollection.setDefaultComparator();
            }
            _this.fullCollection.sort();
            return _this.render();
          };
        })(this));
      };

      SearchResultsLayoutView.prototype.getComparatorKey = function() {
        return this.fullCollection.getComparatorKey();
      };

      SearchResultsLayoutView.prototype.serializeData = function() {
        var crumb, data;
        if (this.hidden || (this.collection == null)) {
          return {
            hidden: true
          };
        }
        data = SearchResultsLayoutView.__super__.serializeData.call(this);
        if (this.collection.length) {
          crumb = (function() {
            switch (this.collectionType) {
              case 'search':
                return i18n.t('sidebar.search_results');
              case 'radius':
                if (this.position != null) {
                  return this.position.humanAddress();
                }
            }
          }).call(this);
          data = {
            comparatorKey: this.fullCollection.getComparatorKey(),
            controls: this.collectionType === 'radius',
            target: this.resultType,
            expanded: this._expanded(),
            showAll: false,
            showMore: false,
            onlyResultType: this.onlyResultType,
            crumb: crumb,
            header: i18n.t("search.type." + this.resultType + ".count", {
              count: this.fullCollection.length
            })
          };
          if (this.fullCollection.length > EXPAND_CUTOFF && !this._expanded()) {
            data.showAll = i18n.t("search.type." + this.resultType + ".show_all", {
              count: this.fullCollection.length
            });
          } else if (this.fullCollection.length > this.expansion && !this.renderLocationPrompt) {
            data.showMore = true;
          }
        }
        return data;
      };

      SearchResultsLayoutView.prototype.onRender = function() {
        var collectionView;
        if (this.renderLocationPrompt) {
          this.results.show(new LocationPromptView());
          return;
        }
        if (!this.ready) {
          this.ready = true;
          return;
        }
        collectionView = new SearchResultsView({
          collection: this.collection,
          parent: this
        });
        this.listenTo(collectionView, 'collection:rendered', (function(_this) {
          return function() {
            return _.defer(function() {
              _this.$more = $(_this.el).find('.show-more');
              _this.tryNextPage();
              return _this.trigger('rendered');
            });
          };
        })(this));
        this.results.show(collectionView);
        if (this.collectionType === 'radius') {
          return this.controls.show(new RadiusControlsView({
            radius: this.fullCollection.filters.distance
          }));
        }
      };

      SearchResultsLayoutView.prototype.tryNextPage = function() {
        var spinner, _ref;
        if ((_ref = this.$more) != null ? _ref.length : void 0) {
          if (isElementInViewport(this.$more)) {
            this.$more.find('.text-content').html(i18n.t('accessibility.pending'));
            spinner = new SMSpinner({
              container: this.$more.find('.spinner-container').get(0),
              radius: 5,
              length: 3,
              lines: 12,
              width: 2
            });
            spinner.start();
            return this.nextPage();
          }
        }
      };

      SearchResultsLayoutView.prototype._expanded = function() {
        return this.expansion > EXPAND_CUTOFF;
      };

      return SearchResultsLayoutView;

    })(base.SMLayout);
    BaseListingLayoutView = (function(_super) {
      __extends(BaseListingLayoutView, _super);

      function BaseListingLayoutView() {
        return BaseListingLayoutView.__super__.constructor.apply(this, arguments);
      }

      BaseListingLayoutView.prototype.className = function() {
        return 'search-results navigation-element limit-max-height';
      };

      BaseListingLayoutView.prototype.events = function() {
        return {
          'scroll': 'tryNextPage'
        };
      };

      BaseListingLayoutView.prototype.onRender = function() {
        var view;
        view = this.getPrimaryResultLayoutView();
        if (view == null) {
          return;
        }
        return this.listenToOnce(view, 'rendered', (function(_this) {
          return function() {
            return _.defer(function() {
              return _this.$el.find('.search-result').first().focus();
            });
          };
        })(this));
      };

      return BaseListingLayoutView;

    })(base.SMLayout);
    UnitListLayoutView = (function(_super) {
      __extends(UnitListLayoutView, _super);

      function UnitListLayoutView() {
        return UnitListLayoutView.__super__.constructor.apply(this, arguments);
      }

      UnitListLayoutView.prototype.template = 'service-units';

      UnitListLayoutView.prototype.regions = {
        'unitRegion': '.unit-region'
      };

      UnitListLayoutView.prototype.tryNextPage = function() {
        return this.resultLayoutView.tryNextPage();
      };

      UnitListLayoutView.prototype.initialize = function() {
        var opts, rest;
        opts = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return this.resultLayoutView = (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(SearchResultsLayoutView, [opts].concat(__slice.call(rest)), function(){});
      };

      UnitListLayoutView.prototype.onRender = function() {
        this.unitRegion.show(this.resultLayoutView);
        return UnitListLayoutView.__super__.onRender.call(this);
      };

      UnitListLayoutView.prototype.getPrimaryResultLayoutView = function() {
        return this.resultLayoutView;
      };

      return UnitListLayoutView;

    })(BaseListingLayoutView);
    SearchLayoutView = (function(_super) {
      __extends(SearchLayoutView, _super);

      function SearchLayoutView() {
        return SearchLayoutView.__super__.constructor.apply(this, arguments);
      }

      SearchLayoutView.prototype.template = 'search-layout';

      SearchLayoutView.prototype.type = 'search';

      SearchLayoutView.prototype.events = function() {
        return _.extend({}, SearchLayoutView.__super__.events.call(this), {
          'click .show-all': 'showAllOfSingleType'
        });
      };

      SearchLayoutView.prototype.tryNextPage = function() {
        var _ref;
        if (this.expanded) {
          return (_ref = this.resultLayoutViews[this.expanded]) != null ? _ref.tryNextPage() : void 0;
        }
      };

      SearchLayoutView.prototype.expand = function(target) {
        return this.expanded = target;
      };

      SearchLayoutView.prototype.showAllOfSingleType = function(ev) {
        var target;
        if (ev != null) {
          ev.preventDefault();
        }
        target = $(ev.currentTarget).data('target');
        this.expanded = target;
        return _(this.collections).each((function(_this) {
          return function(collection, key) {
            if (key === target) {
              return collection.trigger('show-all');
            } else {
              return collection.trigger('hide');
            }
          };
        })(this));
      };

      SearchLayoutView.prototype.backToSummary = function() {
        this.expanded = null;
        return this.render();
      };

      SearchLayoutView.prototype._regionId = function(key) {
        return "" + key + "Region";
      };

      SearchLayoutView.prototype._getRegionForType = function(key) {
        return this.getRegion(this._regionId(key));
      };

      SearchLayoutView.prototype.initialize = function() {
        this.expanded = null;
        this.collections = {};
        this.resultLayoutViews = {};
        _(RESULT_TYPES).each((function(_this) {
          return function(val, key) {
            _this.collections[key] = new val(null, {
              setComparator: true
            });
            return _this.addRegion(_this._regionId(key), "." + key + "-region");
          };
        })(this));
        return this.listenTo(this.collection, 'hide', (function(_this) {
          return function() {
            return _this.$el.hide();
          };
        })(this));
      };

      SearchLayoutView.prototype.serializeData = function() {
        var data;
        data = SearchLayoutView.__super__.serializeData.call(this);
        _(RESULT_TYPES).each((function(_this) {
          return function(__, key) {
            return _this.collections[key].set(_this.collection.where({
              object_type: key
            }));
          };
        })(this));
        if (!this.collection.length) {
          if (this.collection.query) {
            data.noResults = true;
            data.query = this.collection.query;
          }
        }
        return data;
      };

      SearchLayoutView.prototype.getPrimaryResultLayoutView = function() {
        return this.resultLayoutViews['unit'];
      };

      SearchLayoutView.prototype.onRender = function() {
        var resultTypeCount;
        this.$el.show();
        resultTypeCount = _(this.collections).filter((function(_this) {
          return function(c) {
            return c.length > 0;
          };
        })(this)).length;
        _(RESULT_TYPES).each((function(_this) {
          return function(__, key) {
            if (_this.collections[key].length) {
              _this.resultLayoutViews[key] = new SearchResultsLayoutView({
                resultType: key,
                collectionType: 'search',
                fullCollection: _this.collections[key],
                onlyResultType: resultTypeCount === 1,
                parent: _this
              });
              return _this._getRegionForType(key).show(_this.resultLayoutViews[key]);
            }
          };
        })(this));
        return SearchLayoutView.__super__.onRender.call(this);
      };

      return SearchLayoutView;

    })(BaseListingLayoutView);
    return {
      SearchLayoutView: SearchLayoutView,
      UnitListLayoutView: UnitListLayoutView
    };
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'app/p13n', 'app/views/base'], function(_, p13n, base) {
    var ServiceCartView;
    return ServiceCartView = (function(_super) {
      __extends(ServiceCartView, _super);

      function ServiceCartView() {
        return ServiceCartView.__super__.constructor.apply(this, arguments);
      }

      ServiceCartView.prototype.template = 'service-cart';

      ServiceCartView.prototype.tagName = 'ul';

      ServiceCartView.prototype.className = 'expanded container main-list';

      ServiceCartView.prototype.events = function() {
        return {
          'click .personalisation-container .maximizer': 'maximize',
          'keydown .personalisation-container .maximizer': this.keyboardHandler(this.maximize, ['space', 'enter']),
          'click .button.cart-close-button': 'minimize',
          'click .button.close-button': 'closeService',
          'keydown .button.close-button': this.keyboardHandler(this.closeService, ['space', 'enter']),
          'click input': 'selectLayerInput',
          'click label': 'selectLayerLabel'
        };
      };

      ServiceCartView.prototype.initialize = function(opts) {
        this.collection = opts.collection;
        this.listenTo(this.collection, 'add', this.maximize);
        this.listenTo(this.collection, 'remove', (function(_this) {
          return function() {
            if (_this.collection.length) {
              return _this.render();
            } else {
              return _this.minimize();
            }
          };
        })(this));
        this.listenTo(this.collection, 'reset', this.render);
        this.listenTo(this.collection, 'minmax', this.render);
        this.listenTo(p13n, 'change', (function(_this) {
          return function(path, value) {
            if (path[0] === 'map_background_layer') {
              return _this.render();
            }
          };
        })(this));
        if (this.collection.length) {
          return this.minimized = false;
        } else {
          return this.minimized = true;
        }
      };

      ServiceCartView.prototype.maximize = function() {
        this.minimized = false;
        return this.collection.trigger('minmax');
      };

      ServiceCartView.prototype.minimize = function() {
        this.minimized = true;
        return this.collection.trigger('minmax');
      };

      ServiceCartView.prototype.onRender = function() {
        if (this.minimized) {
          this.$el.removeClass('expanded');
          return this.$el.addClass('minimized');
        } else {
          this.$el.addClass('expanded');
          this.$el.removeClass('minimized');
          return _.defer((function(_this) {
            return function() {
              return _this.$el.find('input:checked').first().focus();
            };
          })(this));
        }
      };

      ServiceCartView.prototype.serializeData = function() {
        var data;
        if (this.minimized) {
          return {
            minimized: true
          };
        }
        data = ServiceCartView.__super__.serializeData.call(this);
        data.layers = p13n.getMapBackgroundLayers();
        return data;
      };

      ServiceCartView.prototype.closeService = function(ev) {
        return app.commands.execute('removeService', $(ev.currentTarget).data('service'));
      };

      ServiceCartView.prototype._selectLayer = function(value) {
        return p13n.setMapBackgroundLayer(value);
      };

      ServiceCartView.prototype.selectLayerInput = function(ev) {
        return this._selectLayer($(ev.currentTarget).attr('value'));
      };

      ServiceCartView.prototype.selectLayerLabel = function(ev) {
        return this._selectLayer($(ev.currentTarget).data('layer'));
      };

      return ServiceCartView;

    })(base.SMItemView);
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['i18next', 'app/views/base'], function(_arg, _arg1) {
    var SMItemView, ServiceMapDisclaimersOverlayView, ServiceMapDisclaimersView, t;
    t = _arg.t;
    SMItemView = _arg1.SMItemView;
    return {
      ServiceMapDisclaimersView: ServiceMapDisclaimersView = (function(_super) {
        __extends(ServiceMapDisclaimersView, _super);

        function ServiceMapDisclaimersView() {
          return ServiceMapDisclaimersView.__super__.constructor.apply(this, arguments);
        }

        ServiceMapDisclaimersView.prototype.template = 'description-of-service';

        ServiceMapDisclaimersView.prototype.className = 'content modal-dialog about';

        ServiceMapDisclaimersView.prototype.serializeData = function() {
          return {
            lang: p13n.getLanguage()
          };
        };

        return ServiceMapDisclaimersView;

      })(SMItemView),
      ServiceMapDisclaimersOverlayView: ServiceMapDisclaimersOverlayView = (function(_super) {
        __extends(ServiceMapDisclaimersOverlayView, _super);

        function ServiceMapDisclaimersOverlayView() {
          return ServiceMapDisclaimersOverlayView.__super__.constructor.apply(this, arguments);
        }

        ServiceMapDisclaimersOverlayView.prototype.template = 'disclaimers-overlay';

        ServiceMapDisclaimersOverlayView.prototype.serializeData = function() {
          var copyrightLink, layer;
          layer = p13n.get('map_background_layer');
          if (layer === 'servicemap' || layer === 'accessible_map') {
            copyrightLink = "https://www.openstreetmap.org/copyright";
          }
          return {
            copyright: t("disclaimer.copyright." + layer),
            copyrightLink: copyrightLink
          };
        };

        ServiceMapDisclaimersOverlayView.prototype.events = {
          'click #about-the-service': 'onAboutClick'
        };

        ServiceMapDisclaimersOverlayView.prototype.onAboutClick = function(ev) {
          return app.commands.execute('showServiceMapDescription');
        };

        return ServiceMapDisclaimersOverlayView;

      })(SMItemView)
    };
  });

}).call(this);

//

(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['underscore', 'i18next', 'app/models', 'app/views/base'], function(_, i18n, models, base) {
    var ServiceTreeView;
    return ServiceTreeView = (function(_super) {
      __extends(ServiceTreeView, _super);

      function ServiceTreeView() {
        return ServiceTreeView.__super__.constructor.apply(this, arguments);
      }

      ServiceTreeView.prototype.id = 'service-tree-container';

      ServiceTreeView.prototype.className = 'navigation-element';

      ServiceTreeView.prototype.template = 'service-tree';

      ServiceTreeView.prototype.events = function() {
        var openOnKbd, toggleOnKbd;
        openOnKbd = this.keyboardHandler(this.openService, ['enter']);
        toggleOnKbd = this.keyboardHandler(this.toggleLeafButton, ['enter', 'space']);
        return {
          'click .service.has-children': 'openService',
          'keydown .service.parent': openOnKbd,
          'keydown .service.has-children': openOnKbd,
          'keydown .service.has-children a.show-icon': toggleOnKbd,
          'click .service.parent': 'openService',
          'click .crumb': 'handleBreadcrumbClick',
          'click .service.leaf': 'toggleLeaf',
          'keydown .service.leaf': toggleOnKbd,
          'click .service .show-icon': 'toggleButton',
          'mouseenter .service .show-icon': 'showTooltip',
          'mouseleave .service .show-icon': 'removeTooltip'
        };
      };

      ServiceTreeView.prototype.type = 'service-tree';

      ServiceTreeView.prototype.initialize = function(options) {
        this.selectedServices = options.selectedServices;
        this.breadcrumbs = options.breadcrumbs;
        this.animationType = 'left';
        this.scrollPosition = 0;
        this.listenTo(this.selectedServices, 'remove', this.render);
        this.listenTo(this.selectedServices, 'add', this.render);
        return this.listenTo(this.selectedServices, 'reset', this.render);
      };

      ServiceTreeView.prototype.toggleLeaf = function(event) {
        return this.toggleElement($(event.currentTarget).find('.show-icon'));
      };

      ServiceTreeView.prototype.toggleLeafButton = function(event) {
        return this.toggleElement($(event.currentTarget));
      };

      ServiceTreeView.prototype.toggleButton = function(event) {
        this.removeTooltip();
        event.preventDefault();
        event.stopPropagation();
        return this.toggleElement($(event.target));
      };

      ServiceTreeView.prototype.showTooltip = function(event) {
        var $targetEl, buttonOffset, originalOffset;
        this.removeTooltip();
        this.$tooltipElement = $("<div id=\"tooltip\">" + (i18n.t('sidebar.show_tooltip')) + "</div>");
        $targetEl = $(event.currentTarget);
        $('body').append(this.$tooltipElement);
        buttonOffset = $targetEl.offset();
        originalOffset = this.$tooltipElement.offset();
        this.$tooltipElement.css('top', "" + (buttonOffset.top + originalOffset.top) + "px");
        return this.$tooltipElement.css('left', "" + (buttonOffset.left + originalOffset.left) + "px");
      };

      ServiceTreeView.prototype.removeTooltip = function(event) {
        var _ref;
        return (_ref = this.$tooltipElement) != null ? _ref.remove() : void 0;
      };

      ServiceTreeView.prototype.getShowIconClasses = function(showing, rootId) {
        if (showing) {
          return "show-icon selected service-color-" + rootId;
        } else {
          return "show-icon service-hover-color-" + rootId;
        }
      };

      ServiceTreeView.prototype.toggleElement = function($targetElement) {
        var service, serviceId;
        serviceId = $targetElement.closest('li').data('service-id');
        if (this.selected(serviceId) !== true) {
          app.commands.execute('clearSearchResults');
          service = new models.Service({
            id: serviceId
          });
          return service.fetch({
            success: (function(_this) {
              return function() {
                return app.commands.execute('addService', service);
              };
            })(this)
          });
        } else {
          return app.commands.execute('removeService', serviceId);
        }
      };

      ServiceTreeView.prototype.handleBreadcrumbClick = function(event) {
        event.preventDefault();
        event.stopPropagation();
        return this.openService(event);
      };

      ServiceTreeView.prototype.openService = function(event) {
        var $target, index, serviceId, serviceName, spinnerOptions;
        $target = $(event.currentTarget);
        serviceId = $target.data('service-id');
        serviceName = $target.data('service-name');
        this.animationType = $target.data('slide-direction');
        if (!serviceId) {
          return null;
        }
        if (serviceId === 'root') {
          serviceId = null;
          this.breadcrumbs.splice(0, this.breadcrumbs.length);
        } else {
          index = _.indexOf(_.pluck(this.breadcrumbs, 'serviceId'), serviceId);
          if (index !== -1) {
            this.breadcrumbs.splice(index, this.breadcrumbs.length - index);
          }
          this.breadcrumbs.push({
            serviceId: serviceId,
            serviceName: serviceName
          });
        }
        spinnerOptions = {
          container: $target.get(0),
          hideContainerContent: true
        };
        return this.collection.expand(serviceId, spinnerOptions);
      };

      ServiceTreeView.prototype.onRender = function() {
        var $targetElement, $ul;
        if (this.serviceToDisplay) {
          $targetElement = this.$el.find("[data-service-id=" + this.serviceToDisplay.id + "]").find('.show-icon');
          this.serviceToDisplay = false;
          this.toggleElement($targetElement);
        }
        $ul = this.$el.find('ul');
        $ul.on('scroll', (function(_this) {
          return function(ev) {
            return _this.scrollPosition = ev.currentTarget.scrollTop;
          };
        })(this));
        $ul.scrollTop(this.scrollPosition);
        this.scrollPosition = 0;
        return this.setBreadcrumbWidths();
      };

      ServiceTreeView.prototype.setBreadcrumbWidths = function() {
        var $chevrons, $container, $crumbs, $lastCrumb, CRUMB_MIN_WIDTH, crumbWidth, lastWidth, spaceAvailable, spaceNeeded;
        CRUMB_MIN_WIDTH = 40;
        $container = this.$el.find('.header-item').last();
        $crumbs = $container.find('.crumb');
        if (!($crumbs.length > 1)) {
          return;
        }
        $lastCrumb = $crumbs.last();
        $crumbs = $crumbs.not(':last');
        $chevrons = $container.find('.icon-icon-forward');
        spaceAvailable = $container.width() - ($chevrons.length * $chevrons.first().outerWidth());
        lastWidth = $lastCrumb.width();
        spaceNeeded = lastWidth + $crumbs.length * CRUMB_MIN_WIDTH;
        if (spaceNeeded > spaceAvailable) {
          lastWidth = spaceAvailable - $crumbs.length * CRUMB_MIN_WIDTH;
          $lastCrumb.css({
            'max-width': lastWidth
          });
          return $crumbs.css({
            'max-width': CRUMB_MIN_WIDTH
          });
        } else {
          crumbWidth = (spaceAvailable - lastWidth) / $crumbs.length;
          return $crumbs.css({
            'max-width': crumbWidth
          });
        }
      };

      ServiceTreeView.prototype.selected = function(serviceId) {
        return this.selectedServices.get(serviceId) != null;
      };

      ServiceTreeView.prototype.close = function() {
        this.removeTooltip();
        this.remove();
        return this.stopListening();
      };

      ServiceTreeView.prototype.serializeData = function() {
        var back, classes, data, listItems, parentItem;
        classes = function(category) {
          if (category.get('children').length > 0) {
            return ['service has-children'];
          } else {
            return ['service leaf'];
          }
        };
        listItems = this.collection.map((function(_this) {
          return function(category) {
            var rootId, selected;
            selected = _this.selected(category.id);
            rootId = category.get('root');
            return {
              id: category.get('id'),
              name: category.getText('name'),
              classes: classes(category).join(" "),
              has_children: category.attributes.children.length > 0,
              unit_count: category.attributes.unit_count || 1,
              selected: selected,
              root_id: rootId,
              show_icon_classes: _this.getShowIconClasses(selected, rootId)
            };
          };
        })(this));
        parentItem = {};
        back = null;
        if (this.collection.chosenService) {
          back = this.collection.chosenService.get('parent') || 'root';
          parentItem.name = this.collection.chosenService.getText('name');
          parentItem.rootId = this.collection.chosenService.get('root');
        }
        return data = {
          back: back,
          parent_item: parentItem,
          list_items: listItems,
          breadcrumbs: _.initial(this.breadcrumbs)
        };
      };

      ServiceTreeView.prototype.onRender = function() {
        var $target;
        $target = null;
        if (this.collection.chosenService) {
          $target = this.$el.find('li.service.parent.header-item');
        } else {
          $target = this.$el.find('li.service').first();
        }
        return _.defer((function(_this) {
          return function() {
            return $target.focus().addClass('autofocus').on('blur', function() {
              return $target.removeClass('autofocus');
            });
          };
        })(this));
      };

      return ServiceTreeView;

    })(base.SMLayout);
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['underscore', 'backbone.marionette', 'app/jade', 'app/animations'], function(_, Marionette, jade, animations) {
    var SidebarRegion;
    SidebarRegion = (function(_super) {
      var SUPPORTED_ANIMATIONS;

      __extends(SidebarRegion, _super);

      function SidebarRegion() {
        this.show = __bind(this.show, this);
        this._trigger = __bind(this._trigger, this);
        return SidebarRegion.__super__.constructor.apply(this, arguments);
      }

      SUPPORTED_ANIMATIONS = ['left', 'right'];

      SidebarRegion.prototype._trigger = function(eventName, view) {
        Marionette.triggerMethod.call(this, eventName, view);
        if (_.isFunction(view.triggerMethod)) {
          return view.triggerMethod(eventName);
        } else {
          return Marionette.triggerMethod.call(view, eventName);
        }
      };

      SidebarRegion.prototype.show = function(view, options) {
        var $container, $newContent, $oldContent, animationCallback, animationType, data, isDifferentView, isViewClosed, preventClose, shouldAnimate, showOptions, templateString, _ref, _shouldCloseView;
        showOptions = options || {};
        this.ensureEl();
        isViewClosed = view.isClosed || _.isUndefined(view.$el);
        isDifferentView = view !== this.currentView;
        preventClose = !!showOptions.preventClose;
        _shouldCloseView = !preventClose && isDifferentView;
        animationType = showOptions.animationType;
        $oldContent = (_ref = this.currentView) != null ? _ref.$el : void 0;
        shouldAnimate = ($oldContent != null ? $oldContent.length : void 0) && __indexOf.call(SUPPORTED_ANIMATIONS, animationType) >= 0 && (view.template != null);
        if (shouldAnimate) {
          data = (typeof view.serializeData === "function" ? view.serializeData() : void 0) || {};
          templateString = jade.template(view.template, data);
          $container = this.$el;
          $newContent = view.$el.append($(templateString));
          this._trigger('before:render', view);
          this._trigger('before:show', view);
          animationCallback = (function(_this) {
            return function() {
              if (_shouldCloseView) {
                _this.close();
              }
              _this.currentView = view;
              _this._trigger('render', view);
              return _this._trigger('show', view);
            };
          })(this);
          animations.render($container, $oldContent, $newContent, animationType, animationCallback);
        } else {
          if (_shouldCloseView) {
            this.close();
          }
          view.render();
          this._trigger('before:show', view);
          if (isDifferentView || isViewClosed) {
            this.open(view);
          }
          this.currentView = view;
          this._trigger('show', view);
        }
        return this;
      };

      SidebarRegion.prototype.close = function() {
        var view;
        view = this.currentView;
        if (!view || view.isClosed) {
          return;
        }
        if (view.close) {
          view.close();
        } else if (view.remove) {
          view.remove();
        }
        Marionette.triggerMethod.call(this, 'close', view);
        return delete this.currentView;
      };

      return SidebarRegion;

    })(Marionette.Region);
    return SidebarRegion;
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['app/p13n', 'app/jade', 'app/views/base'], function(p13n, jade, base) {
    var LandingTitleView, TitleView;
    TitleView = (function(_super) {
      __extends(TitleView, _super);

      function TitleView() {
        this.render = __bind(this.render, this);
        return TitleView.__super__.constructor.apply(this, arguments);
      }

      TitleView.prototype.className = 'title-control';

      TitleView.prototype.render = function() {
        this.el.innerHTML = jade.template('title-view', {
          lang: p13n.getLanguage(),
          root: appSettings.url_prefix
        });
        return this.el;
      };

      return TitleView;

    })(base.SMItemView);
    LandingTitleView = (function(_super) {
      __extends(LandingTitleView, _super);

      function LandingTitleView() {
        return LandingTitleView.__super__.constructor.apply(this, arguments);
      }

      LandingTitleView.prototype.template = 'landing-title-view';

      LandingTitleView.prototype.id = 'title';

      LandingTitleView.prototype.className = 'landing-title-control';

      LandingTitleView.prototype.initialize = function() {
        this.listenTo(app.vent, 'title-view:hide', this.hideTitleView);
        return this.listenTo(app.vent, 'title-view:show', this.unHideTitleView);
      };

      LandingTitleView.prototype.serializeData = function() {
        return {
          isHidden: this.isHidden,
          lang: p13n.getLanguage()
        };
      };

      LandingTitleView.prototype.hideTitleView = function() {
        $('body').removeClass('landing');
        this.isHidden = true;
        return this.render();
      };

      LandingTitleView.prototype.unHideTitleView = function() {
        $('body').addClass('landing');
        this.isHidden = false;
        return this.render();
      };

      return LandingTitleView;

    })(base.SMItemView);
    return {
      TitleView: TitleView,
      LandingTitleView: LandingTitleView
    };
  });

}).call(this);

//

(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['i18next', 'harvey', 'app/p13n', 'app/dateformat', 'app/draw', 'app/map-view', 'app/views/base', 'app/views/route', 'app/views/accessibility'], function(i18n, _harvey, p13n, dateformat, draw, MapView, base, RouteView, _arg) {
    var AccessibilityDetailsView, EventListRowView, EventListView, FeedbackItemView, FeedbackListView, UnitDetailsView;
    AccessibilityDetailsView = _arg.AccessibilityDetailsView;
    UnitDetailsView = (function(_super) {
      __extends(UnitDetailsView, _super);

      function UnitDetailsView() {
        this.updateEventsUi = __bind(this.updateEventsUi, this);
        return UnitDetailsView.__super__.constructor.apply(this, arguments);
      }

      UnitDetailsView.prototype.id = 'details-view-container';

      UnitDetailsView.prototype.className = 'navigation-element';

      UnitDetailsView.prototype.template = 'details';

      UnitDetailsView.prototype.regions = {
        'routeRegion': '.section.route-section',
        'accessibilityRegion': '.section.accessibility-section',
        'eventsRegion': '.event-list',
        'feedbackRegion': '.feedback-list'
      };

      UnitDetailsView.prototype.events = {
        'click .back-button': 'userClose',
        'click .icon-icon-close': 'userClose',
        'click .map-active-area': 'showMap',
        'click .show-map': 'showMap',
        'click .mobile-header': 'showContent',
        'click .show-more-events': 'showMoreEvents',
        'click .disabled': 'preventDisabledClick',
        'click .set-accessibility-profile': 'openAccessibilityMenu',
        'click .leave-feedback': 'leaveFeedbackOnAccessibility',
        'click .section.main-info .description .body-expander': 'toggleDescriptionBody',
        'show.bs.collapse': 'scrollToExpandedSection',
        'click .send-feedback': '_onClickSendFeedback'
      };

      UnitDetailsView.prototype.type = 'details';

      UnitDetailsView.prototype.initialize = function(options) {
        this.INITIAL_NUMBER_OF_EVENTS = 5;
        this.NUMBER_OF_EVENTS_FETCHED = 20;
        this.embedded = options.embedded;
        this.searchResults = options.searchResults;
        this.selectedUnits = options.selectedUnits;
        this.selectedPosition = options.selectedPosition;
        this.routingParameters = options.routingParameters;
        this.route = options.route;
        return this.listenTo(this.searchResults, 'reset', this.render);
      };

      UnitDetailsView.prototype._$getMobileHeader = function() {
        return this.$el.find('.mobile-header');
      };

      UnitDetailsView.prototype._$getDefaultHeader = function() {
        return this.$el.find('.content .main-info .header');
      };

      UnitDetailsView.prototype._hideHeader = function($header) {
        return $header.attr('aria-hidden', 'true');
      };

      UnitDetailsView.prototype._showHeader = function($header) {
        return $header.removeAttr('aria-hidden');
      };

      UnitDetailsView.prototype._attachMobileHeaderListeners = function() {
        Harvey.attach('(max-width:767px)', {
          on: (function(_this) {
            return function() {
              _this._hideHeader(_this._$getDefaultHeader());
              return _this._showHeader(_this._$getMobileHeader());
            };
          })(this)
        });
        return Harvey.attach('(min-width:768px)', {
          on: (function(_this) {
            return function() {
              _this._hideHeader(_this._$getMobileHeader());
              return _this._showHeader(_this._$getDefaultHeader());
            };
          })(this)
        });
      };

      UnitDetailsView.prototype._onClickSendFeedback = function(ev) {
        return app.commands.execute('composeFeedback', this.model);
      };

      UnitDetailsView.prototype.onRender = function() {
        var color, context, contextMobile, id, marker, markerCanvas, markerCanvasMobile, rotation, size;
        if (this.model.eventList.isEmpty()) {
          this.listenTo(this.model.eventList, 'reset', (function(_this) {
            return function(list) {
              _this.updateEventsUi(list.fetchState);
              return _this.renderEvents(list);
            };
          })(this));
          this.model.eventList.pageSize = this.INITIAL_NUMBER_OF_EVENTS;
          this.model.getEvents();
          this.model.eventList.pageSize = this.NUMBER_OF_EVENTS_FETCHED;
          this.model.getFeedback();
        } else {
          this.updateEventsUi(this.model.eventList.fetchState);
          this.renderEvents(this.model.eventList);
        }
        if (this.model.feedbackList.isEmpty()) {
          this.listenTo(this.model.feedbackList, 'reset', (function(_this) {
            return function(list) {
              return _this.renderFeedback(_this.model.feedbackList);
            };
          })(this));
        } else {
          this.renderFeedback(this.model.feedbackList);
        }
        this.accessibilityRegion.show(new AccessibilityDetailsView({
          model: this.model
        }));
        this.routeRegion.show(new RouteView({
          model: this.model,
          route: this.route,
          parentView: this,
          routingParameters: this.routingParameters,
          selectedUnits: this.selectedUnits,
          selectedPosition: this.selectedPosition
        }));
        app.vent.trigger('site-title:change', this.model.get('name'));
        this._attachMobileHeaderListeners();
        markerCanvas = this.$el.find('#details-marker-canvas').get(0);
        markerCanvasMobile = this.$el.find('#details-marker-canvas-mobile').get(0);
        context = markerCanvas.getContext('2d');
        contextMobile = markerCanvasMobile.getContext('2d');
        size = 40;
        color = app.colorMatcher.unitColor(this.model) || 'rgb(0, 0, 0)';
        id = 0;
        rotation = 90;
        marker = new draw.Plant(size, color, id, rotation);
        marker.draw(context);
        marker.draw(contextMobile);
        return _.defer((function(_this) {
          return function() {
            return _this.$el.find('a').first().focus();
          };
        })(this));
      };

      UnitDetailsView.prototype.updateEventsUi = function(fetchState) {
        var $eventsSection, shortText, _ref;
        $eventsSection = this.$el.find('.events-section');
        if (fetchState.count) {
          shortText = i18n.t('sidebar.event_count', {
            count: fetchState.count
          });
        } else {
          shortText = i18n.t('sidebar.no_events');
          this.$('.show-more-events').hide();
          $eventsSection.find('.collapser').addClass('disabled');
        }
        $eventsSection.find('.short-text').text(shortText);
        if (!fetchState.next && this.model.eventList.length === ((_ref = this.eventsRegion.currentView) != null ? _ref.collection.length : void 0)) {
          return this.$('.show-more-events').hide();
        }
      };

      UnitDetailsView.prototype.userClose = function(event) {
        event.stopPropagation();
        app.commands.execute('clearSelectedUnit');
        if (!this.searchResults.isEmpty()) {
          app.commands.execute('search', this.searchResults.query);
        }
        return this.trigger('user:close');
      };

      UnitDetailsView.prototype.preventDisabledClick = function(event) {
        event.preventDefault();
        return event.stopPropagation();
      };

      UnitDetailsView.prototype.showMap = function(event) {
        event.preventDefault();
        this.$el.addClass('minimized');
        return MapView.setMapActiveAreaMaxHeight({
          maximize: true
        });
      };

      UnitDetailsView.prototype.showContent = function(event) {
        event.preventDefault();
        this.$el.removeClass('minimized');
        return MapView.setMapActiveAreaMaxHeight({
          maximize: false
        });
      };

      UnitDetailsView.prototype.getTranslatedProvider = function(providerType) {
        var SUPPORTED_PROVIDER_TYPES;
        SUPPORTED_PROVIDER_TYPES = [101, 102, 103, 104, 105];
        if (__indexOf.call(SUPPORTED_PROVIDER_TYPES, providerType) >= 0) {
          return i18n.t("sidebar.provider_type." + providerType);
        } else {
          return '';
        }
      };

      UnitDetailsView.prototype.serializeData = function() {
        var MAX_LENGTH, data, description, embedded, words;
        embedded = this.embedded;
        data = this.model.toJSON();
        data.provider = this.getTranslatedProvider(this.model.get('provider_type'));
        if (!this.searchResults.isEmpty()) {
          data.back_to = i18n.t('sidebar.back_to.search');
        }
        MAX_LENGTH = 20;
        description = data.description;
        if (description) {
          words = description.split(/[ ]+/);
          if (words.length > MAX_LENGTH + 1) {
            data.description_ingress = words.slice(0, MAX_LENGTH).join(' ');
            data.description_body = words.slice(MAX_LENGTH).join(' ');
          } else {
            data.description_ingress = description;
          }
        }
        data.embedded_mode = embedded;
        data.feedback_count = this.model.feedbackList.length;
        return data;
      };

      UnitDetailsView.prototype.renderEvents = function(events) {
        if (events != null) {
          if (!events.isEmpty()) {
            this.$el.find('.section.events-section').removeClass('hidden');
            return this.eventsRegion.show(new EventListView({
              collection: events
            }));
          }
        }
      };

      UnitDetailsView.prototype._feedbackSummary = function(feedbackItems) {
        var count;
        count = feedbackItems.size();
        if (count) {
          return i18n.t('feedback.count', {
            count: count
          });
        } else {
          return '';
        }
      };

      UnitDetailsView.prototype.renderFeedback = function(feedbackItems) {
        var $feedbackSection, feedbackSummary;
        if (this.model.get('organization') !== 91) {
          return;
        }
        if (feedbackItems != null) {
          feedbackItems.unit = this.model;
          feedbackSummary = this._feedbackSummary(feedbackItems);
          $feedbackSection = this.$el.find('.feedback-section');
          $feedbackSection.find('.short-text').text(feedbackSummary);
          $feedbackSection.find('.feedback-count').text(feedbackSummary);
          return this.feedbackRegion.show(new FeedbackListView({
            collection: feedbackItems
          }));
        }
      };

      UnitDetailsView.prototype.showMoreEvents = function(event) {
        var options;
        event.preventDefault();
        options = {
          spinnerOptions: {
            container: this.$('.show-more-events').get(0),
            hideContainerContent: true
          }
        };
        if (this.model.eventList.length <= this.INITIAL_NUMBER_OF_EVENTS) {
          return this.model.getEvents({}, options);
        } else {
          options.success = (function(_this) {
            return function() {
              return _this.updateEventsUi(_this.model.eventList.fetchState);
            };
          })(this);
          return this.model.eventList.fetchNext(options);
        }
      };

      UnitDetailsView.prototype.toggleDescriptionBody = function(ev) {
        var $target;
        $target = $(ev.currentTarget);
        $target.toggle();
        return $target.closest('.description').find('.body').toggle();
      };

      UnitDetailsView.prototype.scrollToExpandedSection = function(event) {
        var $container, $section, scrollTo;
        $container = this.$el.find('.content').first();
        if ($(event.target).hasClass('steps')) {
          return;
        }
        $section = $(event.target).closest('.section');
        scrollTo = $container.scrollTop() + $section.position().top;
        return $('#details-view-container .content').animate({
          scrollTop: scrollTo
        });
      };

      UnitDetailsView.prototype.openAccessibilityMenu = function(event) {
        event.preventDefault();
        return p13n.trigger('user:open');
      };

      return UnitDetailsView;

    })(base.SMLayout);
    EventListRowView = (function(_super) {
      __extends(EventListRowView, _super);

      function EventListRowView() {
        return EventListRowView.__super__.constructor.apply(this, arguments);
      }

      EventListRowView.prototype.tagName = 'li';

      EventListRowView.prototype.template = 'event-list-row';

      EventListRowView.prototype.events = {
        'click .show-event-details': 'showEventDetails'
      };

      EventListRowView.prototype.serializeData = function() {
        var endTime, formattedDatetime, startTime;
        startTime = this.model.get('start_time');
        endTime = this.model.get('end_time');
        formattedDatetime = dateformat.humanizeEventDatetime(startTime, endTime, 'small');
        return {
          name: p13n.getTranslatedAttr(this.model.get('name')),
          datetime: formattedDatetime,
          info_url: p13n.getTranslatedAttr(this.model.get('info_url'))
        };
      };

      EventListRowView.prototype.showEventDetails = function(event) {
        event.preventDefault();
        return app.commands.execute('selectEvent', this.model);
      };

      return EventListRowView;

    })(base.SMItemView);
    EventListView = (function(_super) {
      __extends(EventListView, _super);

      function EventListView() {
        return EventListView.__super__.constructor.apply(this, arguments);
      }

      EventListView.prototype.tagName = 'ul';

      EventListView.prototype.className = 'events';

      EventListView.prototype.itemView = EventListRowView;

      EventListView.prototype.initialize = function(opts) {
        return this.parent = opts.parent;
      };

      return EventListView;

    })(base.SMCollectionView);
    FeedbackItemView = (function(_super) {
      __extends(FeedbackItemView, _super);

      function FeedbackItemView() {
        return FeedbackItemView.__super__.constructor.apply(this, arguments);
      }

      FeedbackItemView.prototype.tagName = 'li';

      FeedbackItemView.prototype.template = 'feedback-list-row';

      FeedbackItemView.prototype.initialize = function(options) {
        return this.unit = options.unit;
      };

      FeedbackItemView.prototype.serializeData = function() {
        var data;
        data = FeedbackItemView.__super__.serializeData.call(this);
        data.unit = this.unit.toJSON();
        return data;
      };

      return FeedbackItemView;

    })(base.SMItemView);
    FeedbackListView = (function(_super) {
      __extends(FeedbackListView, _super);

      function FeedbackListView() {
        return FeedbackListView.__super__.constructor.apply(this, arguments);
      }

      FeedbackListView.prototype.tagName = 'ul';

      FeedbackListView.prototype.className = 'feedback';

      FeedbackListView.prototype.itemView = FeedbackItemView;

      FeedbackListView.prototype.itemViewOptions = function() {
        return {
          unit: this.collection.unit
        };
      };

      return FeedbackListView;

    })(base.SMCollectionView);
    return UnitDetailsView;
  });

}).call(this);

//

(function() {
  var __slice = [].slice;

  define(['app/draw', 'leaflet', 'leaflet.markercluster', 'underscore', 'jquery', 'backbone', 'app/jade'], function(draw, leaflet, markercluster, _, $, Backbone, jade) {
    var CanvasIcon, CirclePolygon, REDUCED_OPACITY, SMMarker, anchor, createMarker, initializer;
    anchor = function(size) {
      var x, y;
      x = size.x / 3 + 5;
      y = size.y / 2 + 16;
      return new L.Point(x, y);
    };
    SMMarker = L.Marker;
    REDUCED_OPACITY = 1;
    initializer = function() {
      var OriginalMarkerCluster, SMMarkerCluster;
      REDUCED_OPACITY = 0.5;
      OriginalMarkerCluster = L.MarkerCluster;
      SMMarkerCluster = L.MarkerCluster.extend({
        setOpacity: function(opacity) {
          var children, reducedProminence, _ref, _ref1;
          children = this.getAllChildMarkers();
          reducedProminence = false;
          if (children.length) {
            reducedProminence = (_ref = children[0].unit) != null ? (_ref1 = _ref.collection) != null ? _ref1.hasReducedPriority() : void 0 : void 0;
          }
          if (reducedProminence && opacity === 1) {
            opacity = REDUCED_OPACITY;
          }
          return OriginalMarkerCluster.prototype.setOpacity.call(this, opacity);
        }
      });
      L.MarkerCluster = SMMarkerCluster;
      return SMMarker = L.Marker.extend({
        setOpacity: function(opacity) {
          if (this.options.reducedProminence && opacity === 1) {
            opacity = REDUCED_OPACITY;
          }
          return L.Marker.prototype.setOpacity.call(this, opacity);
        }
      });
    };
    createMarker = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(SMMarker, args, function(){});
    };
    CanvasIcon = L.Icon.extend({
      initialize: function(dimension, options) {
        this.dimension = dimension;
        this.options.iconSize = new L.Point(this.dimension, this.dimension);
        this.options.iconAnchor = this.iconAnchor();
        this.options.reducedProminence = options.reducedProminence;
        return this.options.pixelRatio = function(el) {
          var backingStoreRatio, context, devicePixelRatio;
          context = el.getContext('2d');
          devicePixelRatio = window.devicePixelRatio || 1;
          backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
          return devicePixelRatio / backingStoreRatio;
        };
      },
      options: {
        className: 'leaflet-canvas-icon'
      },
      setupCanvas: function() {
        var context, el, ratio, s;
        el = document.createElement('canvas');
        context = el.getContext('2d');
        ratio = this.options.pixelRatio(el);
        if (typeof G_vmlCanvasManager !== "undefined" && G_vmlCanvasManager !== null) {
          G_vmlCanvasManager.initElement(el);
        }
        this._setIconStyles(el, 'icon');
        s = this.options.iconSize;
        el.width = s.x * ratio;
        el.height = s.y * ratio;
        el.style.width = s.x + 'px';
        el.style.height = s.y + 'px';
        context.scale(ratio, ratio);
        if (this.options.reducedProminence) {
          L.DomUtil.setOpacity(el, REDUCED_OPACITY);
        }
        return el;
      },
      createIcon: function() {
        var el;
        el = this.setupCanvas();
        this.draw(el.getContext('2d'));
        return el;
      },
      createShadow: function() {
        return null;
      },
      iconAnchor: function() {
        return anchor(this.options.iconSize);
      }
    });
    CirclePolygon = L.Polygon.extend({
      initialize: function(latLng, radius, options) {
        var latLngs;
        this.circle = L.circle(latLng, radius);
        latLngs = this._calculateLatLngs();
        return L.Polygon.prototype.initialize.call(this, [latLngs], options);
      },
      _calculateLatLngs: function() {
        var STEPS, bounds, center, east, i, latRadius, lngRadius, north, rad, _i, _results;
        bounds = this.circle.getBounds();
        north = bounds.getNorth();
        east = bounds.getEast();
        center = this.circle.getLatLng();
        lngRadius = east - center.lng;
        latRadius = north - center.lat;
        STEPS = 180;
        _results = [];
        for (i = _i = 0; 0 <= STEPS ? _i < STEPS : _i > STEPS; i = 0 <= STEPS ? ++_i : --_i) {
          rad = (2 * i * Math.PI) / STEPS;
          _results.push([center.lat + Math.sin(rad) * latRadius, center.lng + Math.cos(rad) * lngRadius]);
        }
        return _results;
      }
    });
    return {
      PlantCanvasIcon: CanvasIcon.extend({
        initialize: function(dimension, color, id, options) {
          this.dimension = dimension;
          this.color = color;
          CanvasIcon.prototype.initialize.call(this, this.dimension, options);
          return this.plant = new draw.Plant(this.dimension, this.color, id);
        },
        draw: function(ctx) {
          return this.plant.draw(ctx);
        }
      }),
      PointCanvasIcon: CanvasIcon.extend({
        initialize: function(dimension, color, id) {
          this.dimension = dimension;
          this.color = color;
          CanvasIcon.prototype.initialize.call(this, this.dimension);
          return this.drawer = new draw.PointPlant(this.dimension, this.color, 2);
        },
        draw: function(ctx) {
          return this.drawer.draw(ctx);
        }
      }),
      CanvasClusterIcon: CanvasIcon.extend({
        initialize: function(count, dimension, colors, id, options) {
          var rotations, translations, _i, _ref, _results;
          this.count = count;
          this.dimension = dimension;
          this.colors = colors;
          CanvasIcon.prototype.initialize.call(this, this.dimension, options);
          this.options.iconSize = new L.Point(this.dimension + 30, this.dimension + 30);
          if (this.count > 5) {
            this.count = 5;
          }
          rotations = [130, 110, 90, 70, 50];
          translations = [[0, 5], [10, 7], [12, 8], [15, 10], [5, 12]];
          return this.plants = _.map((function() {
            _results = [];
            for (var _i = 1, _ref = this.count; 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this), (function(_this) {
            return function(i) {
              return new draw.Plant(_this.dimension, _this.colors[(i - 1) % _this.colors.length], id, rotations[i - 1], translations[i - 1]);
            };
          })(this));
        },
        draw: function(ctx) {
          var plant, _i, _len, _ref, _results;
          _ref = this.plants;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            plant = _ref[_i];
            _results.push(plant.draw(ctx));
          }
          return _results;
        }
      }),
      PointCanvasClusterIcon: CanvasIcon.extend({
        initialize: function(count, dimension, colors, id) {
          var range, _i, _ref, _results;
          this.dimension = dimension;
          this.colors = colors;
          CanvasIcon.prototype.initialize.call(this, this.dimension);
          this.count = (Math.min(20, count) / 5) * 5;
          this.radius = 2;
          range = (function(_this) {
            return function() {
              return _this.radius + Math.random() * (_this.dimension - 2 * _this.radius);
            };
          })(this);
          this.positions = _.map((function() {
            _results = [];
            for (var _i = 1, _ref = this.count; 1 <= _ref ? _i <= _ref : _i >= _ref; 1 <= _ref ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this), (function(_this) {
            return function(i) {
              return [range(), range()];
            };
          })(this));
          return this.clusterDrawer = new draw.PointCluster(this.dimension, this.colors, this.positions, this.radius);
        },
        draw: function(ctx) {
          return this.clusterDrawer.draw(ctx);
        }
      }),
      LeftAlignedPopup: L.Popup.extend({
        _updatePosition: function() {
          var animated, offset, pos, properOffset;
          if (!this._map) {
            return;
          }
          pos = this._map.latLngToLayerPoint(this._latlng);
          animated = this._animated;
          offset = L.point(this.options.offset);
          properOffset = {
            x: 15,
            y: -27
          };
          if (animated) {
            pos.y = pos.y + properOffset.y;
            pos.x = pos.x + properOffset.x;
            L.DomUtil.setPosition(this._container, pos);
          }
          this._containerBottom = -offset.y - (animated ? 0 : pos.y + properOffset.y);
          this._containerLeft = offset.x + (animated ? 0 : pos.x + properOffset.x);
          this._container.style.bottom = this._containerBottom + 'px';
          return this._container.style.left = this._containerLeft + 'px';
        }
      }),
      ControlWrapper: L.Control.extend({
        initialize: function(view, options) {
          this.view = view;
          return L.Util.setOptions(this, options);
        },
        onAdd: function(map) {
          return this.view.render();
        }
      }),
      initializer: initializer,
      createMarker: createMarker,
      CirclePolygon: CirclePolygon
    };
  });

}).call(this);

//

//# sourceMappingURL=bundle.js.map
